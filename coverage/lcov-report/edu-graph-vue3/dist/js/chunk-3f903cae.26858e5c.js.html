
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for edu-graph-vue3/dist/js/chunk-3f903cae.26858e5c.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../prettify.css" />
    <link rel="stylesheet" href="../../../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../index.html">All files</a> / <a href="index.html">edu-graph-vue3/dist/js</a> chunk-3f903cae.26858e5c.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/11302</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/10661</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/2866</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-3f903cae"],{"093e":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0}),e.CacheStatusEnum=void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t[t["One"]=1]="One",t[t["Two"]=2]="Two"}</span>(e.CacheStatusEnum||(e.CacheStatusEnum={}))}</span>,"094f":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,"0b53":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0}),e.AccountEnum=e.RepositoryEnum=e.UserEnum=void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["Personal"]="personal",t["Organization"]="organization"}</span>(e.UserEnum||(e.UserEnum={})),<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["Public"]="public",t["Private"]="private"}</span>(e.RepositoryEnum||(e.RepositoryEnum={})),<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["Admin"]="admin",t["User"]="user"}</span>(e.AccountEnum||(e.AccountEnum={}))}</span>,"238c":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0}),e.DatabaseEnum=void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["User"]="User",t["Admin"]="Admin",t["Organization"]="Organization",t["MailCode"]="MailCode",t["AdminToken"]="AdminToken",t["Token"]="Token",t["AdminRole"]="AdminRole",t["AdminPageRouteAuth"]="AdminPageRouteAuth",t["AdminPageOperationAuth"]="AdminPageOperationAuth",t["AdminAPIAuth"]="AdminAPIAuth",t["RichText"]="RichText",t["File"]="File",t["Domain"]="Domain",t["KnowledgeGraphEdge"]="KnowledgeGraphEdge",t["KnowledgeBaseType"]="KnowledgeBaseType",t["Knowledge"]="Knowledge",t["AlternativeKnowledge"]="AlternativeKnowledge",t["KnowledgeArticle"]="KnowledgeArticle",t["Level"]="Level",t["LevelBaseType"]="LevelBaseType",t["Section"]="Section",t["SectionEntity"]="SectionEntity",t["SectionArticle"]="SectionArticle",t["Exercise"]="Exercise",t["Repository"]="Repository",t["RepositoryEntity"]="RepositoryEntity",t["CSPReport"]="CSPReport",t["Comment"]="Comment",t["PullRequest"]="PullRequest",t["Point"]="Point",t["PointDetail"]="PointDetail",t["FootPrintRecord"]="FootPrintRecord",t["SearchRecord"]="SearchRecord",t["Tag"]="Tag",t["EntityTag"]="EntityTag",t["Log"]="Log",t["Star"]="Star",t["StarDetail"]="StarDetail",t["Entity"]="Entity"}</span>(e.DatabaseEnum||(e.DatabaseEnum={}))}</span>,2487:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,"27f3":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0}),e.FileEnum=void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["Text"]="text",t["Image"]="image",t["Video"]="video",t["Audio"]="audio",t["JSON"]="json"}</span>(e.FileEnum||(e.FileEnum={}))}</span>,"28e3":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){},"34b4":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >n("99af"),n("b0c0");v</span>ar r=<span class="cstat-no" title="statement not covered" >n("7a23");<span class="cstat-no" title="statement not covered" ></span>Object(r["pushScopeId"])("data-v-22ec6050");v</span>ar o=<span class="cstat-no" title="statement not covered" >Object(r["createTextVNode"])(" 评论 ");</span>function <span class="fstat-no" title="function not covered" >i(</span>t,e,n,i,s,a){var c=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-avatar"),</span>l=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-text-area"),</span>p=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-form-item"),</span>u=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-button"),</span>h=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-comment"),</span>d=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-list-item"),</span>f=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-list");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createElementBlock"])(r["Fragment"],null,[Object(r["createVNode"])(h,null,{avatar:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Object(r["createVNode"])(c,{src:"http://file.songxiwen.com.cn/icon1.jpeg",alt:"Han Solo"})]}</span>)),content:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Object(r["createVNode"])(p,{class:"inner-form-item"},{default:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Object(r["createVNode"])(l,{rows:4,value:t.commentContent,"onUpdate:value":e[0]||(e[0]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.commentContent=e}</span>)},null,8,["value"])]}</span>)),_:1}),Object(r["createVNode"])(p,null,{default:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Object(r["createVNode"])(u,{"html-type":"submit",loading:t.submitting,type:"primary",onClick:t.handleSubmitComment},{default:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[o]}</span>)),_:1},8,["loading","onClick"])]}</span>)),_:1})]}</span>)),_:1}),t.commentList.length?(Object(r["openBlock"])(),Object(r["createBlock"])(f,{key:0,"data-source":t.commentList,header:"".concat(t.commentList.length," ").concat(t.commentList.length&gt;1?"comments":"comment"),"item-layout":"horizontal"},{renderItem:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.item;<span class="cstat-no" title="statement not covered" ></span>return[Object(r["createVNode"])(d,null,{default:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Object(r["createVNode"])(h,{avatar:e.user.avatar,content:e.content,author:e.user.name,datetime:e.createdAt},null,8,["avatar","content","author","datetime"])]}</span>)),_:2},1024)]}</span>)),_:1},8,["data-source","header"])):Object(r["createCommentVNode"])("",!0)],64)}<span class="cstat-no" title="statement not covered" ></span>Object(r["popScopeId"])();v</span>ar s=<span class="cstat-no" title="statement not covered" >n("1da1"),</span>a=(<span class="cstat-no" title="statement not covered" >n("96cf"),n("6162"))</span>,c=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({props:{entityId:{type:String,required:!0},entityType:{type:String,required:!0}},setup:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Object(r["toRef"])(t,"entityType"),</span>n=<span class="cstat-no" title="statement not covered" >Object(r["toRef"])(t,"entityId"),</span>o=<span class="cstat-no" title="statement not covered" >Object(r["ref"])([]),</span>i=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(!1),</span>c=<span class="cstat-no" title="statement not covered" >Object(r["ref"])("");<span class="cstat-no" title="statement not covered" ></span>Object(r["watch"])(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >console.log(t,"sssssss")}</span>));v</span>ar l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >Object(s["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >t(</span>){var r;<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(t.prev=t.next){case 0:<span class="cstat-no" title="statement not covered" >return t.next=2,a["b"].getCommentByEntityId({entityId:n.value,entityType:e.value,pageIndex:0,pageSize:10});c</span>ase 2:<span class="cstat-no" title="statement not covered" >r=t.sent,r.data&amp;&amp;(o.value=r.data.list);c</span>ase 4:case"end":<span class="cstat-no" title="statement not covered" >return t.stop()}</span>}</span></span>),t)}</span>)));<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.apply(this,arguments)}</span>}</span>(),</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >Object(s["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >t(</span>){<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(t.prev=t.next){case 0:<span class="cstat-no" title="statement not covered" >if(c.value){<span class="cstat-no" title="statement not covered" >t.next=2;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.abrupt("return");c</span>ase 2:<span class="cstat-no" title="statement not covered" >return i.value=!0,t.next=5,a["a"].create({entityId:n.value,entityType:e.value,content:c.value});c</span>ase 5:<span class="cstat-no" title="statement not covered" >return t.next=7,l();c</span>ase 7:<span class="cstat-no" title="statement not covered" >i.value=!1;c</span>ase 8:case"end":<span class="cstat-no" title="statement not covered" >return t.stop()}</span>}</span></span>),t)}</span>)));<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.apply(this,arguments)}</span>}</span>();<span class="cstat-no" title="statement not covered" ></span>return Object(r["onMounted"])(Object(s["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >t(</span>){<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(t.prev=t.next){case 0:<span class="cstat-no" title="statement not covered" >return t.next=2,l();c</span>ase 2:case"end":<span class="cstat-no" title="statement not covered" >return t.stop()}</span>}</span></span>),t)}</span>)))),{commentList:o,submitting:i,commentContent:c,handleSubmitComment:p}}</span>});<span class="cstat-no" title="statement not covered" ></span>n("bbbc");<span class="cstat-no" title="statement not covered" >c</span>.render=i,c.__scopeId="data-v-22ec6050";<span class="cstat-no" title="statement not covered" >e</span>["a"]=c}</span>,"35bc":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >n("5577")}</span>,"3a80":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,"4df4":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >n("0366"),</span>o=<span class="cstat-no" title="statement not covered" >n("7b0b"),</span>i=<span class="cstat-no" title="statement not covered" >n("9bdd"),</span>s=<span class="cstat-no" title="statement not covered" >n("e95a"),</span>a=<span class="cstat-no" title="statement not covered" >n("50c4"),</span>c=<span class="cstat-no" title="statement not covered" >n("8418"),</span>l=<span class="cstat-no" title="statement not covered" >n("9a1f"),</span>p=<span class="cstat-no" title="statement not covered" >n("35a1");<span class="cstat-no" title="statement not covered" ></span>t.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,n,u,h,d,f,m=<span class="cstat-no" title="statement not covered" >o(t),</span>v=<span class="cstat-no" title="statement not covered" >"function"==typeof this?this:Array,</span>g=<span class="cstat-no" title="statement not covered" >arguments.length,</span>y=<span class="cstat-no" title="statement not covered" >g&gt;1?arguments[1]:void 0,</span>b=<span class="cstat-no" title="statement not covered" >void 0!==y,</span>w=<span class="cstat-no" title="statement not covered" >p(m),</span>O=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(b&amp;&amp;(y=r(y,g&gt;2?arguments[2]:void 0,2)),void 0==w||v==Array&amp;&amp;s(w))<span class="cstat-no" title="statement not covered" >for(e=a(m.length),n=new v(e);e&gt;O;O++)<span class="cstat-no" title="statement not covered" >f=b?y(m[O],O):m[O],c(n,O,f);e</span></span>lse <span class="cstat-no" title="statement not covered" >for(h=l(m,w),d=h.next,n=new v;!(u=d.call(h)).done;O++)<span class="cstat-no" title="statement not covered" >f=b?i(h,y,[u.value,O],!0):u.value,c(n,O,f);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n.length=O,n}</span>}</span>,5577:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){},5899:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"}</span>,"58a8":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >n("1d80"),</span>o=<span class="cstat-no" title="statement not covered" >n("577e"),</span>i=<span class="cstat-no" title="statement not covered" >n("5899"),</span>s=<span class="cstat-no" title="statement not covered" >"["+i+"]",</span>a=<span class="cstat-no" title="statement not covered" >RegExp("^"+s+s+"*"),</span>c=<span class="cstat-no" title="statement not covered" >RegExp(s+s+"*$"),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >o(r(e));<span class="cstat-no" title="statement not covered" ></span>return 1&amp;t&amp;&amp;(n=n.replace(a,"")),2&amp;t&amp;&amp;(n=n.replace(c,"")),n}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>t.exports={start:l(1),end:l(2),trim:l(3)}}</span>,"5dd4":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){},"5ebe":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >n("28e3")}</span>,"6e03":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,"748a":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0}),e.PointDetailSymbolEnum=e.PointSourceEnum=void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["AddComment"]="AddComment",t["CreateKnowledge"]="CreateKnowledge",t["CreateExercise"]="CreateExercise",t["CreateEdge"]="CreateEdge"}</span>(e.PointSourceEnum||(e.PointSourceEnum={})),<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["In"]="in",t["Out"]="out"}</span>(e.PointDetailSymbolEnum||(e.PointDetailSymbolEnum={}))}</span>,"79b1":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,"7db0":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >n("23e7"),</span>o=<span class="cstat-no" title="statement not covered" >n("b727").find,</span>i=<span class="cstat-no" title="statement not covered" >n("44d2"),</span>s=<span class="cstat-no" title="statement not covered" >"find",</span>a=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>s in[]&amp;&amp;Array(1)[s]((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a=!1}</span>)),r({target:"Array",proto:!0,forced:a},{find:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return o(this,t,arguments.length&gt;1?arguments[1]:void 0)}</span>}),i(s)}</span>,"7ffa":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,"8f57":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >n("5dd4")}</span>,"99af":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >n("23e7"),</span>o=<span class="cstat-no" title="statement not covered" >n("d039"),</span>i=<span class="cstat-no" title="statement not covered" >n("e8b5"),</span>s=<span class="cstat-no" title="statement not covered" >n("861d"),</span>a=<span class="cstat-no" title="statement not covered" >n("7b0b"),</span>c=<span class="cstat-no" title="statement not covered" >n("50c4"),</span>l=<span class="cstat-no" title="statement not covered" >n("8418"),</span>p=<span class="cstat-no" title="statement not covered" >n("65f0"),</span>u=<span class="cstat-no" title="statement not covered" >n("1dde"),</span>h=<span class="cstat-no" title="statement not covered" >n("b622"),</span>d=<span class="cstat-no" title="statement not covered" >n("2d00"),</span>f=<span class="cstat-no" title="statement not covered" >h("isConcatSpreadable"),</span>m=<span class="cstat-no" title="statement not covered" >9007199254740991,</span>v=<span class="cstat-no" title="statement not covered" >"Maximum allowed index exceeded",</span>g=<span class="cstat-no" title="statement not covered" >d&gt;=51||!o((<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t[f]=!1,t.concat()[0]!==t}</span>)),</span>y=<span class="cstat-no" title="statement not covered" >u("concat"),</span>b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!s(t))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >t[f];<span class="cstat-no" title="statement not covered" ></span>return void 0!==e?!!e:i(t)}</span>,</span>w=<span class="cstat-no" title="statement not covered" >!g||!y;<span class="cstat-no" title="statement not covered" ></span>r({target:"Array",proto:!0,forced:w},{concat:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,n,r,o,i,s=<span class="cstat-no" title="statement not covered" >a(this),</span>u=<span class="cstat-no" title="statement not covered" >p(s,0),</span>h=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(e=-1,r=arguments.length;e&lt;r;e++)<span class="cstat-no" title="statement not covered" >if(i=-1===e?s:arguments[e],b(i)){<span class="cstat-no" title="statement not covered" >if(o=c(i.length),h+o&gt;m)<span class="cstat-no" title="statement not covered" >throw TypeError(v);<span class="cstat-no" title="statement not covered" >f</span></span>or(n=0;n&lt;o;n++,h++)<span class="cstat-no" title="statement not covered" >n in i&amp;&amp;l(u,h,i[n])}</span></span>else{<span class="cstat-no" title="statement not covered" >if(h&gt;=m)<span class="cstat-no" title="statement not covered" >throw TypeError(v);<span class="cstat-no" title="statement not covered" >l</span></span>(u,h++,i)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn u.length=h,u}</span>})}</span>,"9bc2":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >n("9c3f")}</span>,"9bdd":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >n("825a"),</span>o=<span class="cstat-no" title="statement not covered" >n("2a62");<span class="cstat-no" title="statement not covered" ></span>t.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,i){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return i?e(r(n)[0],n[1]):e(n)}</span>catch(s){<span class="cstat-no" title="statement not covered" >o(t,"throw",s)}</span>}</span>}</span>,"9c3f":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){},"9fb3":<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0}),e.PullRequestOperatorEnum=e.PullRequestStatusEnum=void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["Pending"]="pending",t["Merged"]="merged",t["Failed"]="failed",t["Closed"]="closed"}</span>(e.PullRequestStatusEnum||(e.PullRequestStatusEnum={})),<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["User"]="user",t["Admin"]="admin"}</span>(e.PullRequestOperatorEnum||(e.PullRequestOperatorEnum={}))}</span>,a4d6:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,a630e:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >n("23e7"),</span>o=<span class="cstat-no" title="statement not covered" >n("4df4"),</span>i=<span class="cstat-no" title="statement not covered" >n("1c7e"),</span>s=<span class="cstat-no" title="statement not covered" >!i((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >Array.from(t)}</span>));<span class="cstat-no" title="statement not covered" ></span>r({target:"Array",stat:!0,forced:s},{from:o})}</span>,a9e3:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >n("83ab"),</span>o=<span class="cstat-no" title="statement not covered" >n("da84"),</span>i=<span class="cstat-no" title="statement not covered" >n("94ca"),</span>s=<span class="cstat-no" title="statement not covered" >n("6eeb"),</span>a=<span class="cstat-no" title="statement not covered" >n("5135"),</span>c=<span class="cstat-no" title="statement not covered" >n("c6b6"),</span>l=<span class="cstat-no" title="statement not covered" >n("7156"),</span>p=<span class="cstat-no" title="statement not covered" >n("d9b5"),</span>u=<span class="cstat-no" title="statement not covered" >n("c04e"),</span>h=<span class="cstat-no" title="statement not covered" >n("d039"),</span>d=<span class="cstat-no" title="statement not covered" >n("7c73"),</span>f=<span class="cstat-no" title="statement not covered" >n("241c").f,</span>m=<span class="cstat-no" title="statement not covered" >n("06cf").f,</span>v=<span class="cstat-no" title="statement not covered" >n("9bf2").f,</span>g=<span class="cstat-no" title="statement not covered" >n("58a8").trim,</span>y=<span class="cstat-no" title="statement not covered" >"Number",</span>b=<span class="cstat-no" title="statement not covered" >o[y],</span>w=<span class="cstat-no" title="statement not covered" >b.prototype,</span>O=<span class="cstat-no" title="statement not covered" >c(d(w))==y,</span>k=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(p(t))<span class="cstat-no" title="statement not covered" >throw TypeError("Cannot convert a Symbol value to a number");v</span></span>ar e,n,r,o,i,s,a,c,l=<span class="cstat-no" title="statement not covered" >u(t,"number");<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof l&amp;&amp;l.length&gt;2)<span class="cstat-no" title="statement not covered" >if(l=g(l),e=l.charCodeAt(0),43===e||45===e){<span class="cstat-no" title="statement not covered" >if(n=l.charCodeAt(2),88===n||120===n)<span class="cstat-no" title="statement not covered" >return NaN}</span></span>else <span class="cstat-no" title="statement not covered" >if(48===e){<span class="cstat-no" title="statement not covered" >switch(l.charCodeAt(1)){case 66:case 98:<span class="cstat-no" title="statement not covered" >r=2,o=49;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 79:case 111:<span class="cstat-no" title="statement not covered" >r=8,o=55;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >return+l}<span class="cstat-no" title="statement not covered" ></span>f</span>or(i=l.slice(2),s=i.length,a=0;a&lt;s;a++)<span class="cstat-no" title="statement not covered" >if(c=i.charCodeAt(a),c&lt;48||c&gt;o)<span class="cstat-no" title="statement not covered" >return NaN;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn parseInt(i,r)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn+l}</span>;<span class="cstat-no" title="statement not covered" ></span>if(i(y,!b(" 0o1")||!b("0b1")||b("+0x1"))){<span class="cstat-no" title="statement not covered" >for(var x,S=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >arguments.length&lt;1?0:t,</span>n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return n instanceof S&amp;&amp;(O?h((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >w.valueOf.call(n)}</span>)):c(n)!=y)?l(new b(k(e)),n,S):k(e)}</span>,</span>M=<span class="cstat-no" title="statement not covered" >r?f(b):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","),</span>C=<span class="cstat-no" title="statement not covered" >0;</span>M.length&gt;C;C++)<span class="cstat-no" title="statement not covered" >a(b,x=M[C])&amp;&amp;!a(S,x)&amp;&amp;v(S,x,m(b,x));<span class="cstat-no" title="statement not covered" >S</span></span>.prototype=w,w.constructor=S,s(o,y,S)}</span>}</span>,b240:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){},b34c:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >n("7a23");<span class="cstat-no" title="statement not covered" ></span>Object(r["pushScopeId"])("data-v-5ddadcf2");v</span>ar o=<span class="cstat-no" title="statement not covered" >{class:"section-article"},</span>i=<span class="cstat-no" title="statement not covered" >Object(r["createTextVNode"])("text"),</span>s=<span class="cstat-no" title="statement not covered" >{class:"article-container"},</span>a=<span class="cstat-no" title="statement not covered" >{class:"limit-container"},</span>c=<span class="cstat-no" title="statement not covered" >{key:0,class:"editor-container"},</span>l=<span class="cstat-no" title="statement not covered" >{key:1,class:"editor-container-view"},</span>p=<span class="cstat-no" title="statement not covered" >{class:"comment-content"};</span>function <span class="fstat-no" title="function not covered" >u(</span>t,e,n,u,h,d){var f=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("section-article-control"),</span>m=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-button"),</span>v=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("article-limit"),</span>g=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("editor-content");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createElementBlock"])("div",o,[t.editable&amp;&amp;t.editor?(Object(r["openBlock"])(),Object(r["createBlock"])(f,{key:0,editor:t.editor,onSave:t.saveSectionArticle},null,8,["editor","onSave"])):Object(r["createCommentVNode"])("",!0),Object(r["createVNode"])(m,{onClick:t.upload},{default:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[i]}</span>)),_:1},8,["onClick"]),Object(r["createElementVNode"])("div",s,[Object(r["createElementVNode"])("div",a,[t.editor?(Object(r["openBlock"])(),Object(r["createBlock"])(v,{key:0,current:t.editor.getCharacterCount(),limit:t.limit},null,8,["current","limit"])):Object(r["createCommentVNode"])("",!0)]),t.editable?(Object(r["openBlock"])(),Object(r["createElementBlock"])("div",c,[Object(r["createVNode"])(g,{class:"tip-tap-editor",editor:t.editor},null,8,["editor"])])):(Object(r["openBlock"])(),Object(r["createElementBlock"])("div",l,[Object(r["createVNode"])(g,{class:"tip-tap-editor",editor:t.editor},null,8,["editor"])])),Object(r["createElementVNode"])("div",p,[Object(r["renderSlot"])(t.$slots,"comment",{entityId:t.entityId},void 0,!0)])])])}<span class="cstat-no" title="statement not covered" ></span>Object(r["popScopeId"])();v</span>ar h=<span class="cstat-no" title="statement not covered" >n("1da1");<span class="cstat-no" title="statement not covered" ></span>n("96cf"),n("b0c0");f</span>unction <span class="fstat-no" title="function not covered" >d(</span>t){<span class="cstat-no" title="statement not covered" >if(null==t)<span class="cstat-no" title="statement not covered" >return window;<span class="cstat-no" title="statement not covered" >i</span></span>f("[object Window]"!==t.toString()){var e=<span class="cstat-no" title="statement not covered" >t.ownerDocument;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;e.defaultView||window}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >f(</span>t){var e=<span class="cstat-no" title="statement not covered" >d(t).Element;<span class="cstat-no" title="statement not covered" ></span>return t instanceof e||t instanceof Element}</span>function <span class="fstat-no" title="function not covered" >m(</span>t){var e=<span class="cstat-no" title="statement not covered" >d(t).HTMLElement;<span class="cstat-no" title="statement not covered" ></span>return t instanceof e||t instanceof HTMLElement}</span>function <span class="fstat-no" title="function not covered" >v(</span>t){<span class="cstat-no" title="statement not covered" >if("undefined"===typeof ShadowRoot)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >d(t).ShadowRoot;<span class="cstat-no" title="statement not covered" ></span>return t instanceof e||t instanceof ShadowRoot}</span>var g=<span class="cstat-no" title="statement not covered" >Math.round;</span>function <span class="fstat-no" title="function not covered" >y(</span>t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=!1);v</span>ar n=<span class="cstat-no" title="statement not covered" >t.getBoundingClientRect(),</span>r=<span class="cstat-no" title="statement not covered" >1,</span>o=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>if(m(t)&amp;&amp;e){var i=<span class="cstat-no" title="statement not covered" >t.offsetHeight,</span>s=<span class="cstat-no" title="statement not covered" >t.offsetWidth;<span class="cstat-no" title="statement not covered" ></span>s&gt;0&amp;&amp;(r=n.width/s||1),i&gt;0&amp;&amp;(o=n.height/i||1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{width:g(n.width/r),height:g(n.height/o),top:g(n.top/o),right:g(n.right/r),bottom:g(n.bottom/o),left:g(n.left/r),x:g(n.left/r),y:g(n.top/o)}}</span>function <span class="fstat-no" title="function not covered" >b(</span>t){var e=<span class="cstat-no" title="statement not covered" >d(t),</span>n=<span class="cstat-no" title="statement not covered" >e.pageXOffset,</span>r=<span class="cstat-no" title="statement not covered" >e.pageYOffset;<span class="cstat-no" title="statement not covered" ></span>return{scrollLeft:n,scrollTop:r}}</span>function <span class="fstat-no" title="function not covered" >w(</span>t){<span class="cstat-no" title="statement not covered" >return{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}}</span>function <span class="fstat-no" title="function not covered" >O(</span>t){<span class="cstat-no" title="statement not covered" >return t!==d(t)&amp;&amp;m(t)?w(t):b(t)}</span>function <span class="fstat-no" title="function not covered" >k(</span>t){<span class="cstat-no" title="statement not covered" >return t?(t.nodeName||"").toLowerCase():null}</span>function <span class="fstat-no" title="function not covered" >x(</span>t){<span class="cstat-no" title="statement not covered" >return((f(t)?t.ownerDocument:t.document)||window.document).documentElement}</span>function <span class="fstat-no" title="function not covered" >S(</span>t){<span class="cstat-no" title="statement not covered" >return y(x(t)).left+b(t).scrollLeft}</span>function <span class="fstat-no" title="function not covered" >M(</span>t){<span class="cstat-no" title="statement not covered" >return d(t).getComputedStyle(t)}</span>function <span class="fstat-no" title="function not covered" >C(</span>t){var e=<span class="cstat-no" title="statement not covered" >M(t),</span>n=<span class="cstat-no" title="statement not covered" >e.overflow,</span>r=<span class="cstat-no" title="statement not covered" >e.overflowX,</span>o=<span class="cstat-no" title="statement not covered" >e.overflowY;<span class="cstat-no" title="statement not covered" ></span>return/auto|scroll|overlay|hidden/.test(n+o+r)}</span>function <span class="fstat-no" title="function not covered" >E(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.getBoundingClientRect(),</span>n=<span class="cstat-no" title="statement not covered" >e.width/t.offsetWidth||1,</span>r=<span class="cstat-no" title="statement not covered" >e.height/t.offsetHeight||1;<span class="cstat-no" title="statement not covered" ></span>return 1!==n||1!==r}</span>function <span class="fstat-no" title="function not covered" >T(</span>t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=!1);v</span>ar r=<span class="cstat-no" title="statement not covered" >m(e),</span>o=<span class="cstat-no" title="statement not covered" >m(e)&amp;&amp;E(e),</span>i=<span class="cstat-no" title="statement not covered" >x(e),</span>s=<span class="cstat-no" title="statement not covered" >y(t,o),</span>a=<span class="cstat-no" title="statement not covered" >{scrollLeft:0,scrollTop:0},</span>c=<span class="cstat-no" title="statement not covered" >{x:0,y:0};<span class="cstat-no" title="statement not covered" ></span>return(r||!r&amp;&amp;!n)&amp;&amp;(("body"!==k(e)||C(i))&amp;&amp;(a=O(e)),m(e)?(c=y(e,!0),c.x+=e.clientLeft,c.y+=e.clientTop):i&amp;&amp;(c.x=S(i))),{x:s.left+a.scrollLeft-c.x,y:s.top+a.scrollTop-c.y,width:s.width,height:s.height}}</span>function <span class="fstat-no" title="function not covered" >N(</span>t){var e=<span class="cstat-no" title="statement not covered" >y(t),</span>n=<span class="cstat-no" title="statement not covered" >t.offsetWidth,</span>r=<span class="cstat-no" title="statement not covered" >t.offsetHeight;<span class="cstat-no" title="statement not covered" ></span>return Math.abs(e.width-n)&lt;=1&amp;&amp;(n=e.width),Math.abs(e.height-r)&lt;=1&amp;&amp;(r=e.height),{x:t.offsetLeft,y:t.offsetTop,width:n,height:r}}</span>function <span class="fstat-no" title="function not covered" >j(</span>t){<span class="cstat-no" title="statement not covered" >return"html"===k(t)?t:t.assignedSlot||t.parentNode||(v(t)?t.host:null)||x(t)}</span>function <span class="fstat-no" title="function not covered" >A(</span>t){<span class="cstat-no" title="statement not covered" >return["html","body","#document"].indexOf(k(t))&gt;=0?t.ownerDocument.body:m(t)&amp;&amp;C(t)?t:A(j(t))}</span>function <span class="fstat-no" title="function not covered" >I(</span>t,e){var n;<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=[]);v</span>ar r=<span class="cstat-no" title="statement not covered" >A(t),</span>o=<span class="cstat-no" title="statement not covered" >r===(null==(n=t.ownerDocument)?void 0:n.body),</span>i=<span class="cstat-no" title="statement not covered" >d(r),</span>s=<span class="cstat-no" title="statement not covered" >o?[i].concat(i.visualViewport||[],C(r)?r:[]):r,</span>a=<span class="cstat-no" title="statement not covered" >e.concat(s);<span class="cstat-no" title="statement not covered" ></span>return o?a:a.concat(I(j(s)))}</span>function <span class="fstat-no" title="function not covered" >D(</span>t){<span class="cstat-no" title="statement not covered" >return["table","td","th"].indexOf(k(t))&gt;=0}</span>function <span class="fstat-no" title="function not covered" >R(</span>t){<span class="cstat-no" title="statement not covered" >return m(t)&amp;&amp;"fixed"!==M(t).position?t.offsetParent:null}</span>function <span class="fstat-no" title="function not covered" >_(</span>t){var e=<span class="cstat-no" title="statement not covered" >-1!==navigator.userAgent.toLowerCase().indexOf("firefox"),</span>n=<span class="cstat-no" title="statement not covered" >-1!==navigator.userAgent.indexOf("Trident");<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;m(t)){var r=<span class="cstat-no" title="statement not covered" >M(t);<span class="cstat-no" title="statement not covered" ></span>if("fixed"===r.position)<span class="cstat-no" title="statement not covered" >return null}</span></span>v</span>ar o=<span class="cstat-no" title="statement not covered" >j(t);<span class="cstat-no" title="statement not covered" ></span>while(m(o)&amp;&amp;["html","body"].indexOf(k(o))&lt;0){var i=<span class="cstat-no" title="statement not covered" >M(o);<span class="cstat-no" title="statement not covered" ></span>if("none"!==i.transform||"none"!==i.perspective||"paint"===i.contain||-1!==["transform","perspective"].indexOf(i.willChange)||e&amp;&amp;"filter"===i.willChange||e&amp;&amp;i.filter&amp;&amp;"none"!==i.filter)<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >o</span></span>=o.parentNode}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>function <span class="fstat-no" title="function not covered" >P(</span>t){var e=<span class="cstat-no" title="statement not covered" >d(t),</span>n=<span class="cstat-no" title="statement not covered" >R(t);<span class="cstat-no" title="statement not covered" ></span>while(n&amp;&amp;D(n)&amp;&amp;"static"===M(n).position)<span class="cstat-no" title="statement not covered" >n=R(n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n&amp;&amp;("html"===k(n)||"body"===k(n)&amp;&amp;"static"===M(n).position)?e:n||_(t)||e}</span>var z=<span class="cstat-no" title="statement not covered" >"top",</span>B=<span class="cstat-no" title="statement not covered" >"bottom",</span>L=<span class="cstat-no" title="statement not covered" >"right",</span>V=<span class="cstat-no" title="statement not covered" >"left",</span>$=<span class="cstat-no" title="statement not covered" >"auto",</span>F=<span class="cstat-no" title="statement not covered" >[z,B,L,V],</span>H=<span class="cstat-no" title="statement not covered" >"start",</span>q=<span class="cstat-no" title="statement not covered" >"end",</span>J=<span class="cstat-no" title="statement not covered" >"clippingParents",</span>W=<span class="cstat-no" title="statement not covered" >"viewport",</span>K=<span class="cstat-no" title="statement not covered" >"popper",</span>U=<span class="cstat-no" title="statement not covered" >"reference",</span>G=<span class="cstat-no" title="statement not covered" >F.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.concat([e+"-"+H,e+"-"+q])}</span>),[]),</span>Y=<span class="cstat-no" title="statement not covered" >[].concat(F,[$]).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.concat([e,e+"-"+H,e+"-"+q])}</span>),[]),</span>X=<span class="cstat-no" title="statement not covered" >"beforeRead",</span>Q=<span class="cstat-no" title="statement not covered" >"read",</span>Z=<span class="cstat-no" title="statement not covered" >"afterRead",</span>tt=<span class="cstat-no" title="statement not covered" >"beforeMain",</span>et=<span class="cstat-no" title="statement not covered" >"main",</span>nt=<span class="cstat-no" title="statement not covered" >"afterMain",</span>rt=<span class="cstat-no" title="statement not covered" >"beforeWrite",</span>ot=<span class="cstat-no" title="statement not covered" >"write",</span>it=<span class="cstat-no" title="statement not covered" >"afterWrite",</span>st=<span class="cstat-no" title="statement not covered" >[X,Q,Z,tt,et,nt,rt,ot,it];</span>function <span class="fstat-no" title="function not covered" >at(</span>t){var e=<span class="cstat-no" title="statement not covered" >new Map,</span>n=<span class="cstat-no" title="statement not covered" >new Set,</span>r=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >o(</span>t){<span class="cstat-no" title="statement not covered" >n.add(t.name);v</span>ar i=<span class="cstat-no" title="statement not covered" >[].concat(t.requires||[],t.requiresIfExists||[]);<span class="cstat-no" title="statement not covered" ></span>i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!n.has(t)){var r=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;o(r)}</span>}</span>)),r.push(t)}<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.set(t.name,t)}</span>)),t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.has(t.name)||o(t)}</span>)),r}</span>function <span class="fstat-no" title="function not covered" >ct(</span>t){var e=<span class="cstat-no" title="statement not covered" >at(t);<span class="cstat-no" title="statement not covered" ></span>return st.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t.concat(e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.phase===n}</span>)))}</span>),[])}</span>function <span class="fstat-no" title="function not covered" >lt(</span>t){var e;<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e||(e=new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >Promise.resolve().then((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e=void 0,n(t())}</span>))}</span>))),e}</span>}</span>function <span class="fstat-no" title="function not covered" >pt(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >t[e.name];<span class="cstat-no" title="statement not covered" ></span>return t[e.name]=n?Object.assign({},n,e,{options:Object.assign({},n.options,e.options),data:Object.assign({},n.data,e.data)}):e,t}</span>),{});<span class="cstat-no" title="statement not covered" ></span>return Object.keys(e).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e[t]}</span>))}</span>var ut=<span class="cstat-no" title="statement not covered" >{placement:"bottom",modifiers:[],strategy:"absolute"};</span>function <span class="fstat-no" title="function not covered" >ht(</span>){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>e=<span class="cstat-no" title="statement not covered" >new Array(t),</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t;n++)<span class="cstat-no" title="statement not covered" >e[n]=arguments[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn!e.some((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!(t&amp;&amp;"function"===typeof t.getBoundingClientRect)}</span>))}</span>function <span class="fstat-no" title="function not covered" >dt(</span>t){<span class="cstat-no" title="statement not covered" >void 0===t&amp;&amp;(t={});v</span>ar e=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >e.defaultModifiers,</span>r=<span class="cstat-no" title="statement not covered" >void 0===n?[]:n,</span>o=<span class="cstat-no" title="statement not covered" >e.defaultOptions,</span>i=<span class="cstat-no" title="statement not covered" >void 0===o?ut:o;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=i);v</span>ar o=<span class="cstat-no" title="statement not covered" >{placement:"bottom",orderedModifiers:[],options:Object.assign({},ut,i),modifiersData:{},elements:{reference:t,popper:e},attributes:{},styles:{}},</span>s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >!1,</span>c=<span class="cstat-no" title="statement not covered" >{state:o,setOptions:<span class="fstat-no" title="function not covered" >fu</span>nction(n){var s=<span class="cstat-no" title="statement not covered" >"function"===typeof n?n(o.options):n;<span class="cstat-no" title="statement not covered" ></span>p(),o.options=Object.assign({},i,o.options,s),o.scrollParents={reference:f(t)?I(t):t.contextElement?I(t.contextElement):[],popper:I(e)};v</span>ar a=<span class="cstat-no" title="statement not covered" >ct(pt([].concat(r,o.options.modifiers)));<span class="cstat-no" title="statement not covered" ></span>return o.orderedModifiers=a.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.enabled}</span>)),l(),c.update()}</span>,forceUpdate:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!a){var t=<span class="cstat-no" title="statement not covered" >o.elements,</span>e=<span class="cstat-no" title="statement not covered" >t.reference,</span>n=<span class="cstat-no" title="statement not covered" >t.popper;<span class="cstat-no" title="statement not covered" ></span>if(ht(e,n)){<span class="cstat-no" title="statement not covered" >o.rects={reference:T(e,P(n),"fixed"===o.options.strategy),popper:N(n)},o.reset=!1,o.placement=o.options.placement,o.orderedModifiers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return o.modifiersData[t.name]=Object.assign({},t.data)}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;o.orderedModifiers.length;r++)<span class="cstat-no" title="statement not covered" >if(!0!==o.reset){var i=<span class="cstat-no" title="statement not covered" >o.orderedModifiers[r],</span>s=<span class="cstat-no" title="statement not covered" >i.fn,</span>l=<span class="cstat-no" title="statement not covered" >i.options,</span>p=<span class="cstat-no" title="statement not covered" >void 0===l?{}:l,</span>u=<span class="cstat-no" title="statement not covered" >i.name;<span class="cstat-no" title="statement not covered" ></span>"function"===typeof s&amp;&amp;(o=s({state:o,options:p,name:u,instance:c})||o)}</span>else <span class="cstat-no" title="statement not covered" >o.reset=!1,r=-1}</span></span></span>}</span>}</span>,update:lt((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >c.forceUpdate(),t(o)}</span>))}</span>)),destroy:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >p(),a=!0}</span>};<span class="cstat-no" title="statement not covered" ></span>if(!ht(t,e))<span class="cstat-no" title="statement not covered" >return c;f</span></span>unction <span class="fstat-no" title="function not covered" >l(</span>){<span class="cstat-no" title="statement not covered" >o.orderedModifiers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.name,</span>n=<span class="cstat-no" title="statement not covered" >t.options,</span>r=<span class="cstat-no" title="statement not covered" >void 0===n?{}:n,</span>i=<span class="cstat-no" title="statement not covered" >t.effect;<span class="cstat-no" title="statement not covered" ></span>if("function"===typeof i){var a=<span class="cstat-no" title="statement not covered" >i({state:o,name:e,instance:c,options:r}),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" ></span>s.push(a||l)}</span>}</span>))}</span>function <span class="fstat-no" title="function not covered" >p(</span>){<span class="cstat-no" title="statement not covered" >s.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t()}</span>)),s=[]}<span class="cstat-no" title="statement not covered" ></span>return c.setOptions(n).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >!a&amp;&amp;n.onFirstUpdate&amp;&amp;n.onFirstUpdate(t)}</span>)),c}</span>}</span>var ft=<span class="cstat-no" title="statement not covered" >{passive:!0};</span>function <span class="fstat-no" title="function not covered" >mt(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >t.instance,</span>r=<span class="cstat-no" title="statement not covered" >t.options,</span>o=<span class="cstat-no" title="statement not covered" >r.scroll,</span>i=<span class="cstat-no" title="statement not covered" >void 0===o||o,</span>s=<span class="cstat-no" title="statement not covered" >r.resize,</span>a=<span class="cstat-no" title="statement not covered" >void 0===s||s,</span>c=<span class="cstat-no" title="statement not covered" >d(e.elements.popper),</span>l=<span class="cstat-no" title="statement not covered" >[].concat(e.scrollParents.reference,e.scrollParents.popper);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;l.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.addEventListener("scroll",n.update,ft)}</span>)),a&amp;&amp;c.addEventListener("resize",n.update,ft),<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i&amp;&amp;l.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.removeEventListener("scroll",n.update,ft)}</span>)),a&amp;&amp;c.removeEventListener("resize",n.update,ft)}</span>}</span>var vt=<span class="cstat-no" title="statement not covered" >{name:"eventListeners",enabled:!0,phase:"write",fn:<span class="fstat-no" title="function not covered" >fu</span>nction(){},effect:mt,data:{}};</span>function <span class="fstat-no" title="function not covered" >gt(</span>t){<span class="cstat-no" title="statement not covered" >return t.split("-")[0]}</span>function <span class="fstat-no" title="function not covered" >yt(</span>t){<span class="cstat-no" title="statement not covered" >return t.split("-")[1]}</span>function <span class="fstat-no" title="function not covered" >bt(</span>t){<span class="cstat-no" title="statement not covered" >return["top","bottom"].indexOf(t)&gt;=0?"x":"y"}</span>function <span class="fstat-no" title="function not covered" >wt(</span>t){var e,n=<span class="cstat-no" title="statement not covered" >t.reference,</span>r=<span class="cstat-no" title="statement not covered" >t.element,</span>o=<span class="cstat-no" title="statement not covered" >t.placement,</span>i=<span class="cstat-no" title="statement not covered" >o?gt(o):null,</span>s=<span class="cstat-no" title="statement not covered" >o?yt(o):null,</span>a=<span class="cstat-no" title="statement not covered" >n.x+n.width/2-r.width/2,</span>c=<span class="cstat-no" title="statement not covered" >n.y+n.height/2-r.height/2;<span class="cstat-no" title="statement not covered" ></span>switch(i){case z:<span class="cstat-no" title="statement not covered" >e={x:a,y:n.y-r.height};<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase B:<span class="cstat-no" title="statement not covered" >e={x:a,y:n.y+n.height};<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase L:<span class="cstat-no" title="statement not covered" >e={x:n.x+n.width,y:c};<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase V:<span class="cstat-no" title="statement not covered" >e={x:n.x-r.width,y:c};<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >e={x:n.x,y:n.y}}</span>v</span>ar l=<span class="cstat-no" title="statement not covered" >i?bt(i):null;<span class="cstat-no" title="statement not covered" ></span>if(null!=l){var p=<span class="cstat-no" title="statement not covered" >"y"===l?"height":"width";<span class="cstat-no" title="statement not covered" ></span>switch(s){case H:<span class="cstat-no" title="statement not covered" >e[l]=e[l]-(n[p]/2-r[p]/2);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase q:<span class="cstat-no" title="statement not covered" >e[l]=e[l]+(n[p]/2-r[p]/2);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Ot(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >t.name;<span class="cstat-no" title="statement not covered" ></span>e.modifiersData[n]=wt({reference:e.rects.reference,element:e.rects.popper,strategy:"absolute",placement:e.placement})}</span>var kt=<span class="cstat-no" title="statement not covered" >{name:"popperOffsets",enabled:!0,phase:"read",fn:Ot,data:{}},</span>xt=<span class="cstat-no" title="statement not covered" >Math.max,</span>St=<span class="cstat-no" title="statement not covered" >Math.min,</span>Mt=<span class="cstat-no" title="statement not covered" >Math.round,</span>Ct=<span class="cstat-no" title="statement not covered" >{top:"auto",right:"auto",bottom:"auto",left:"auto"};</span>function <span class="fstat-no" title="function not covered" >Et(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.x,</span>n=<span class="cstat-no" title="statement not covered" >t.y,</span>r=<span class="cstat-no" title="statement not covered" >window,</span>o=<span class="cstat-no" title="statement not covered" >r.devicePixelRatio||1;<span class="cstat-no" title="statement not covered" ></span>return{x:Mt(Mt(e*o)/o)||0,y:Mt(Mt(n*o)/o)||0}}</span>function <span class="fstat-no" title="function not covered" >Tt(</span>t){var e,n=<span class="cstat-no" title="statement not covered" >t.popper,</span>r=<span class="cstat-no" title="statement not covered" >t.popperRect,</span>o=<span class="cstat-no" title="statement not covered" >t.placement,</span>i=<span class="cstat-no" title="statement not covered" >t.variation,</span>s=<span class="cstat-no" title="statement not covered" >t.offsets,</span>a=<span class="cstat-no" title="statement not covered" >t.position,</span>c=<span class="cstat-no" title="statement not covered" >t.gpuAcceleration,</span>l=<span class="cstat-no" title="statement not covered" >t.adaptive,</span>p=<span class="cstat-no" title="statement not covered" >t.roundOffsets,</span>u=<span class="cstat-no" title="statement not covered" >!0===p?Et(s):"function"===typeof p?p(s):s,</span>h=<span class="cstat-no" title="statement not covered" >u.x,</span>f=<span class="cstat-no" title="statement not covered" >void 0===h?0:h,</span>m=<span class="cstat-no" title="statement not covered" >u.y,</span>v=<span class="cstat-no" title="statement not covered" >void 0===m?0:m,</span>g=<span class="cstat-no" title="statement not covered" >s.hasOwnProperty("x"),</span>y=<span class="cstat-no" title="statement not covered" >s.hasOwnProperty("y"),</span>b=<span class="cstat-no" title="statement not covered" >V,</span>w=<span class="cstat-no" title="statement not covered" >z,</span>O=<span class="cstat-no" title="statement not covered" >window;<span class="cstat-no" title="statement not covered" ></span>if(l){var k=<span class="cstat-no" title="statement not covered" >P(n),</span>S=<span class="cstat-no" title="statement not covered" >"clientHeight",</span>C=<span class="cstat-no" title="statement not covered" >"clientWidth";<span class="cstat-no" title="statement not covered" ></span>k===d(n)&amp;&amp;(k=x(n),"static"!==M(k).position&amp;&amp;"absolute"===a&amp;&amp;(S="scrollHeight",C="scrollWidth")),k=k,o!==z&amp;&amp;(o!==V&amp;&amp;o!==L||i!==q)||(w=B,v-=k[S]-r.height,v*=c?1:-1),o!==V&amp;&amp;(o!==z&amp;&amp;o!==B||i!==q)||(b=L,f-=k[C]-r.width,f*=c?1:-1)}</span>v</span>ar E,T=<span class="cstat-no" title="statement not covered" >Object.assign({position:a},l&amp;&amp;Ct);<span class="cstat-no" title="statement not covered" ></span>return c?Object.assign({},T,(E={},E[w]=y?"0":"",E[b]=g?"0":"",E.transform=(O.devicePixelRatio||1)&lt;=1?"translate("+f+"px, "+v+"px)":"translate3d("+f+"px, "+v+"px, 0)",E)):Object.assign({},T,(e={},e[w]=y?v+"px":"",e[b]=g?f+"px":"",e.transform="",e))}</span>function <span class="fstat-no" title="function not covered" >Nt(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >t.options,</span>r=<span class="cstat-no" title="statement not covered" >n.gpuAcceleration,</span>o=<span class="cstat-no" title="statement not covered" >void 0===r||r,</span>i=<span class="cstat-no" title="statement not covered" >n.adaptive,</span>s=<span class="cstat-no" title="statement not covered" >void 0===i||i,</span>a=<span class="cstat-no" title="statement not covered" >n.roundOffsets,</span>c=<span class="cstat-no" title="statement not covered" >void 0===a||a,</span>l=<span class="cstat-no" title="statement not covered" >{placement:gt(e.placement),variation:yt(e.placement),popper:e.elements.popper,popperRect:e.rects.popper,gpuAcceleration:o};<span class="cstat-no" title="statement not covered" ></span>null!=e.modifiersData.popperOffsets&amp;&amp;(e.styles.popper=Object.assign({},e.styles.popper,Tt(Object.assign({},l,{offsets:e.modifiersData.popperOffsets,position:e.options.strategy,adaptive:s,roundOffsets:c})))),null!=e.modifiersData.arrow&amp;&amp;(e.styles.arrow=Object.assign({},e.styles.arrow,Tt(Object.assign({},l,{offsets:e.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:c})))),e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-placement":e.placement})}</span>var jt=<span class="cstat-no" title="statement not covered" >{name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:Nt,data:{}};</span>function <span class="fstat-no" title="function not covered" >At(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state;<span class="cstat-no" title="statement not covered" ></span>Object.keys(e.elements).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >e.styles[t]||{},</span>r=<span class="cstat-no" title="statement not covered" >e.attributes[t]||{},</span>o=<span class="cstat-no" title="statement not covered" >e.elements[t];<span class="cstat-no" title="statement not covered" ></span>m(o)&amp;&amp;k(o)&amp;&amp;(Object.assign(o.style,n),Object.keys(r).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >r[t];<span class="cstat-no" title="statement not covered" ></span>!1===e?o.removeAttribute(t):o.setAttribute(t,!0===e?"":e)}</span>)))}</span>))}</span>function <span class="fstat-no" title="function not covered" >It(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >{popper:{position:e.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};<span class="cstat-no" title="statement not covered" ></span>return Object.assign(e.elements.popper.style,n.popper),e.styles=n,e.elements.arrow&amp;&amp;Object.assign(e.elements.arrow.style,n.arrow),<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Object.keys(e.elements).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >e.elements[t],</span>o=<span class="cstat-no" title="statement not covered" >e.attributes[t]||{},</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(e.styles.hasOwnProperty(t)?e.styles[t]:n[t]),</span>s=<span class="cstat-no" title="statement not covered" >i.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t[e]="",t}</span>),{});<span class="cstat-no" title="statement not covered" ></span>m(r)&amp;&amp;k(r)&amp;&amp;(Object.assign(r.style,s),Object.keys(o).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >r.removeAttribute(t)}</span>)))}</span>))}</span>}</span>var Dt=<span class="cstat-no" title="statement not covered" >{name:"applyStyles",enabled:!0,phase:"write",fn:At,effect:It,requires:["computeStyles"]};</span>function <span class="fstat-no" title="function not covered" >Rt(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >gt(t),</span>o=<span class="cstat-no" title="statement not covered" >[V,z].indexOf(r)&gt;=0?-1:1,</span>i=<span class="cstat-no" title="statement not covered" >"function"===typeof n?n(Object.assign({},e,{placement:t})):n,</span>s=<span class="cstat-no" title="statement not covered" >i[0],</span>a=<span class="cstat-no" title="statement not covered" >i[1];<span class="cstat-no" title="statement not covered" ></span>return s=s||0,a=(a||0)*o,[V,L].indexOf(r)&gt;=0?{x:a,y:s}:{x:s,y:a}}</span>function <span class="fstat-no" title="function not covered" >_t(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >t.options,</span>r=<span class="cstat-no" title="statement not covered" >t.name,</span>o=<span class="cstat-no" title="statement not covered" >n.offset,</span>i=<span class="cstat-no" title="statement not covered" >void 0===o?[0,0]:o,</span>s=<span class="cstat-no" title="statement not covered" >Y.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t[n]=Rt(n,e.rects,i),t}</span>),{}),</span>a=<span class="cstat-no" title="statement not covered" >s[e.placement],</span>c=<span class="cstat-no" title="statement not covered" >a.x,</span>l=<span class="cstat-no" title="statement not covered" >a.y;<span class="cstat-no" title="statement not covered" ></span>null!=e.modifiersData.popperOffsets&amp;&amp;(e.modifiersData.popperOffsets.x+=c,e.modifiersData.popperOffsets.y+=l),e.modifiersData[r]=s}</span>var Pt=<span class="cstat-no" title="statement not covered" >{name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:_t},</span>zt=<span class="cstat-no" title="statement not covered" >{left:"right",right:"left",bottom:"top",top:"bottom"};</span>function <span class="fstat-no" title="function not covered" >Bt(</span>t){<span class="cstat-no" title="statement not covered" >return t.replace(/left|right|bottom|top/g,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return zt[t]}</span>))}</span>var Lt=<span class="cstat-no" title="statement not covered" >{start:"end",end:"start"};</span>function <span class="fstat-no" title="function not covered" >Vt(</span>t){<span class="cstat-no" title="statement not covered" >return t.replace(/start|end/g,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Lt[t]}</span>))}</span>function <span class="fstat-no" title="function not covered" >$t(</span>t){var e=<span class="cstat-no" title="statement not covered" >d(t),</span>n=<span class="cstat-no" title="statement not covered" >x(t),</span>r=<span class="cstat-no" title="statement not covered" >e.visualViewport,</span>o=<span class="cstat-no" title="statement not covered" >n.clientWidth,</span>i=<span class="cstat-no" title="statement not covered" >n.clientHeight,</span>s=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(o=r.width,i=r.height,/^((?!chrome|android).)*safari/i.test(navigator.userAgent)||(s=r.offsetLeft,a=r.offsetTop)),{width:o,height:i,x:s+S(t),y:a}}</span>function <span class="fstat-no" title="function not covered" >Ft(</span>t){var e,n=<span class="cstat-no" title="statement not covered" >x(t),</span>r=<span class="cstat-no" title="statement not covered" >b(t),</span>o=<span class="cstat-no" title="statement not covered" >null==(e=t.ownerDocument)?void 0:e.body,</span>i=<span class="cstat-no" title="statement not covered" >xt(n.scrollWidth,n.clientWidth,o?o.scrollWidth:0,o?o.clientWidth:0),</span>s=<span class="cstat-no" title="statement not covered" >xt(n.scrollHeight,n.clientHeight,o?o.scrollHeight:0,o?o.clientHeight:0),</span>a=<span class="cstat-no" title="statement not covered" >-r.scrollLeft+S(t),</span>c=<span class="cstat-no" title="statement not covered" >-r.scrollTop;<span class="cstat-no" title="statement not covered" ></span>return"rtl"===M(o||n).direction&amp;&amp;(a+=xt(n.clientWidth,o?o.clientWidth:0)-i),{width:i,height:s,x:a,y:c}}</span>function <span class="fstat-no" title="function not covered" >Ht(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >e.getRootNode&amp;&amp;e.getRootNode();<span class="cstat-no" title="statement not covered" ></span>if(t.contains(e))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(n&amp;&amp;v(n)){var r=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >if(r&amp;&amp;t.isSameNode(r))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span>=r.parentNode||r.host}</span>while(r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >qt(</span>t){<span class="cstat-no" title="statement not covered" >return Object.assign({},t,{left:t.x,top:t.y,right:t.x+t.width,bottom:t.y+t.height})}</span>function <span class="fstat-no" title="function not covered" >Jt(</span>t){var e=<span class="cstat-no" title="statement not covered" >y(t);<span class="cstat-no" title="statement not covered" ></span>return e.top=e.top+t.clientTop,e.left=e.left+t.clientLeft,e.bottom=e.top+t.clientHeight,e.right=e.left+t.clientWidth,e.width=t.clientWidth,e.height=t.clientHeight,e.x=e.left,e.y=e.top,e}</span>function <span class="fstat-no" title="function not covered" >Wt(</span>t,e){<span class="cstat-no" title="statement not covered" >return e===W?qt($t(t)):m(e)?Jt(e):qt(Ft(x(t)))}</span>function <span class="fstat-no" title="function not covered" >Kt(</span>t){var e=<span class="cstat-no" title="statement not covered" >I(j(t)),</span>n=<span class="cstat-no" title="statement not covered" >["absolute","fixed"].indexOf(M(t).position)&gt;=0,</span>r=<span class="cstat-no" title="statement not covered" >n&amp;&amp;m(t)?P(t):t;<span class="cstat-no" title="statement not covered" ></span>return f(r)?e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return f(t)&amp;&amp;Ht(t,r)&amp;&amp;"body"!==k(t)}</span>)):[]}</span>function <span class="fstat-no" title="function not covered" >Ut(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >"clippingParents"===e?Kt(t):[].concat(e),</span>o=<span class="cstat-no" title="statement not covered" >[].concat(r,[n]),</span>i=<span class="cstat-no" title="statement not covered" >o[0],</span>s=<span class="cstat-no" title="statement not covered" >o.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r=<span class="cstat-no" title="statement not covered" >Wt(t,n);<span class="cstat-no" title="statement not covered" ></span>return e.top=xt(r.top,e.top),e.right=St(r.right,e.right),e.bottom=St(r.bottom,e.bottom),e.left=xt(r.left,e.left),e}</span>),Wt(t,i));<span class="cstat-no" title="statement not covered" ></span>return s.width=s.right-s.left,s.height=s.bottom-s.top,s.x=s.left,s.y=s.top,s}</span>function <span class="fstat-no" title="function not covered" >Gt(</span>){<span class="cstat-no" title="statement not covered" >return{top:0,right:0,bottom:0,left:0}}</span>function <span class="fstat-no" title="function not covered" >Yt(</span>t){<span class="cstat-no" title="statement not covered" >return Object.assign({},Gt(),t)}</span>function <span class="fstat-no" title="function not covered" >Xt(</span>t,e){<span class="cstat-no" title="statement not covered" >return e.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return e[n]=t,e}</span>),{})}</span>function <span class="fstat-no" title="function not covered" >Qt(</span>t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e={});v</span>ar n=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >n.placement,</span>o=<span class="cstat-no" title="statement not covered" >void 0===r?t.placement:r,</span>i=<span class="cstat-no" title="statement not covered" >n.boundary,</span>s=<span class="cstat-no" title="statement not covered" >void 0===i?J:i,</span>a=<span class="cstat-no" title="statement not covered" >n.rootBoundary,</span>c=<span class="cstat-no" title="statement not covered" >void 0===a?W:a,</span>l=<span class="cstat-no" title="statement not covered" >n.elementContext,</span>p=<span class="cstat-no" title="statement not covered" >void 0===l?K:l,</span>u=<span class="cstat-no" title="statement not covered" >n.altBoundary,</span>h=<span class="cstat-no" title="statement not covered" >void 0!==u&amp;&amp;u,</span>d=<span class="cstat-no" title="statement not covered" >n.padding,</span>m=<span class="cstat-no" title="statement not covered" >void 0===d?0:d,</span>v=<span class="cstat-no" title="statement not covered" >Yt("number"!==typeof m?m:Xt(m,F)),</span>g=<span class="cstat-no" title="statement not covered" >p===K?U:K,</span>b=<span class="cstat-no" title="statement not covered" >t.rects.popper,</span>w=<span class="cstat-no" title="statement not covered" >t.elements[h?g:p],</span>O=<span class="cstat-no" title="statement not covered" >Ut(f(w)?w:w.contextElement||x(t.elements.popper),s,c),</span>k=<span class="cstat-no" title="statement not covered" >y(t.elements.reference),</span>S=<span class="cstat-no" title="statement not covered" >wt({reference:k,element:b,strategy:"absolute",placement:o}),</span>M=<span class="cstat-no" title="statement not covered" >qt(Object.assign({},b,S)),</span>C=<span class="cstat-no" title="statement not covered" >p===K?M:k,</span>E=<span class="cstat-no" title="statement not covered" >{top:O.top-C.top+v.top,bottom:C.bottom-O.bottom+v.bottom,left:O.left-C.left+v.left,right:C.right-O.right+v.right},</span>T=<span class="cstat-no" title="statement not covered" >t.modifiersData.offset;<span class="cstat-no" title="statement not covered" ></span>if(p===K&amp;&amp;T){var N=<span class="cstat-no" title="statement not covered" >T[o];<span class="cstat-no" title="statement not covered" ></span>Object.keys(E).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >[L,B].indexOf(t)&gt;=0?1:-1,</span>n=<span class="cstat-no" title="statement not covered" >[z,B].indexOf(t)&gt;=0?"y":"x";<span class="cstat-no" title="statement not covered" ></span>E[t]+=N[n]*e}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn E}</span>function <span class="fstat-no" title="function not covered" >Zt(</span>t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e={});v</span>ar n=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >n.placement,</span>o=<span class="cstat-no" title="statement not covered" >n.boundary,</span>i=<span class="cstat-no" title="statement not covered" >n.rootBoundary,</span>s=<span class="cstat-no" title="statement not covered" >n.padding,</span>a=<span class="cstat-no" title="statement not covered" >n.flipVariations,</span>c=<span class="cstat-no" title="statement not covered" >n.allowedAutoPlacements,</span>l=<span class="cstat-no" title="statement not covered" >void 0===c?Y:c,</span>p=<span class="cstat-no" title="statement not covered" >yt(r),</span>u=<span class="cstat-no" title="statement not covered" >p?a?G:G.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return yt(t)===p}</span>)):F,</span>h=<span class="cstat-no" title="statement not covered" >u.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return l.indexOf(t)&gt;=0}</span>));<span class="cstat-no" title="statement not covered" ></span>0===h.length&amp;&amp;(h=u);v</span>ar d=<span class="cstat-no" title="statement not covered" >h.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return e[n]=Qt(t,{placement:n,boundary:o,rootBoundary:i,padding:s})[gt(n)],e}</span>),{});<span class="cstat-no" title="statement not covered" ></span>return Object.keys(d).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return d[t]-d[e]}</span>))}</span>function <span class="fstat-no" title="function not covered" >te(</span>t){<span class="cstat-no" title="statement not covered" >if(gt(t)===$)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar e=<span class="cstat-no" title="statement not covered" >Bt(t);<span class="cstat-no" title="statement not covered" ></span>return[Vt(t),e,Vt(e)]}</span>function <span class="fstat-no" title="function not covered" >ee(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >t.options,</span>r=<span class="cstat-no" title="statement not covered" >t.name;<span class="cstat-no" title="statement not covered" ></span>if(!e.modifiersData[r]._skip){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >n.mainAxis,</span>i=<span class="cstat-no" title="statement not covered" >void 0===o||o,</span>s=<span class="cstat-no" title="statement not covered" >n.altAxis,</span>a=<span class="cstat-no" title="statement not covered" >void 0===s||s,</span>c=<span class="cstat-no" title="statement not covered" >n.fallbackPlacements,</span>l=<span class="cstat-no" title="statement not covered" >n.padding,</span>p=<span class="cstat-no" title="statement not covered" >n.boundary,</span>u=<span class="cstat-no" title="statement not covered" >n.rootBoundary,</span>h=<span class="cstat-no" title="statement not covered" >n.altBoundary,</span>d=<span class="cstat-no" title="statement not covered" >n.flipVariations,</span>f=<span class="cstat-no" title="statement not covered" >void 0===d||d,</span>m=<span class="cstat-no" title="statement not covered" >n.allowedAutoPlacements,</span>v=<span class="cstat-no" title="statement not covered" >e.options.placement,</span>g=<span class="cstat-no" title="statement not covered" >gt(v),</span>y=<span class="cstat-no" title="statement not covered" >g===v,</span>b=<span class="cstat-no" title="statement not covered" >c||(y||!f?[Bt(v)]:te(v)),</span>w=<span class="cstat-no" title="statement not covered" >[v].concat(b).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t.concat(gt(n)===$?Zt(e,{placement:n,boundary:p,rootBoundary:u,padding:l,flipVariations:f,allowedAutoPlacements:m}):n)}</span>),[]),</span>O=<span class="cstat-no" title="statement not covered" >e.rects.reference,</span>k=<span class="cstat-no" title="statement not covered" >e.rects.popper,</span>x=<span class="cstat-no" title="statement not covered" >new Map,</span>S=<span class="cstat-no" title="statement not covered" >!0,</span>M=<span class="cstat-no" title="statement not covered" >w[0],</span>C=<span class="cstat-no" title="statement not covered" >0;</span>C&lt;w.length;C++){var E=<span class="cstat-no" title="statement not covered" >w[C],</span>T=<span class="cstat-no" title="statement not covered" >gt(E),</span>N=<span class="cstat-no" title="statement not covered" >yt(E)===H,</span>j=<span class="cstat-no" title="statement not covered" >[z,B].indexOf(T)&gt;=0,</span>A=<span class="cstat-no" title="statement not covered" >j?"width":"height",</span>I=<span class="cstat-no" title="statement not covered" >Qt(e,{placement:E,boundary:p,rootBoundary:u,altBoundary:h,padding:l}),</span>D=<span class="cstat-no" title="statement not covered" >j?N?L:V:N?B:z;<span class="cstat-no" title="statement not covered" ></span>O[A]&gt;k[A]&amp;&amp;(D=Bt(D));v</span>ar R=<span class="cstat-no" title="statement not covered" >Bt(D),</span>_=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;_.push(I[T]&lt;=0),a&amp;&amp;_.push(I[D]&lt;=0,I[R]&lt;=0),_.every((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>))){<span class="cstat-no" title="statement not covered" >M=E,S=!1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>x</span>.set(E,_)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(S)<span class="cstat-no" title="statement not covered" >for(var P=<span class="cstat-no" title="statement not covered" >f?3:1,</span>F=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >w.find((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >x.get(e);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return n.slice(0,t).every((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t}</span>))}</span></span>));<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return M=e,"break"}</span></span>,</span>q=<span class="cstat-no" title="statement not covered" >P;</span>q&gt;0;q--){var J=<span class="cstat-no" title="statement not covered" >F(q);<span class="cstat-no" title="statement not covered" ></span>if("break"===J)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>e</span></span>.placement!==M&amp;&amp;(e.modifiersData[r]._skip=!0,e.placement=M,e.reset=!0)}</span>}</span>var ne=<span class="cstat-no" title="statement not covered" >{name:"flip",enabled:!0,phase:"main",fn:ee,requiresIfExists:["offset"],data:{_skip:!1}};</span>function <span class="fstat-no" title="function not covered" >re(</span>t){<span class="cstat-no" title="statement not covered" >return"x"===t?"y":"x"}</span>function <span class="fstat-no" title="function not covered" >oe(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return xt(t,St(e,n))}</span>function <span class="fstat-no" title="function not covered" >ie(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >t.options,</span>r=<span class="cstat-no" title="statement not covered" >t.name,</span>o=<span class="cstat-no" title="statement not covered" >n.mainAxis,</span>i=<span class="cstat-no" title="statement not covered" >void 0===o||o,</span>s=<span class="cstat-no" title="statement not covered" >n.altAxis,</span>a=<span class="cstat-no" title="statement not covered" >void 0!==s&amp;&amp;s,</span>c=<span class="cstat-no" title="statement not covered" >n.boundary,</span>l=<span class="cstat-no" title="statement not covered" >n.rootBoundary,</span>p=<span class="cstat-no" title="statement not covered" >n.altBoundary,</span>u=<span class="cstat-no" title="statement not covered" >n.padding,</span>h=<span class="cstat-no" title="statement not covered" >n.tether,</span>d=<span class="cstat-no" title="statement not covered" >void 0===h||h,</span>f=<span class="cstat-no" title="statement not covered" >n.tetherOffset,</span>m=<span class="cstat-no" title="statement not covered" >void 0===f?0:f,</span>v=<span class="cstat-no" title="statement not covered" >Qt(e,{boundary:c,rootBoundary:l,padding:u,altBoundary:p}),</span>g=<span class="cstat-no" title="statement not covered" >gt(e.placement),</span>y=<span class="cstat-no" title="statement not covered" >yt(e.placement),</span>b=<span class="cstat-no" title="statement not covered" >!y,</span>w=<span class="cstat-no" title="statement not covered" >bt(g),</span>O=<span class="cstat-no" title="statement not covered" >re(w),</span>k=<span class="cstat-no" title="statement not covered" >e.modifiersData.popperOffsets,</span>x=<span class="cstat-no" title="statement not covered" >e.rects.reference,</span>S=<span class="cstat-no" title="statement not covered" >e.rects.popper,</span>M=<span class="cstat-no" title="statement not covered" >"function"===typeof m?m(Object.assign({},e.rects,{placement:e.placement})):m,</span>C=<span class="cstat-no" title="statement not covered" >{x:0,y:0};<span class="cstat-no" title="statement not covered" ></span>if(k){<span class="cstat-no" title="statement not covered" >if(i||a){var E=<span class="cstat-no" title="statement not covered" >"y"===w?z:V,</span>T=<span class="cstat-no" title="statement not covered" >"y"===w?B:L,</span>j=<span class="cstat-no" title="statement not covered" >"y"===w?"height":"width",</span>A=<span class="cstat-no" title="statement not covered" >k[w],</span>I=<span class="cstat-no" title="statement not covered" >k[w]+v[E],</span>D=<span class="cstat-no" title="statement not covered" >k[w]-v[T],</span>R=<span class="cstat-no" title="statement not covered" >d?-S[j]/2:0,</span>_=<span class="cstat-no" title="statement not covered" >y===H?x[j]:S[j],</span>$=<span class="cstat-no" title="statement not covered" >y===H?-S[j]:-x[j],</span>F=<span class="cstat-no" title="statement not covered" >e.elements.arrow,</span>q=<span class="cstat-no" title="statement not covered" >d&amp;&amp;F?N(F):{width:0,height:0},</span>J=<span class="cstat-no" title="statement not covered" >e.modifiersData["arrow#persistent"]?e.modifiersData["arrow#persistent"].padding:Gt(),</span>W=<span class="cstat-no" title="statement not covered" >J[E],</span>K=<span class="cstat-no" title="statement not covered" >J[T],</span>U=<span class="cstat-no" title="statement not covered" >oe(0,x[j],q[j]),</span>G=<span class="cstat-no" title="statement not covered" >b?x[j]/2-R-U-W-M:_-U-W-M,</span>Y=<span class="cstat-no" title="statement not covered" >b?-x[j]/2+R+U+K+M:$+U+K+M,</span>X=<span class="cstat-no" title="statement not covered" >e.elements.arrow&amp;&amp;P(e.elements.arrow),</span>Q=<span class="cstat-no" title="statement not covered" >X?"y"===w?X.clientTop||0:X.clientLeft||0:0,</span>Z=<span class="cstat-no" title="statement not covered" >e.modifiersData.offset?e.modifiersData.offset[e.placement][w]:0,</span>tt=<span class="cstat-no" title="statement not covered" >k[w]+G-Z-Q,</span>et=<span class="cstat-no" title="statement not covered" >k[w]+Y-Z;<span class="cstat-no" title="statement not covered" ></span>if(i){var nt=<span class="cstat-no" title="statement not covered" >oe(d?St(I,tt):I,A,d?xt(D,et):D);<span class="cstat-no" title="statement not covered" ></span>k[w]=nt,C[w]=nt-A}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a){var rt=<span class="cstat-no" title="statement not covered" >"x"===w?z:V,</span>ot=<span class="cstat-no" title="statement not covered" >"x"===w?B:L,</span>it=<span class="cstat-no" title="statement not covered" >k[O],</span>st=<span class="cstat-no" title="statement not covered" >it+v[rt],</span>at=<span class="cstat-no" title="statement not covered" >it-v[ot],</span>ct=<span class="cstat-no" title="statement not covered" >oe(d?St(st,tt):st,it,d?xt(at,et):at);<span class="cstat-no" title="statement not covered" ></span>k[O]=ct,C[O]=ct-it}</span>}<span class="cstat-no" title="statement not covered" ></span>e</span>.modifiersData[r]=C}</span>}</span>var se=<span class="cstat-no" title="statement not covered" >{name:"preventOverflow",enabled:!0,phase:"main",fn:ie,requiresIfExists:["offset"]},</span>ae=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t="function"===typeof t?t(Object.assign({},e.rects,{placement:e.placement})):t,Yt("number"!==typeof t?t:Xt(t,F))}</span>;</span>function <span class="fstat-no" title="function not covered" >ce(</span>t){var e,n=<span class="cstat-no" title="statement not covered" >t.state,</span>r=<span class="cstat-no" title="statement not covered" >t.name,</span>o=<span class="cstat-no" title="statement not covered" >t.options,</span>i=<span class="cstat-no" title="statement not covered" >n.elements.arrow,</span>s=<span class="cstat-no" title="statement not covered" >n.modifiersData.popperOffsets,</span>a=<span class="cstat-no" title="statement not covered" >gt(n.placement),</span>c=<span class="cstat-no" title="statement not covered" >bt(a),</span>l=<span class="cstat-no" title="statement not covered" >[V,L].indexOf(a)&gt;=0,</span>p=<span class="cstat-no" title="statement not covered" >l?"height":"width";<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;s){var u=<span class="cstat-no" title="statement not covered" >ae(o.padding,n),</span>h=<span class="cstat-no" title="statement not covered" >N(i),</span>d=<span class="cstat-no" title="statement not covered" >"y"===c?z:V,</span>f=<span class="cstat-no" title="statement not covered" >"y"===c?B:L,</span>m=<span class="cstat-no" title="statement not covered" >n.rects.reference[p]+n.rects.reference[c]-s[c]-n.rects.popper[p],</span>v=<span class="cstat-no" title="statement not covered" >s[c]-n.rects.reference[c],</span>g=<span class="cstat-no" title="statement not covered" >P(i),</span>y=<span class="cstat-no" title="statement not covered" >g?"y"===c?g.clientHeight||0:g.clientWidth||0:0,</span>b=<span class="cstat-no" title="statement not covered" >m/2-v/2,</span>w=<span class="cstat-no" title="statement not covered" >u[d],</span>O=<span class="cstat-no" title="statement not covered" >y-h[p]-u[f],</span>k=<span class="cstat-no" title="statement not covered" >y/2-h[p]/2+b,</span>x=<span class="cstat-no" title="statement not covered" >oe(w,k,O),</span>S=<span class="cstat-no" title="statement not covered" >c;<span class="cstat-no" title="statement not covered" ></span>n.modifiersData[r]=(e={},e[S]=x,e.centerOffset=x-k,e)}</span>}</span>function <span class="fstat-no" title="function not covered" >le(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >t.options,</span>r=<span class="cstat-no" title="statement not covered" >n.element,</span>o=<span class="cstat-no" title="statement not covered" >void 0===r?"[data-popper-arrow]":r;<span class="cstat-no" title="statement not covered" ></span>null!=o&amp;&amp;("string"!==typeof o||(o=e.elements.popper.querySelector(o),o))&amp;&amp;Ht(e.elements.popper,o)&amp;&amp;(e.elements.arrow=o)}</span>var pe=<span class="cstat-no" title="statement not covered" >{name:"arrow",enabled:!0,phase:"main",fn:ce,effect:le,requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};</span>function <span class="fstat-no" title="function not covered" >ue(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return void 0===n&amp;&amp;(n={x:0,y:0}),{top:t.top-e.height-n.y,right:t.right-e.width+n.x,bottom:t.bottom-e.height+n.y,left:t.left-e.width-n.x}}</span>function <span class="fstat-no" title="function not covered" >he(</span>t){<span class="cstat-no" title="statement not covered" >return[z,L,B,V].some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e]&gt;=0}</span>))}</span>function <span class="fstat-no" title="function not covered" >de(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >t.name,</span>r=<span class="cstat-no" title="statement not covered" >e.rects.reference,</span>o=<span class="cstat-no" title="statement not covered" >e.rects.popper,</span>i=<span class="cstat-no" title="statement not covered" >e.modifiersData.preventOverflow,</span>s=<span class="cstat-no" title="statement not covered" >Qt(e,{elementContext:"reference"}),</span>a=<span class="cstat-no" title="statement not covered" >Qt(e,{altBoundary:!0}),</span>c=<span class="cstat-no" title="statement not covered" >ue(s,r),</span>l=<span class="cstat-no" title="statement not covered" >ue(a,o,i),</span>p=<span class="cstat-no" title="statement not covered" >he(c),</span>u=<span class="cstat-no" title="statement not covered" >he(l);<span class="cstat-no" title="statement not covered" ></span>e.modifiersData[n]={referenceClippingOffsets:c,popperEscapeOffsets:l,isReferenceHidden:p,hasPopperEscaped:u},e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-reference-hidden":p,"data-popper-escaped":u})}</span>var fe=<span class="cstat-no" title="statement not covered" >{name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:de},</span>me=<span class="cstat-no" title="statement not covered" >[vt,kt,jt,Dt,Pt,ne,se,pe,fe],</span>ve=<span class="cstat-no" title="statement not covered" >dt({defaultModifiers:me}),</span>ge=<span class="cstat-no" title="statement not covered" >"tippy-box",</span>ye=<span class="cstat-no" title="statement not covered" >"tippy-content",</span>be=<span class="cstat-no" title="statement not covered" >"tippy-backdrop",</span>we=<span class="cstat-no" title="statement not covered" >"tippy-arrow",</span>Oe=<span class="cstat-no" title="statement not covered" >"tippy-svg-arrow",</span>ke=<span class="cstat-no" title="statement not covered" >{passive:!0,capture:!0};</span>function <span class="fstat-no" title="function not covered" >xe(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(Array.isArray(t)){var r=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>return null==r?Array.isArray(n)?n[e]:n:r}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Se(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >{}.toString.call(t);<span class="cstat-no" title="statement not covered" ></span>return 0===n.indexOf("[object")&amp;&amp;n.indexOf(e+"]")&gt;-1}</span>function <span class="fstat-no" title="function not covered" >Me(</span>t,e){<span class="cstat-no" title="statement not covered" >return"function"===typeof t?t.apply(void 0,e):t}</span>function <span class="fstat-no" title="function not covered" >Ce(</span>t,e){<span class="cstat-no" title="statement not covered" >return 0===e?t:<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >clearTimeout(n),n=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t(r)}</span>),e)}</span>;v</span>ar n}function <span class="fstat-no" title="function not covered" >Ee(</span>t){<span class="cstat-no" title="statement not covered" >return t.split(/\s+/).filter(Boolean)}</span>function <span class="fstat-no" title="function not covered" >Te(</span>t){<span class="cstat-no" title="statement not covered" >return[].concat(t)}</span>function <span class="fstat-no" title="function not covered" >Ne(</span>t,e){<span class="cstat-no" title="statement not covered" >-1===t.indexOf(e)&amp;&amp;t.push(e)}</span>function <span class="fstat-no" title="function not covered" >je(</span>t){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return t.indexOf(e)===n}</span>))}</span>function <span class="fstat-no" title="function not covered" >Ae(</span>t){<span class="cstat-no" title="statement not covered" >return t.split("-")[0]}</span>function <span class="fstat-no" title="function not covered" >Ie(</span>t){<span class="cstat-no" title="statement not covered" >return[].slice.call(t)}</span>function <span class="fstat-no" title="function not covered" >De(</span>t){<span class="cstat-no" title="statement not covered" >return Object.keys(t).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return void 0!==t[n]&amp;&amp;(e[n]=t[n]),e}</span>),{})}</span>function <span class="fstat-no" title="function not covered" >Re(</span>){<span class="cstat-no" title="statement not covered" >return document.createElement("div")}</span>function <span class="fstat-no" title="function not covered" >_e(</span>t){<span class="cstat-no" title="statement not covered" >return["Element","Fragment"].some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Se(t,e)}</span>))}</span>function <span class="fstat-no" title="function not covered" >Pe(</span>t){<span class="cstat-no" title="statement not covered" >return Se(t,"NodeList")}</span>function <span class="fstat-no" title="function not covered" >ze(</span>t){<span class="cstat-no" title="statement not covered" >return Se(t,"MouseEvent")}</span>function <span class="fstat-no" title="function not covered" >Be(</span>t){<span class="cstat-no" title="statement not covered" >return!(!t||!t._tippy||t._tippy.reference!==t)}</span>function <span class="fstat-no" title="function not covered" >Le(</span>t){<span class="cstat-no" title="statement not covered" >return _e(t)?[t]:Pe(t)?Ie(t):Array.isArray(t)?t:Ie(document.querySelectorAll(t))}</span>function <span class="fstat-no" title="function not covered" >Ve(</span>t,e){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t&amp;&amp;(t.style.transitionDuration=e+"ms")}</span>))}</span>function <span class="fstat-no" title="function not covered" >$e(</span>t,e){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.setAttribute("data-state",e)}</span>))}</span>function <span class="fstat-no" title="function not covered" >Fe(</span>t){var e,n=<span class="cstat-no" title="statement not covered" >Te(t),</span>r=<span class="cstat-no" title="statement not covered" >n[0];<span class="cstat-no" title="statement not covered" ></span>return(null==r||null==(e=r.ownerDocument)?void 0:e.body)?r.ownerDocument:document}</span>function <span class="fstat-no" title="function not covered" >He(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >e.clientX,</span>r=<span class="cstat-no" title="statement not covered" >e.clientY;<span class="cstat-no" title="statement not covered" ></span>return t.every((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.popperRect,</span>o=<span class="cstat-no" title="statement not covered" >t.popperState,</span>i=<span class="cstat-no" title="statement not covered" >t.props,</span>s=<span class="cstat-no" title="statement not covered" >i.interactiveBorder,</span>a=<span class="cstat-no" title="statement not covered" >Ae(o.placement),</span>c=<span class="cstat-no" title="statement not covered" >o.modifiersData.offset;<span class="cstat-no" title="statement not covered" ></span>if(!c)<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >"bottom"===a?c.top.y:0,</span>p=<span class="cstat-no" title="statement not covered" >"top"===a?c.bottom.y:0,</span>u=<span class="cstat-no" title="statement not covered" >"right"===a?c.left.x:0,</span>h=<span class="cstat-no" title="statement not covered" >"left"===a?c.right.x:0,</span>d=<span class="cstat-no" title="statement not covered" >e.top-r+l&gt;s,</span>f=<span class="cstat-no" title="statement not covered" >r-e.bottom-p&gt;s,</span>m=<span class="cstat-no" title="statement not covered" >e.left-n+u&gt;s,</span>v=<span class="cstat-no" title="statement not covered" >n-e.right-h&gt;s;<span class="cstat-no" title="statement not covered" ></span>return d||f||m||v}</span>))}</span>function <span class="fstat-no" title="function not covered" >qe(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >e+"EventListener";<span class="cstat-no" title="statement not covered" ></span>["transitionend","webkitTransitionEnd"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t[r](e,n)}</span>))}</span>var Je=<span class="cstat-no" title="statement not covered" >{isTouch:!1},</span>We=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >Ke(</span>){<span class="cstat-no" title="statement not covered" >Je.isTouch||(Je.isTouch=!0,window.performance&amp;&amp;document.addEventListener("mousemove",Ue))}</span>function <span class="fstat-no" title="function not covered" >Ue(</span>){var t=<span class="cstat-no" title="statement not covered" >performance.now();<span class="cstat-no" title="statement not covered" ></span>t-We&lt;20&amp;&amp;(Je.isTouch=!1,document.removeEventListener("mousemove",Ue)),We=t}</span>function <span class="fstat-no" title="function not covered" >Ge(</span>){var t=<span class="cstat-no" title="statement not covered" >document.activeElement;<span class="cstat-no" title="statement not covered" ></span>if(Be(t)){var e=<span class="cstat-no" title="statement not covered" >t._tippy;<span class="cstat-no" title="statement not covered" ></span>t.blur&amp;&amp;!e.state.isVisible&amp;&amp;t.blur()}</span>}</span>function <span class="fstat-no" title="function not covered" >Ye(</span>){<span class="cstat-no" title="statement not covered" >document.addEventListener("touchstart",Ke,ke),window.addEventListener("blur",Ge)}</span>var Xe=<span class="cstat-no" title="statement not covered" >"undefined"!==typeof window&amp;&amp;"undefined"!==typeof document,</span>Qe=<span class="cstat-no" title="statement not covered" >Xe?navigator.userAgent:"",</span>Ze=<span class="cstat-no" title="statement not covered" >/MSIE |Trident\//.test(Qe);</span>var tn=<span class="cstat-no" title="statement not covered" >{animateFill:!1,followCursor:!1,inlinePositioning:!1,sticky:!1},</span>en=<span class="cstat-no" title="statement not covered" >{allowHTML:!1,animation:"fade",arrow:!0,content:"",inertia:!1,maxWidth:350,role:"tooltip",theme:"",zIndex:9999},</span>nn=<span class="cstat-no" title="statement not covered" >Object.assign({appendTo:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return document.body}</span>,aria:{content:"auto",expanded:"auto"},delay:0,duration:[300,250],getReferenceClientRect:null,hideOnClick:!0,ignoreAttributes:!1,interactive:!1,interactiveBorder:2,interactiveDebounce:0,moveTransition:"",offset:[0,10],onAfterUpdate:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onBeforeUpdate:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onCreate:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onDestroy:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onHidden:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onHide:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onMount:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onShow:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onShown:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onTrigger:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onUntrigger:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onClickOutside:<span class="fstat-no" title="function not covered" >fu</span>nction(){},placement:"top",plugins:[],popperOptions:{},render:null,showOnCreate:!1,touch:!0,trigger:"mouseenter focus",triggerTarget:null},tn,{},en),</span>rn=<span class="cstat-no" title="statement not covered" >Object.keys(nn),</span>on=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Object.keys(t);<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >nn[e]=t[e]}</span>))}</span>;</span>function <span class="fstat-no" title="function not covered" >sn(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.plugins||[],</span>n=<span class="cstat-no" title="statement not covered" >e.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r=<span class="cstat-no" title="statement not covered" >n.name,</span>o=<span class="cstat-no" title="statement not covered" >n.defaultValue;<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(e[r]=void 0!==t[r]?t[r]:o),e}</span>),{});<span class="cstat-no" title="statement not covered" ></span>return Object.assign({},t,{},n)}</span>function <span class="fstat-no" title="function not covered" >an(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >e?Object.keys(sn(Object.assign({},nn,{plugins:e}))):rn,</span>r=<span class="cstat-no" title="statement not covered" >n.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r=<span class="cstat-no" title="statement not covered" >(t.getAttribute("data-tippy-"+n)||"").trim();<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f("content"===n)<span class="cstat-no" title="statement not covered" >e[n]=r;e</span>lse <span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >e[n]=JSON.parse(r)}</span>catch(o){<span class="cstat-no" title="statement not covered" >e[n]=r}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>),{});<span class="cstat-no" title="statement not covered" ></span>return r}</span>function <span class="fstat-no" title="function not covered" >cn(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >Object.assign({},e,{content:Me(e.content,[t])},e.ignoreAttributes?{}:an(t,e.plugins));<span class="cstat-no" title="statement not covered" ></span>return n.aria=Object.assign({},nn.aria,{},n.aria),n.aria={expanded:"auto"===n.aria.expanded?e.interactive:n.aria.expanded,content:"auto"===n.aria.content?e.interactive?null:"describedby":n.aria.content},n}</span>var ln=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"innerHTML"}</span>;</span>function <span class="fstat-no" title="function not covered" >pn(</span>t,e){<span class="cstat-no" title="statement not covered" >t[ln()]=e}</span>function <span class="fstat-no" title="function not covered" >un(</span>t){var e=<span class="cstat-no" title="statement not covered" >Re();<span class="cstat-no" title="statement not covered" ></span>return!0===t?e.className=we:(e.className=Oe,_e(t)?e.appendChild(t):pn(e,t)),e}</span>function <span class="fstat-no" title="function not covered" >hn(</span>t,e){<span class="cstat-no" title="statement not covered" >_e(e.content)?(pn(t,""),t.appendChild(e.content)):"function"!==typeof e.content&amp;&amp;(e.allowHTML?pn(t,e.content):t.textContent=e.content)}</span>function <span class="fstat-no" title="function not covered" >dn(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.firstElementChild,</span>n=<span class="cstat-no" title="statement not covered" >Ie(e.children);<span class="cstat-no" title="statement not covered" ></span>return{box:e,content:n.find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.classList.contains(ye)}</span>)),arrow:n.find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.classList.contains(we)||t.classList.contains(Oe)}</span>)),backdrop:n.find((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.classList.contains(be)}</span>))}}</span>function <span class="fstat-no" title="function not covered" >fn(</span>t){var e=<span class="cstat-no" title="statement not covered" >Re(),</span>n=<span class="cstat-no" title="statement not covered" >Re();<span class="cstat-no" title="statement not covered" ></span>n.className=ge,n.setAttribute("data-state","hidden"),n.setAttribute("tabindex","-1");v</span>ar r=<span class="cstat-no" title="statement not covered" >Re();</span>function <span class="fstat-no" title="function not covered" >o(</span>n,r){var o=<span class="cstat-no" title="statement not covered" >dn(e),</span>i=<span class="cstat-no" title="statement not covered" >o.box,</span>s=<span class="cstat-no" title="statement not covered" >o.content,</span>a=<span class="cstat-no" title="statement not covered" >o.arrow;<span class="cstat-no" title="statement not covered" ></span>r.theme?i.setAttribute("data-theme",r.theme):i.removeAttribute("data-theme"),"string"===typeof r.animation?i.setAttribute("data-animation",r.animation):i.removeAttribute("data-animation"),r.inertia?i.setAttribute("data-inertia",""):i.removeAttribute("data-inertia"),i.style.maxWidth="number"===typeof r.maxWidth?r.maxWidth+"px":r.maxWidth,r.role?i.setAttribute("role",r.role):i.removeAttribute("role"),n.content===r.content&amp;&amp;n.allowHTML===r.allowHTML||hn(s,t.props),r.arrow?a?n.arrow!==r.arrow&amp;&amp;(i.removeChild(a),i.appendChild(un(r.arrow))):i.appendChild(un(r.arrow)):a&amp;&amp;i.removeChild(a)}<span class="cstat-no" title="statement not covered" ></span>return r.className=ye,r.setAttribute("data-state","hidden"),hn(r,t.props),e.appendChild(n),n.appendChild(r),o(t.props,t.props),{popper:e,onUpdate:o}}<span class="cstat-no" title="statement not covered" ></span>fn.$$tippy=!0;v</span>ar mn=<span class="cstat-no" title="statement not covered" >1,</span>vn=<span class="cstat-no" title="statement not covered" >[],</span>gn=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >yn(</span>t,e){var n,r,o,i,s,a,c,l=<span class="cstat-no" title="statement not covered" >cn(t,Object.assign({},nn,{},sn(De(e)))),</span>p=<span class="cstat-no" title="statement not covered" >!1,</span>u=<span class="cstat-no" title="statement not covered" >!1,</span>h=<span class="cstat-no" title="statement not covered" >!1,</span>d=<span class="cstat-no" title="statement not covered" >!1,</span>f=<span class="cstat-no" title="statement not covered" >[],</span>m=<span class="cstat-no" title="statement not covered" >Ce(Y,l.interactiveDebounce),</span>v=<span class="cstat-no" title="statement not covered" >mn++,</span>g=<span class="cstat-no" title="statement not covered" >null,</span>y=<span class="cstat-no" title="statement not covered" >je(l.plugins),</span>b=<span class="cstat-no" title="statement not covered" >{isEnabled:!0,isVisible:!1,isDestroyed:!1,isMounted:!1,isShown:!1},</span>w=<span class="cstat-no" title="statement not covered" >{id:v,reference:t,popper:Re(),popperInstance:g,props:l,state:b,plugins:y,clearDelayTimeouts:ct,setProps:lt,setContent:pt,show:ut,hide:ht,hideWithInteractivity:dt,enable:st,disable:at,unmount:ft,destroy:mt};<span class="cstat-no" title="statement not covered" ></span>if(!l.render)<span class="cstat-no" title="statement not covered" >return w;v</span></span>ar O=<span class="cstat-no" title="statement not covered" >l.render(w),</span>k=<span class="cstat-no" title="statement not covered" >O.popper,</span>x=<span class="cstat-no" title="statement not covered" >O.onUpdate;<span class="cstat-no" title="statement not covered" ></span>k.setAttribute("data-tippy-root",""),k.id="tippy-"+w.id,w.popper=k,t._tippy=w,k._tippy=w;v</span>ar S=<span class="cstat-no" title="statement not covered" >y.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.fn(w)}</span>)),</span>M=<span class="cstat-no" title="statement not covered" >t.hasAttribute("aria-expanded");<span class="cstat-no" title="statement not covered" ></span>return K(),P(),D(),R("onCreate",[w]),l.showOnCreate&amp;&amp;ot(),k.addEventListener("mouseenter",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >w.props.interactive&amp;&amp;w.state.isVisible&amp;&amp;w.clearDelayTimeouts()}</span>)),k.addEventListener("mouseleave",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >w.props.interactive&amp;&amp;w.props.trigger.indexOf("mouseenter")&gt;=0&amp;&amp;(j().addEventListener("mousemove",m),m(t))}</span>)),w;f</span>unction <span class="fstat-no" title="function not covered" >C(</span>){var t=<span class="cstat-no" title="statement not covered" >w.props.touch;<span class="cstat-no" title="statement not covered" ></span>return Array.isArray(t)?t:[t,0]}</span>function <span class="fstat-no" title="function not covered" >E(</span>){<span class="cstat-no" title="statement not covered" >return"hold"===C()[0]}</span>function <span class="fstat-no" title="function not covered" >T(</span>){var t;<span class="cstat-no" title="statement not covered" >return!!(null==(t=w.props.render)?void 0:t.$$tippy)}</span>function <span class="fstat-no" title="function not covered" >N(</span>){<span class="cstat-no" title="statement not covered" >return c||t}</span>function <span class="fstat-no" title="function not covered" >j(</span>){var t=<span class="cstat-no" title="statement not covered" >N().parentNode;<span class="cstat-no" title="statement not covered" ></span>return t?Fe(t):document}</span>function <span class="fstat-no" title="function not covered" >A(</span>){<span class="cstat-no" title="statement not covered" >return dn(k)}</span>function <span class="fstat-no" title="function not covered" >I(</span>t){<span class="cstat-no" title="statement not covered" >return w.state.isMounted&amp;&amp;!w.state.isVisible||Je.isTouch||i&amp;&amp;"focus"===i.type?0:xe(w.props.delay,t?0:1,nn.delay)}</span>function <span class="fstat-no" title="function not covered" >D(</span>){<span class="cstat-no" title="statement not covered" >k.style.pointerEvents=w.props.interactive&amp;&amp;w.state.isVisible?"":"none",k.style.zIndex=""+w.props.zIndex}</span>function <span class="fstat-no" title="function not covered" >R(</span>t,e,n){var r;<span class="cstat-no" title="statement not covered" >(void 0===n&amp;&amp;(n=!0),S.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >n[t]&amp;&amp;n[t].apply(void 0,e)}</span>)),n)&amp;&amp;(r=w.props)[t].apply(r,e)}</span>function <span class="fstat-no" title="function not covered" >_(</span>){var e=<span class="cstat-no" title="statement not covered" >w.props.aria;<span class="cstat-no" title="statement not covered" ></span>if(e.content){var n=<span class="cstat-no" title="statement not covered" >"aria-"+e.content,</span>r=<span class="cstat-no" title="statement not covered" >k.id,</span>o=<span class="cstat-no" title="statement not covered" >Te(w.props.triggerTarget||t);<span class="cstat-no" title="statement not covered" ></span>o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.getAttribute(n);<span class="cstat-no" title="statement not covered" ></span>if(w.state.isVisible)<span class="cstat-no" title="statement not covered" >t.setAttribute(n,e?e+" "+r:r);e</span>lse{var o=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.replace(r,"").trim();<span class="cstat-no" title="statement not covered" ></span>o?t.setAttribute(n,o):t.removeAttribute(n)}</span>}</span>))}</span>}</span>function <span class="fstat-no" title="function not covered" >P(</span>){<span class="cstat-no" title="statement not covered" >if(!M&amp;&amp;w.props.aria.expanded){var e=<span class="cstat-no" title="statement not covered" >Te(w.props.triggerTarget||t);<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >w.props.interactive?t.setAttribute("aria-expanded",w.state.isVisible&amp;&amp;t===N()?"true":"false"):t.removeAttribute("aria-expanded")}</span>))}</span>}</span>function <span class="fstat-no" title="function not covered" >z(</span>){<span class="cstat-no" title="statement not covered" >j().removeEventListener("mousemove",m),vn=vn.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t!==m}</span>))}</span>function <span class="fstat-no" title="function not covered" >B(</span>t){<span class="cstat-no" title="statement not covered" >if((!Je.isTouch||!h&amp;&amp;"mousedown"!==t.type)&amp;&amp;(!w.props.interactive||!k.contains(t.target))){<span class="cstat-no" title="statement not covered" >if(N().contains(t.target)){<span class="cstat-no" title="statement not covered" >if(Je.isTouch)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(w.state.isVisible&amp;&amp;w.props.trigger.indexOf("click")&gt;=0)<span class="cstat-no" title="statement not covered" >return}</span></span>else <span class="cstat-no" title="statement not covered" >R("onClickOutside",[w,t]);<span class="cstat-no" title="statement not covered" >!</span></span>0===w.props.hideOnClick&amp;&amp;(w.clearDelayTimeouts(),w.hide(),u=!0,setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >u=!1}</span>)),w.state.isMounted||F())}</span>}</span>function <span class="fstat-no" title="function not covered" >L(</span>){<span class="cstat-no" title="statement not covered" >h=!0}</span>function <span class="fstat-no" title="function not covered" >V(</span>){<span class="cstat-no" title="statement not covered" >h=!1}</span>function <span class="fstat-no" title="function not covered" >$(</span>){var t=<span class="cstat-no" title="statement not covered" >j();<span class="cstat-no" title="statement not covered" ></span>t.addEventListener("mousedown",B,!0),t.addEventListener("touchend",B,ke),t.addEventListener("touchstart",V,ke),t.addEventListener("touchmove",L,ke)}</span>function <span class="fstat-no" title="function not covered" >F(</span>){var t=<span class="cstat-no" title="statement not covered" >j();<span class="cstat-no" title="statement not covered" ></span>t.removeEventListener("mousedown",B,!0),t.removeEventListener("touchend",B,ke),t.removeEventListener("touchstart",V,ke),t.removeEventListener("touchmove",L,ke)}</span>function <span class="fstat-no" title="function not covered" >H(</span>t,e){<span class="cstat-no" title="statement not covered" >J(t,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >!w.state.isVisible&amp;&amp;k.parentNode&amp;&amp;k.parentNode.contains(k)&amp;&amp;e()}</span>))}</span>function <span class="fstat-no" title="function not covered" >q(</span>t,e){<span class="cstat-no" title="statement not covered" >J(t,e)}</span>function <span class="fstat-no" title="function not covered" >J(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >A().box;</span>function <span class="fstat-no" title="function not covered" >r(</span>t){<span class="cstat-no" title="statement not covered" >t.target===n&amp;&amp;(qe(n,"remove",r),e())}<span class="cstat-no" title="statement not covered" ></span>if(0===t)<span class="cstat-no" title="statement not covered" >return e();<span class="cstat-no" title="statement not covered" >q</span></span>e(n,"remove",s),qe(n,"add",r),s=r}</span>function <span class="fstat-no" title="function not covered" >W(</span>e,n,r){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=!1);v</span>ar o=<span class="cstat-no" title="statement not covered" >Te(w.props.triggerTarget||t);<span class="cstat-no" title="statement not covered" ></span>o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.addEventListener(e,n,r),f.push({node:t,eventType:e,handler:n,options:r})}</span>))}</span>function <span class="fstat-no" title="function not covered" >K(</span>){<span class="cstat-no" title="statement not covered" >E()&amp;&amp;(W("touchstart",G,{passive:!0}),W("touchend",X,{passive:!0})),Ee(w.props.trigger).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("manual"!==t)<span class="cstat-no" title="statement not covered" >switch(W(t,G),t){case"mouseenter":<span class="cstat-no" title="statement not covered" >W("mouseleave",X);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"focus":<span class="cstat-no" title="statement not covered" >W(Ze?"focusout":"blur",Q);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"focusin":<span class="cstat-no" title="statement not covered" >W("focusout",Q);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>))}</span>function <span class="fstat-no" title="function not covered" >U(</span>){<span class="cstat-no" title="statement not covered" >f.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.node,</span>n=<span class="cstat-no" title="statement not covered" >t.eventType,</span>r=<span class="cstat-no" title="statement not covered" >t.handler,</span>o=<span class="cstat-no" title="statement not covered" >t.options;<span class="cstat-no" title="statement not covered" ></span>e.removeEventListener(n,r,o)}</span>)),f=[]}</span>function <span class="fstat-no" title="function not covered" >G(</span>t){var e,n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(w.state.isEnabled&amp;&amp;!Z(t)&amp;&amp;!u){var r=<span class="cstat-no" title="statement not covered" >"focus"===(null==(e=i)?void 0:e.type);<span class="cstat-no" title="statement not covered" ></span>i=t,c=t.currentTarget,P(),!w.state.isVisible&amp;&amp;ze(t)&amp;&amp;vn.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t)}</span>)),"click"===t.type&amp;&amp;(w.props.trigger.indexOf("mouseenter")&lt;0||p)&amp;&amp;!1!==w.props.hideOnClick&amp;&amp;w.state.isVisible?n=!0:ot(t),"click"===t.type&amp;&amp;(p=!n),n&amp;&amp;!r&amp;&amp;it(t)}</span>}</span>function <span class="fstat-no" title="function not covered" >Y(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.target,</span>n=<span class="cstat-no" title="statement not covered" >N().contains(e)||k.contains(e);<span class="cstat-no" title="statement not covered" ></span>if("mousemove"!==t.type||!n){var r=<span class="cstat-no" title="statement not covered" >rt().concat(k).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,n=<span class="cstat-no" title="statement not covered" >t._tippy,</span>r=<span class="cstat-no" title="statement not covered" >null==(e=n.popperInstance)?void 0:e.state;<span class="cstat-no" title="statement not covered" ></span>return r?{popperRect:t.getBoundingClientRect(),popperState:r,props:l}:null}</span>)).filter(Boolean);<span class="cstat-no" title="statement not covered" ></span>He(r,t)&amp;&amp;(z(),it(t))}</span>}</span>function <span class="fstat-no" title="function not covered" >X(</span>t){var e=<span class="cstat-no" title="statement not covered" >Z(t)||w.props.trigger.indexOf("click")&gt;=0&amp;&amp;p;<span class="cstat-no" title="statement not covered" ></span>e||(w.props.interactive?w.hideWithInteractivity(t):it(t))}</span>function <span class="fstat-no" title="function not covered" >Q(</span>t){<span class="cstat-no" title="statement not covered" >w.props.trigger.indexOf("focusin")&lt;0&amp;&amp;t.target!==N()||w.props.interactive&amp;&amp;t.relatedTarget&amp;&amp;k.contains(t.relatedTarget)||it(t)}</span>function <span class="fstat-no" title="function not covered" >Z(</span>t){<span class="cstat-no" title="statement not covered" >return!!Je.isTouch&amp;&amp;E()!==t.type.indexOf("touch")&gt;=0}</span>function <span class="fstat-no" title="function not covered" >tt(</span>){<span class="cstat-no" title="statement not covered" >et();v</span>ar e=<span class="cstat-no" title="statement not covered" >w.props,</span>n=<span class="cstat-no" title="statement not covered" >e.popperOptions,</span>r=<span class="cstat-no" title="statement not covered" >e.placement,</span>o=<span class="cstat-no" title="statement not covered" >e.offset,</span>i=<span class="cstat-no" title="statement not covered" >e.getReferenceClientRect,</span>s=<span class="cstat-no" title="statement not covered" >e.moveTransition,</span>c=<span class="cstat-no" title="statement not covered" >T()?dn(k).arrow:null,</span>l=<span class="cstat-no" title="statement not covered" >i?{getBoundingClientRect:i,contextElement:i.contextElement||N()}:t,</span>p=<span class="cstat-no" title="statement not covered" >{name:"$$tippy",enabled:!0,phase:"beforeWrite",requires:["computeStyles"],fn:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.state;<span class="cstat-no" title="statement not covered" ></span>if(T()){var n=<span class="cstat-no" title="statement not covered" >A(),</span>r=<span class="cstat-no" title="statement not covered" >n.box;<span class="cstat-no" title="statement not covered" ></span>["placement","reference-hidden","escaped"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"placement"===t?r.setAttribute("data-placement",e.placement):e.attributes.popper["data-popper-"+t]?r.setAttribute("data-"+t,""):r.removeAttribute("data-"+t)}</span>)),e.attributes.popper={}}</span>}</span>},</span>u=<span class="cstat-no" title="statement not covered" >[{name:"offset",options:{offset:o}},{name:"preventOverflow",options:{padding:{top:2,bottom:2,left:5,right:5}}},{name:"flip",options:{padding:5}},{name:"computeStyles",options:{adaptive:!s}},p];<span class="cstat-no" title="statement not covered" ></span>T()&amp;&amp;c&amp;&amp;u.push({name:"arrow",options:{element:c,padding:3}}),u.push.apply(u,(null==n?void 0:n.modifiers)||[]),w.popperInstance=ve(l,k,Object.assign({},n,{placement:r,onFirstUpdate:a,modifiers:u}))}</span>function <span class="fstat-no" title="function not covered" >et(</span>){<span class="cstat-no" title="statement not covered" >w.popperInstance&amp;&amp;(w.popperInstance.destroy(),w.popperInstance=null)}</span>function <span class="fstat-no" title="function not covered" >nt(</span>){var t,e=<span class="cstat-no" title="statement not covered" >w.props.appendTo,</span>n=<span class="cstat-no" title="statement not covered" >N();<span class="cstat-no" title="statement not covered" ></span>t=w.props.interactive&amp;&amp;e===nn.appendTo||"parent"===e?n.parentNode:Me(e,[n]),t.contains(k)||t.appendChild(k),tt()}</span>function <span class="fstat-no" title="function not covered" >rt(</span>){<span class="cstat-no" title="statement not covered" >return Ie(k.querySelectorAll("[data-tippy-root]"))}</span>function <span class="fstat-no" title="function not covered" >ot(</span>t){<span class="cstat-no" title="statement not covered" >w.clearDelayTimeouts(),t&amp;&amp;R("onTrigger",[w,t]),$();v</span>ar e=<span class="cstat-no" title="statement not covered" >I(!0),</span>r=<span class="cstat-no" title="statement not covered" >C(),</span>o=<span class="cstat-no" title="statement not covered" >r[0],</span>i=<span class="cstat-no" title="statement not covered" >r[1];<span class="cstat-no" title="statement not covered" ></span>Je.isTouch&amp;&amp;"hold"===o&amp;&amp;i&amp;&amp;(e=i),e?n=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >w.show()}</span>),e):w.show()}</span>function <span class="fstat-no" title="function not covered" >it(</span>t){<span class="cstat-no" title="statement not covered" >if(w.clearDelayTimeouts(),R("onUntrigger",[w,t]),w.state.isVisible){<span class="cstat-no" title="statement not covered" >if(!(w.props.trigger.indexOf("mouseenter")&gt;=0&amp;&amp;w.props.trigger.indexOf("click")&gt;=0&amp;&amp;["mouseleave","mousemove"].indexOf(t.type)&gt;=0&amp;&amp;p)){var e=<span class="cstat-no" title="statement not covered" >I(!1);<span class="cstat-no" title="statement not covered" ></span>e?r=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >w.state.isVisible&amp;&amp;w.hide()}</span>),e):o=requestAnimationFrame((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >w.hide()}</span>))}</span>}</span>else <span class="cstat-no" title="statement not covered" >F()}</span></span>function <span class="fstat-no" title="function not covered" >st(</span>){<span class="cstat-no" title="statement not covered" >w.state.isEnabled=!0}</span>function <span class="fstat-no" title="function not covered" >at(</span>){<span class="cstat-no" title="statement not covered" >w.hide(),w.state.isEnabled=!1}</span>function <span class="fstat-no" title="function not covered" >ct(</span>){<span class="cstat-no" title="statement not covered" >clearTimeout(n),clearTimeout(r),cancelAnimationFrame(o)}</span>function <span class="fstat-no" title="function not covered" >lt(</span>e){<span class="cstat-no" title="statement not covered" >if(!w.state.isDestroyed){<span class="cstat-no" title="statement not covered" >R("onBeforeUpdate",[w,e]),U();v</span>ar n=<span class="cstat-no" title="statement not covered" >w.props,</span>r=<span class="cstat-no" title="statement not covered" >cn(t,Object.assign({},w.props,{},e,{ignoreAttributes:!0}));<span class="cstat-no" title="statement not covered" ></span>w.props=r,K(),n.interactiveDebounce!==r.interactiveDebounce&amp;&amp;(z(),m=Ce(Y,r.interactiveDebounce)),n.triggerTarget&amp;&amp;!r.triggerTarget?Te(n.triggerTarget).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.removeAttribute("aria-expanded")}</span>)):r.triggerTarget&amp;&amp;t.removeAttribute("aria-expanded"),P(),D(),x&amp;&amp;x(n,r),w.popperInstance&amp;&amp;(tt(),rt().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >requestAnimationFrame(t._tippy.popperInstance.forceUpdate)}</span>))),R("onAfterUpdate",[w,e])}</span>}</span>function <span class="fstat-no" title="function not covered" >pt(</span>t){<span class="cstat-no" title="statement not covered" >w.setProps({content:t})}</span>function <span class="fstat-no" title="function not covered" >ut(</span>){var t=<span class="cstat-no" title="statement not covered" >w.state.isVisible,</span>e=<span class="cstat-no" title="statement not covered" >w.state.isDestroyed,</span>n=<span class="cstat-no" title="statement not covered" >!w.state.isEnabled,</span>r=<span class="cstat-no" title="statement not covered" >Je.isTouch&amp;&amp;!w.props.touch,</span>o=<span class="cstat-no" title="statement not covered" >xe(w.props.duration,0,nn.duration);<span class="cstat-no" title="statement not covered" ></span>if(!(t||e||n||r)&amp;&amp;!N().hasAttribute("disabled")&amp;&amp;(R("onShow",[w],!1),!1!==w.props.onShow(w))){<span class="cstat-no" title="statement not covered" >if(w.state.isVisible=!0,T()&amp;&amp;(k.style.visibility="visible"),D(),$(),w.state.isMounted||(k.style.transition="none"),T()){var i=<span class="cstat-no" title="statement not covered" >A(),</span>s=<span class="cstat-no" title="statement not covered" >i.box,</span>c=<span class="cstat-no" title="statement not covered" >i.content;<span class="cstat-no" title="statement not covered" ></span>Ve([s,c],0)}<span class="cstat-no" title="statement not covered" ></span>a</span>=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t;<span class="cstat-no" title="statement not covered" >if(w.state.isVisible&amp;&amp;!d){<span class="cstat-no" title="statement not covered" >if(d=!0,k.offsetHeight,k.style.transition=w.props.moveTransition,T()&amp;&amp;w.props.animation){var e=<span class="cstat-no" title="statement not covered" >A(),</span>n=<span class="cstat-no" title="statement not covered" >e.box,</span>r=<span class="cstat-no" title="statement not covered" >e.content;<span class="cstat-no" title="statement not covered" ></span>Ve([n,r],o),$e([n,r],"visible")}<span class="cstat-no" title="statement not covered" ></span>_</span>(),P(),Ne(gn,w),null==(t=w.popperInstance)||t.forceUpdate(),w.state.isMounted=!0,R("onMount",[w]),w.props.animation&amp;&amp;T()&amp;&amp;q(o,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >w.state.isShown=!0,R("onShown",[w])}</span>))}</span>}</span>,nt()}</span>}</span>function <span class="fstat-no" title="function not covered" >ht(</span>){var t=<span class="cstat-no" title="statement not covered" >!w.state.isVisible,</span>e=<span class="cstat-no" title="statement not covered" >w.state.isDestroyed,</span>n=<span class="cstat-no" title="statement not covered" >!w.state.isEnabled,</span>r=<span class="cstat-no" title="statement not covered" >xe(w.props.duration,1,nn.duration);<span class="cstat-no" title="statement not covered" ></span>if(!(t||e||n)&amp;&amp;(R("onHide",[w],!1),!1!==w.props.onHide(w))){<span class="cstat-no" title="statement not covered" >if(w.state.isVisible=!1,w.state.isShown=!1,d=!1,p=!1,T()&amp;&amp;(k.style.visibility="hidden"),z(),F(),D(),T()){var o=<span class="cstat-no" title="statement not covered" >A(),</span>i=<span class="cstat-no" title="statement not covered" >o.box,</span>s=<span class="cstat-no" title="statement not covered" >o.content;<span class="cstat-no" title="statement not covered" ></span>w.props.animation&amp;&amp;(Ve([i,s],r),$e([i,s],"hidden"))}<span class="cstat-no" title="statement not covered" ></span>_</span>(),P(),w.props.animation?T()&amp;&amp;H(r,w.unmount):w.unmount()}</span>}</span>function <span class="fstat-no" title="function not covered" >dt(</span>t){<span class="cstat-no" title="statement not covered" >j().addEventListener("mousemove",m),Ne(vn,m),m(t)}</span>function <span class="fstat-no" title="function not covered" >ft(</span>){<span class="cstat-no" title="statement not covered" >w.state.isVisible&amp;&amp;w.hide(),w.state.isMounted&amp;&amp;(et(),rt().forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t._tippy.unmount()}</span>)),k.parentNode&amp;&amp;k.parentNode.removeChild(k),gn=gn.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t!==w}</span>)),w.state.isMounted=!1,R("onHidden",[w]))}</span>function <span class="fstat-no" title="function not covered" >mt(</span>){<span class="cstat-no" title="statement not covered" >w.state.isDestroyed||(w.clearDelayTimeouts(),w.unmount(),U(),delete t._tippy,w.state.isDestroyed=!0,R("onDestroy",[w]))}</span>}function <span class="fstat-no" title="function not covered" >bn(</span>t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e={});v</span>ar n=<span class="cstat-no" title="statement not covered" >nn.plugins.concat(e.plugins||[]);<span class="cstat-no" title="statement not covered" ></span>Ye();v</span>ar r=<span class="cstat-no" title="statement not covered" >Object.assign({},e,{plugins:n}),</span>o=<span class="cstat-no" title="statement not covered" >Le(t),</span>i=<span class="cstat-no" title="statement not covered" >o.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >e&amp;&amp;yn(e,r);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;t.push(n),t}</span>),[]);<span class="cstat-no" title="statement not covered" ></span>return _e(t)?i[0]:i}<span class="cstat-no" title="statement not covered" ></span>bn.defaultProps=nn,bn.setDefaultProps=on,bn.currentInput=Je;<span class="cstat-no" title="statement not covered" >O</span>bject.assign({},Dt,{effect:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >{popper:{position:e.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};<span class="cstat-no" title="statement not covered" ></span>Object.assign(e.elements.popper.style,n.popper),e.styles=n,e.elements.arrow&amp;&amp;Object.assign(e.elements.arrow.style,n.arrow)}</span>});<span class="cstat-no" title="statement not covered" >b</span>n.setDefaultProps({render:fn});v</span>ar wn=<span class="cstat-no" title="statement not covered" >bn;</span>function <span class="fstat-no" title="function not covered" >On(</span>t){<span class="cstat-no" title="statement not covered" >this.content=t}<span class="cstat-no" title="statement not covered" ></span>On.prototype={constructor:On,find:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.content.length;e+=2)<span class="cstat-no" title="statement not covered" >if(this.content[e]===t)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn-1}</span>,get:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.find(t);<span class="cstat-no" title="statement not covered" ></span>return-1==e?void 0:this.content[e+1]}</span>,update:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >n&amp;&amp;n!=t?this.remove(n):this,</span>o=<span class="cstat-no" title="statement not covered" >r.find(t),</span>i=<span class="cstat-no" title="statement not covered" >r.content.slice();<span class="cstat-no" title="statement not covered" ></span>return-1==o?i.push(n||t,e):(i[o+1]=e,n&amp;&amp;(i[o]=n)),new On(i)}</span>,remove:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.find(t);<span class="cstat-no" title="statement not covered" ></span>if(-1==e)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.content.slice();<span class="cstat-no" title="statement not covered" ></span>return n.splice(e,2),new On(n)}</span>,addToStart:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new On([t,e].concat(this.remove(t).content))}</span>,addToEnd:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this.remove(t).content.slice();<span class="cstat-no" title="statement not covered" ></span>return n.push(t,e),new On(n)}</span>,addBefore:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this.remove(e),</span>o=<span class="cstat-no" title="statement not covered" >r.content.slice(),</span>i=<span class="cstat-no" title="statement not covered" >r.find(t);<span class="cstat-no" title="statement not covered" ></span>return o.splice(-1==i?o.length:i,0,e,n),new On(o)}</span>,forEach:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.content.length;e+=2)<span class="cstat-no" title="statement not covered" >t(this.content[e],this.content[e+1])}</span></span>,prepend:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=On.from(t),t.size?new On(t.content.concat(this.subtract(t).content)):this}</span>,append:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=On.from(t),t.size?new On(this.subtract(t).content.concat(t.content)):this}</span>,subtract:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t=On.from(t);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.content.length;n+=2)<span class="cstat-no" title="statement not covered" >e=e.remove(t.content[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,<span class="fstat-no" title="function not covered" >ge</span>t size(){<span class="cstat-no" title="statement not covered" >return this.content.length&gt;&gt;1}</span>},On.from=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t instanceof On)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >e.push(n,t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn new On(e)}</span>;v</span>ar kn=<span class="cstat-no" title="statement not covered" >On,</span>xn=<span class="cstat-no" title="statement not covered" >kn;</span>function <span class="fstat-no" title="function not covered" >Sn(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0;</span>;r++){<span class="cstat-no" title="statement not covered" >if(r==t.childCount||r==e.childCount)<span class="cstat-no" title="statement not covered" >return t.childCount==e.childCount?null:n;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t.child(r),</span>i=<span class="cstat-no" title="statement not covered" >e.child(r);<span class="cstat-no" title="statement not covered" ></span>if(o!=i){<span class="cstat-no" title="statement not covered" >if(!o.sameMarkup(i))<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.isText&amp;&amp;o.text!=i.text){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>o.text[s]==i.text[s];s++)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o.content.size||i.content.size){var a=<span class="cstat-no" title="statement not covered" >Sn(o.content,i.content,n+1);<span class="cstat-no" title="statement not covered" ></span>if(null!=a)<span class="cstat-no" title="statement not covered" >return a}<span class="cstat-no" title="statement not covered" ></span></span>n</span>+=o.nodeSize}</span>else <span class="cstat-no" title="statement not covered" >n+=o.nodeSize}</span></span>}</span>function <span class="fstat-no" title="function not covered" >Mn(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >t.childCount,</span>i=<span class="cstat-no" title="statement not covered" >e.childCount;</span>;){<span class="cstat-no" title="statement not covered" >if(0==o||0==i)<span class="cstat-no" title="statement not covered" >return o==i?null:{a:n,b:r};v</span></span>ar s=<span class="cstat-no" title="statement not covered" >t.child(--o),</span>a=<span class="cstat-no" title="statement not covered" >e.child(--i),</span>c=<span class="cstat-no" title="statement not covered" >s.nodeSize;<span class="cstat-no" title="statement not covered" ></span>if(s!=a){<span class="cstat-no" title="statement not covered" >if(!s.sameMarkup(a))<span class="cstat-no" title="statement not covered" >return{a:n,b:r};<span class="cstat-no" title="statement not covered" >i</span></span>f(s.isText&amp;&amp;s.text!=a.text){var l=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" >Math.min(s.text.length,a.text.length);<span class="cstat-no" title="statement not covered" ></span>while(l&lt;p&amp;&amp;s.text[s.text.length-l-1]==a.text[a.text.length-l-1])<span class="cstat-no" title="statement not covered" >l++,n--,r--;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{a:n,b:r}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.content.size||a.content.size){var u=<span class="cstat-no" title="statement not covered" >Mn(s.content,a.content,n-1,r-1);<span class="cstat-no" title="statement not covered" ></span>if(u)<span class="cstat-no" title="statement not covered" >return u}<span class="cstat-no" title="statement not covered" ></span></span>n</span>-=c,r-=c}</span>else <span class="cstat-no" title="statement not covered" >n-=c,r-=c}</span></span>}</span>var Cn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(this.content=t,this.size=e||0,null==e)<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >this.size+=t[n].nodeSize}</span></span></span>,</span>En=<span class="cstat-no" title="statement not covered" >{firstChild:{configurable:!0},lastChild:{configurable:!0},childCount:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>Cn.prototype.nodesBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=0);<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;e;i++){var a=<span class="cstat-no" title="statement not covered" >this.content[i],</span>c=<span class="cstat-no" title="statement not covered" >s+a.nodeSize;<span class="cstat-no" title="statement not covered" ></span>if(c&gt;t&amp;&amp;!1!==n(a,r+s,o,i)&amp;&amp;a.content.size){var l=<span class="cstat-no" title="statement not covered" >s+1;<span class="cstat-no" title="statement not covered" ></span>a.nodesBetween(Math.max(0,t-l),Math.min(a.content.size,e-l),n,r+l)}<span class="cstat-no" title="statement not covered" ></span>s</span>=c}</span>}</span>,Cn.prototype.descendants=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.nodesBetween(0,this.size,t)}</span>,Cn.prototype.textBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >"",</span>i=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>return this.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(s,a){<span class="cstat-no" title="statement not covered" >s.isText?(o+=s.text.slice(Math.max(t,a)-a,e-a),i=!n):s.isLeaf&amp;&amp;r?(o+=r,i=!n):!i&amp;&amp;s.isBlock&amp;&amp;(o+=n,i=!0)}</span>),0),o}</span>,Cn.prototype.append=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t.size)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.size)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.lastChild,</span>n=<span class="cstat-no" title="statement not covered" >t.firstChild,</span>r=<span class="cstat-no" title="statement not covered" >this.content.slice(),</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(e.isText&amp;&amp;e.sameMarkup(n)&amp;&amp;(r[r.length-1]=e.withText(e.text+n.text),o=1);o&lt;t.content.length;o++)<span class="cstat-no" title="statement not covered" >r.push(t.content[o]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Cn(r,this.size+t.size)}</span>,Cn.prototype.cut=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(null==e&amp;&amp;(e=this.size),0==t&amp;&amp;e==this.size)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;t)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e;o++){var s=<span class="cstat-no" title="statement not covered" >this.content[o],</span>a=<span class="cstat-no" title="statement not covered" >i+s.nodeSize;<span class="cstat-no" title="statement not covered" ></span>a&gt;t&amp;&amp;((i&lt;t||a&gt;e)&amp;&amp;(s=s.isText?s.cut(Math.max(0,t-i),Math.min(s.text.length,e-i)):s.cut(Math.max(0,t-i-1),Math.min(s.content.size,e-i-1))),n.push(s),r+=s.nodeSize),i=a}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn new Cn(n,r)}</span>,Cn.prototype.cutByIndex=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t==e?Cn.empty:0==t&amp;&amp;e==this.content.length?this:new Cn(this.content.slice(t,e))}</span>,Cn.prototype.replaceChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this.content[t];<span class="cstat-no" title="statement not covered" ></span>if(n==e)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.content.slice(),</span>o=<span class="cstat-no" title="statement not covered" >this.size+e.nodeSize-n.nodeSize;<span class="cstat-no" title="statement not covered" ></span>return r[t]=e,new Cn(r,o)}</span>,Cn.prototype.addToStart=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Cn([t].concat(this.content),this.size+t.nodeSize)}</span>,Cn.prototype.addToEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Cn(this.content.concat(t),this.size+t.nodeSize)}</span>,Cn.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.content.length!=t.content.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.content.length;e++)<span class="cstat-no" title="statement not covered" >if(!this.content[e].eq(t.content[e]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,En.firstChild.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.length?this.content[0]:null}</span>,En.lastChild.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.length?this.content[this.content.length-1]:null}</span>,En.childCount.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.length}</span>,Cn.prototype.child=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.content[t];<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index "+t+" out of range for "+this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,Cn.prototype.maybeChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.content[t]}</span>,Cn.prototype.forEach=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.content.length;e++){var r=<span class="cstat-no" title="statement not covered" >this.content[e];<span class="cstat-no" title="statement not covered" ></span>t(r,n,e),n+=r.nodeSize}</span>}</span>,Cn.prototype.findDiffStart=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=0),Sn(this,t,e)}</span>,Cn.prototype.findDiffEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=this.size),void 0===n&amp;&amp;(n=t.size),Mn(this,t,e,n)}</span>,Cn.prototype.findIndex=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(void 0===e&amp;&amp;(e=-1),0==t)<span class="cstat-no" title="statement not covered" >return Nn(0,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(t==this.size)<span class="cstat-no" title="statement not covered" >return Nn(this.content.length,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(t&gt;this.size||t&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Position "+t+" outside of fragment ("+this+")");<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>;n++){var o=<span class="cstat-no" title="statement not covered" >this.child(n),</span>i=<span class="cstat-no" title="statement not covered" >r+o.nodeSize;<span class="cstat-no" title="statement not covered" ></span>if(i&gt;=t)<span class="cstat-no" title="statement not covered" >return i==t||e&gt;0?Nn(n+1,i):Nn(n,r);<span class="cstat-no" title="statement not covered" >r</span></span>=i}</span>}</span>,Cn.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"&lt;"+this.toStringInner()+"&gt;"}</span>,Cn.prototype.toStringInner=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.join(", ")}</span>,Cn.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.length?this.content.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toJSON()}</span>)):null}</span>,Cn.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return Cn.empty;<span class="cstat-no" title="statement not covered" >i</span></span>f(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Fragment.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Cn(e.map(t.nodeFromJSON))}</span>,Cn.fromArray=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return Cn.empty;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e,n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++){var o=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>n+=o.nodeSize,r&amp;&amp;o.isText&amp;&amp;t[r-1].sameMarkup(o)?(e||(e=t.slice(0,r)),e[e.length-1]=o.withText(e[e.length-1].text+o.text)):e&amp;&amp;e.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Cn(e||t,n)}</span>,Cn.from=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return Cn.empty;<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof Cn)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(t))<span class="cstat-no" title="statement not covered" >return this.fromArray(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.attrs)<span class="cstat-no" title="statement not covered" >return new Cn([t],t.nodeSize);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new RangeError("Can not convert "+t+" to a Fragment"+(t.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}</span>,Object.defineProperties(Cn.prototype,En);v</span>ar Tn=<span class="cstat-no" title="statement not covered" >{index:0,offset:0};</span>function <span class="fstat-no" title="function not covered" >Nn(</span>t,e){<span class="cstat-no" title="statement not covered" >return Tn.index=t,Tn.offset=e,Tn}</span>function <span class="fstat-no" title="function not covered" >jn(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t===e)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t||"object"!=typeof t||!e||"object"!=typeof e)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >Array.isArray(t);<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(e)!=n)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(n){<span class="cstat-no" title="statement not covered" >if(t.length!=e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >if(!jn(t[r],e[r]))<span class="cstat-no" title="statement not covered" >return!1}</span></span></span>else{<span class="cstat-no" title="statement not covered" >for(var o in t)<span class="cstat-no" title="statement not covered" >if(!(o in e)||!jn(t[o],e[o]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(var i in e)<span class="cstat-no" title="statement not covered" >if(!(i in t))<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>Cn.empty=new Cn([],0);v</span>ar An=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.type=t,this.attrs=e}</span>;</span>function <span class="fstat-no" title="function not covered" >In(</span>t){var e=<span class="cstat-no" title="statement not covered" >Error.call(this,t);<span class="cstat-no" title="statement not covered" ></span>return e.__proto__=In.prototype,e}<span class="cstat-no" title="statement not covered" ></span>An.prototype.addToSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e,n=<span class="cstat-no" title="statement not covered" >!1,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++){var o=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>if(this.eq(o))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.type.excludes(o.type))<span class="cstat-no" title="statement not covered" >e||(e=t.slice(0,r));e</span>lse{<span class="cstat-no" title="statement not covered" >if(o.type.excludes(this.type))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >!</span></span>n&amp;&amp;o.type.rank&gt;this.type.rank&amp;&amp;(e||(e=t.slice(0,r)),e.push(this),n=!0),e&amp;&amp;e.push(o)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e||(e=t.slice()),n||e.push(this),e}</span>,An.prototype.removeFromSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(this.eq(t[e]))<span class="cstat-no" title="statement not covered" >return t.slice(0,e).concat(t.slice(e+1));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t}</span>,An.prototype.isInSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(this.eq(t[e]))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>,An.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this==t||this.type==t.type&amp;&amp;jn(this.attrs,t.attrs)}</span>,An.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >{type:this.type.name};<span class="cstat-no" title="statement not covered" ></span>for(var e in this.attrs){<span class="cstat-no" title="statement not covered" >t.attrs=this.attrs;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,An.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Mark.fromJSON");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.marks[e.type];<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new RangeError("There is no mark type "+e.type+" in this schema");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.create(e.attrs)}</span>,An.sameSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t==e)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.length!=e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >if(!t[n].eq(e[n]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,An.setFrom=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t||0==t.length)<span class="cstat-no" title="statement not covered" >return An.none;<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof An)<span class="cstat-no" title="statement not covered" >return[t];v</span></span>ar e=<span class="cstat-no" title="statement not covered" >t.slice();<span class="cstat-no" title="statement not covered" ></span>return e.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.type.rank-e.type.rank}</span>)),e}</span>,An.none=[],In.prototype=Object.create(Error.prototype),In.prototype.constructor=In,In.prototype.name="ReplaceError";v</span>ar Dn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.content=t,this.openStart=e,this.openEnd=n}</span>,</span>Rn=<span class="cstat-no" title="statement not covered" >{size:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >_n(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.findIndex(e),</span>o=<span class="cstat-no" title="statement not covered" >r.index,</span>i=<span class="cstat-no" title="statement not covered" >r.offset,</span>s=<span class="cstat-no" title="statement not covered" >t.maybeChild(o),</span>a=<span class="cstat-no" title="statement not covered" >t.findIndex(n),</span>c=<span class="cstat-no" title="statement not covered" >a.index,</span>l=<span class="cstat-no" title="statement not covered" >a.offset;<span class="cstat-no" title="statement not covered" ></span>if(i==e||s.isText){<span class="cstat-no" title="statement not covered" >if(l!=n&amp;&amp;!t.child(c).isText)<span class="cstat-no" title="statement not covered" >throw new RangeError("Removing non-flat range");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.cut(0,e).append(t.cut(n))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o!=c)<span class="cstat-no" title="statement not covered" >throw new RangeError("Removing non-flat range");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.replaceChild(o,s.copy(_n(s.content,e-i-1,n-i-1)))}</span>function <span class="fstat-no" title="function not covered" >Pn(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >t.findIndex(e),</span>i=<span class="cstat-no" title="statement not covered" >o.index,</span>s=<span class="cstat-no" title="statement not covered" >o.offset,</span>a=<span class="cstat-no" title="statement not covered" >t.maybeChild(i);<span class="cstat-no" title="statement not covered" ></span>if(s==e||a.isText)<span class="cstat-no" title="statement not covered" >return r&amp;&amp;!r.canReplace(i,i,n)?null:t.cut(0,e).append(n).append(t.cut(e));v</span></span>ar c=<span class="cstat-no" title="statement not covered" >Pn(a.content,e-s-1,n);<span class="cstat-no" title="statement not covered" ></span>return c&amp;&amp;t.replaceChild(i,a.copy(c))}</span>function <span class="fstat-no" title="function not covered" >zn(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(n.openStart&gt;t.depth)<span class="cstat-no" title="statement not covered" >throw new In("Inserted content deeper than insertion position");<span class="cstat-no" title="statement not covered" >i</span></span>f(t.depth-n.openStart!=e.depth-n.openEnd)<span class="cstat-no" title="statement not covered" >throw new In("Inconsistent open depths");<span class="cstat-no" title="statement not covered" >r</span></span>eturn Bn(t,e,n,0)}</span>function <span class="fstat-no" title="function not covered" >Bn(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >t.index(r),</span>i=<span class="cstat-no" title="statement not covered" >t.node(r);<span class="cstat-no" title="statement not covered" ></span>if(o==e.index(r)&amp;&amp;r&lt;t.depth-n.openStart){var s=<span class="cstat-no" title="statement not covered" >Bn(t,e,n,r+1);<span class="cstat-no" title="statement not covered" ></span>return i.copy(i.content.replaceChild(o,s))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.content.size){<span class="cstat-no" title="statement not covered" >if(n.openStart||n.openEnd||t.depth!=r||e.depth!=r){var a=<span class="cstat-no" title="statement not covered" >Wn(n,t),</span>c=<span class="cstat-no" title="statement not covered" >a.start,</span>l=<span class="cstat-no" title="statement not covered" >a.end;<span class="cstat-no" title="statement not covered" ></span>return Hn(i,qn(t,c,l,e,r))}</span>v</span>ar p=<span class="cstat-no" title="statement not covered" >t.parent,</span>u=<span class="cstat-no" title="statement not covered" >p.content;<span class="cstat-no" title="statement not covered" ></span>return Hn(p,u.cut(0,t.parentOffset).append(n.content).append(u.cut(e.parentOffset)))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Hn(i,Jn(t,e,r))}</span>function <span class="fstat-no" title="function not covered" >Ln(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e.type.compatibleContent(t.type))<span class="cstat-no" title="statement not covered" >throw new In("Cannot join "+e.type.name+" onto "+t.type.name)}</span></span>function <span class="fstat-no" title="function not covered" >Vn(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.node(n);<span class="cstat-no" title="statement not covered" ></span>return Ln(r,e.node(n)),r}</span>function <span class="fstat-no" title="function not covered" >$n(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >e.length-1;<span class="cstat-no" title="statement not covered" ></span>n&gt;=0&amp;&amp;t.isText&amp;&amp;t.sameMarkup(e[n])?e[n]=t.withText(e[n].text+t.text):e.push(t)}</span>function <span class="fstat-no" title="function not covered" >Fn(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >(e||t).node(n),</span>i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >e?e.index(n):o.childCount;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(i=t.index(n),t.depth&gt;n?i++:t.textOffset&amp;&amp;($n(t.nodeAfter,r),i++));<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >i;</span>a&lt;s;a++)<span class="cstat-no" title="statement not covered" >$n(o.child(a),r);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;e.depth==n&amp;&amp;e.textOffset&amp;&amp;$n(e.nodeBefore,r)}</span>function <span class="fstat-no" title="function not covered" >Hn(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!t.type.validContent(e))<span class="cstat-no" title="statement not covered" >throw new In("Invalid content for node "+t.type.name);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.copy(e)}</span>function <span class="fstat-no" title="function not covered" >qn(</span>t,e,n,r,o){var i=<span class="cstat-no" title="statement not covered" >t.depth&gt;o&amp;&amp;Vn(t,e,o+1),</span>s=<span class="cstat-no" title="statement not covered" >r.depth&gt;o&amp;&amp;Vn(n,r,o+1),</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return Fn(null,t,o,a),i&amp;&amp;s&amp;&amp;e.index(o)==n.index(o)?(Ln(i,s),$n(Hn(i,qn(t,e,n,r,o+1)),a)):(i&amp;&amp;$n(Hn(i,Jn(t,e,o+1)),a),Fn(e,n,o,a),s&amp;&amp;$n(Hn(s,Jn(n,r,o+1)),a)),Fn(r,null,o,a),new Cn(a)}</span>function <span class="fstat-no" title="function not covered" >Jn(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(Fn(null,t,n,r),t.depth&gt;n){var o=<span class="cstat-no" title="statement not covered" >Vn(t,e,n+1);<span class="cstat-no" title="statement not covered" ></span>$n(Hn(o,Jn(t,e,n+1)),r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Fn(e,null,n,r),new Cn(r)}</span>function <span class="fstat-no" title="function not covered" >Wn(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >e.depth-t.openStart,</span>r=<span class="cstat-no" title="statement not covered" >e.node(n),</span>o=<span class="cstat-no" title="statement not covered" >r.copy(t.content),</span>i=<span class="cstat-no" title="statement not covered" >n-1;</span>i&gt;=0;i--)<span class="cstat-no" title="statement not covered" >o=e.node(i).copy(Cn.from(o));<span class="cstat-no" title="statement not covered" >r</span></span>eturn{start:o.resolveNoCache(t.openStart+n),end:o.resolveNoCache(o.content.size-t.openEnd-n)}}<span class="cstat-no" title="statement not covered" ></span>Rn.size.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.size-this.openStart-this.openEnd}</span>,Dn.prototype.insertAt=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Pn(this.content,t+this.openStart,e,null);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;new Dn(n,this.openStart,this.openEnd)}</span>,Dn.prototype.removeBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new Dn(_n(this.content,t+this.openStart,e+this.openStart),this.openStart,this.openEnd)}</span>,Dn.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.content.eq(t.content)&amp;&amp;this.openStart==t.openStart&amp;&amp;this.openEnd==t.openEnd}</span>,Dn.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content+"("+this.openStart+","+this.openEnd+")"}</span>,Dn.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.content.size)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >{content:this.content.toJSON()};<span class="cstat-no" title="statement not covered" ></span>return this.openStart&gt;0&amp;&amp;(t.openStart=this.openStart),this.openEnd&gt;0&amp;&amp;(t.openEnd=this.openEnd),t}</span>,Dn.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return Dn.empty;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e.openStart||0,</span>r=<span class="cstat-no" title="statement not covered" >e.openEnd||0;<span class="cstat-no" title="statement not covered" ></span>if("number"!=typeof n||"number"!=typeof r)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Slice.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Dn(Cn.fromJSON(t,e.content),n,r)}</span>,Dn.maxOpen=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=!0);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >t.firstChild;</span>o&amp;&amp;!o.isLeaf&amp;&amp;(e||!o.type.spec.isolating);o=o.firstChild)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >t.lastChild;</span>i&amp;&amp;!i.isLeaf&amp;&amp;(e||!i.type.spec.isolating);i=i.lastChild)<span class="cstat-no" title="statement not covered" >r++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Dn(t,n,r)}</span>,Object.defineProperties(Dn.prototype,Rn),Dn.empty=new Dn(Cn.empty,0,0);v</span>ar Kn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.pos=t,this.path=e,this.depth=e.length/3-1,this.parentOffset=n}</span>,</span>Un=<span class="cstat-no" title="statement not covered" >{parent:{configurable:!0},doc:{configurable:!0},textOffset:{configurable:!0},nodeAfter:{configurable:!0},nodeBefore:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>Kn.prototype.resolveDepth=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.depth:t&lt;0?this.depth+t:t}</span>,Un.parent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node(this.depth)}</span>,Un.doc.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node(0)}</span>,Kn.prototype.node=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.path[3*this.resolveDepth(t)]}</span>,Kn.prototype.index=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.path[3*this.resolveDepth(t)+1]}</span>,Kn.prototype.indexAfter=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=this.resolveDepth(t),this.index(t)+(t!=this.depth||this.textOffset?1:0)}</span>,Kn.prototype.start=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=this.resolveDepth(t),0==t?0:this.path[3*t-1]+1}</span>,Kn.prototype.end=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=this.resolveDepth(t),this.start(t)+this.node(t).content.size}</span>,Kn.prototype.before=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t=this.resolveDepth(t),!t)<span class="cstat-no" title="statement not covered" >throw new RangeError("There is no position before the top-level node");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t==this.depth+1?this.pos:this.path[3*t-1]}</span>,Kn.prototype.after=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t=this.resolveDepth(t),!t)<span class="cstat-no" title="statement not covered" >throw new RangeError("There is no position after the top-level node");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t==this.depth+1?this.pos:this.path[3*t-1]+this.path[3*t].nodeSize}</span>,Un.textOffset.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.pos-this.path[this.path.length-1]}</span>,Un.nodeAfter.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.parent,</span>e=<span class="cstat-no" title="statement not covered" >this.index(this.depth);<span class="cstat-no" title="statement not covered" ></span>if(e==t.childCount)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.pos-this.path[this.path.length-1],</span>r=<span class="cstat-no" title="statement not covered" >t.child(e);<span class="cstat-no" title="statement not covered" ></span>return n?t.child(e).cut(n):r}</span>,Un.nodeBefore.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.index(this.depth),</span>e=<span class="cstat-no" title="statement not covered" >this.pos-this.path[this.path.length-1];<span class="cstat-no" title="statement not covered" ></span>return e?this.parent.child(t).cut(0,e):0==t?null:this.parent.child(t-1)}</span>,Kn.prototype.posAtIndex=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e=this.resolveDepth(e);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >this.path[3*e],</span>r=<span class="cstat-no" title="statement not covered" >0==e?0:this.path[3*e-1]+1,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t;o++)<span class="cstat-no" title="statement not covered" >r+=n.child(o).nodeSize;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,Kn.prototype.marks=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.parent,</span>e=<span class="cstat-no" title="statement not covered" >this.index();<span class="cstat-no" title="statement not covered" ></span>if(0==t.content.size)<span class="cstat-no" title="statement not covered" >return An.none;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.textOffset)<span class="cstat-no" title="statement not covered" >return t.child(e).marks;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.maybeChild(e-1),</span>r=<span class="cstat-no" title="statement not covered" >t.maybeChild(e);<span class="cstat-no" title="statement not covered" ></span>if(!n){var o=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>n=r,r=o}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >n.marks,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >!1!==i[s].type.spec.inclusive||r&amp;&amp;i[s].isInSet(r.marks)||(i=i[s--].removeFromSet(i));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>,Kn.prototype.marksAcross=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.parent.maybeChild(this.index());<span class="cstat-no" title="statement not covered" ></span>if(!e||!e.isInline)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >e.marks,</span>r=<span class="cstat-no" title="statement not covered" >t.parent.maybeChild(t.index()),</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n.length;o++)<span class="cstat-no" title="statement not covered" >!1!==n[o].type.spec.inclusive||r&amp;&amp;n[o].isInSet(r.marks)||(n=n[o--].removeFromSet(n));<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,Kn.prototype.sharedDepth=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.depth;</span>e&gt;0;e--)<span class="cstat-no" title="statement not covered" >if(this.start(e)&lt;=t&amp;&amp;this.end(e)&gt;=t)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn 0}</span>,Kn.prototype.blockRange=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(void 0===t&amp;&amp;(t=this),t.pos&lt;this.pos)<span class="cstat-no" title="statement not covered" >return t.blockRange(this);<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >this.depth-(this.parent.inlineContent||this.pos==t.pos?1:0);</span>n&gt;=0;n--)<span class="cstat-no" title="statement not covered" >if(t.pos&lt;=this.end(n)&amp;&amp;(!e||e(this.node(n))))<span class="cstat-no" title="statement not covered" >return new Qn(this,t,n)}</span></span></span>,Kn.prototype.sameParent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.pos-this.parentOffset==t.pos-t.parentOffset}</span>,Kn.prototype.max=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.pos&gt;this.pos?t:this}</span>,Kn.prototype.min=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.pos&lt;this.pos?t:this}</span>,Kn.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >"",</span>e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;=this.depth;e++)<span class="cstat-no" title="statement not covered" >t+=(t?"/":"")+this.node(e).type.name+"_"+this.index(e-1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t+":"+this.parentOffset}</span>,Kn.resolve=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!(e&gt;=0&amp;&amp;e&lt;=t.content.size))<span class="cstat-no" title="statement not covered" >throw new RangeError("Position "+e+" out of range");<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>i=<span class="cstat-no" title="statement not covered" >t;</span>;){var s=<span class="cstat-no" title="statement not covered" >i.content.findIndex(o),</span>a=<span class="cstat-no" title="statement not covered" >s.index,</span>c=<span class="cstat-no" title="statement not covered" >s.offset,</span>l=<span class="cstat-no" title="statement not covered" >o-c;<span class="cstat-no" title="statement not covered" ></span>if(n.push(i,a,r+c),!l)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(i=i.child(a),i.isText)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>=l-1,r+=c+1}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Kn(e,n,o)}</span>,Kn.resolveCached=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;Gn.length;n++){var r=<span class="cstat-no" title="statement not covered" >Gn[n];<span class="cstat-no" title="statement not covered" ></span>if(r.pos==e&amp;&amp;r.doc==t)<span class="cstat-no" title="statement not covered" >return r}</span></span>v</span>ar o=<span class="cstat-no" title="statement not covered" >Gn[Yn]=Kn.resolve(t,e);<span class="cstat-no" title="statement not covered" ></span>return Yn=(Yn+1)%Xn,o}</span>,Object.defineProperties(Kn.prototype,Un);v</span>ar Gn=<span class="cstat-no" title="statement not covered" >[],</span>Yn=<span class="cstat-no" title="statement not covered" >0,</span>Xn=<span class="cstat-no" title="statement not covered" >12,</span>Qn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.$from=t,this.$to=e,this.depth=n}</span>,</span>Zn=<span class="cstat-no" title="statement not covered" >{start:{configurable:!0},end:{configurable:!0},parent:{configurable:!0},startIndex:{configurable:!0},endIndex:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>Zn.start.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.before(this.depth+1)}</span>,Zn.end.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$to.after(this.depth+1)}</span>,Zn.parent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.node(this.depth)}</span>,Zn.startIndex.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.index(this.depth)}</span>,Zn.endIndex.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$to.indexAfter(this.depth)}</span>,Object.defineProperties(Qn.prototype,Zn);v</span>ar tr=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>er=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.type=t,this.attrs=e,this.content=n||Cn.empty,this.marks=r||An.none}</span>,</span>nr=<span class="cstat-no" title="statement not covered" >{nodeSize:{configurable:!0},childCount:{configurable:!0},textContent:{configurable:!0},firstChild:{configurable:!0},lastChild:{configurable:!0},isBlock:{configurable:!0},isTextblock:{configurable:!0},inlineContent:{configurable:!0},isInline:{configurable:!0},isText:{configurable:!0},isLeaf:{configurable:!0},isAtom:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>nr.nodeSize.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isLeaf?1:2+this.content.size}</span>,nr.childCount.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.childCount}</span>,er.prototype.child=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.content.child(t)}</span>,er.prototype.maybeChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.content.maybeChild(t)}</span>,er.prototype.forEach=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.content.forEach(t)}</span>,er.prototype.nodesBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=0),this.content.nodesBetween(t,e,n,r,this)}</span>,er.prototype.descendants=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.nodesBetween(0,this.content.size,t)}</span>,nr.textContent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.textBetween(0,this.content.size,"")}</span>,er.prototype.textBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return this.content.textBetween(t,e,n,r)}</span>,nr.firstChild.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.firstChild}</span>,nr.lastChild.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.lastChild}</span>,er.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this==t||this.sameMarkup(t)&amp;&amp;this.content.eq(t.content)}</span>,er.prototype.sameMarkup=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.hasMarkup(t.type,t.attrs,t.marks)}</span>,er.prototype.hasMarkup=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return this.type==t&amp;&amp;jn(this.attrs,e||t.defaultAttrs||tr)&amp;&amp;An.sameSet(this.marks,n||An.none)}</span>,er.prototype.copy=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return void 0===t&amp;&amp;(t=null),t==this.content?this:new this.constructor(this.type,this.attrs,t,this.marks)}</span>,er.prototype.mark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t==this.marks?this:new this.constructor(this.type,this.attrs,this.content,t)}</span>,er.prototype.cut=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return 0==t&amp;&amp;e==this.content.size?this:this.copy(this.content.cut(t,e))}</span>,er.prototype.slice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(void 0===e&amp;&amp;(e=this.content.size),void 0===n&amp;&amp;(n=!1),t==e)<span class="cstat-no" title="statement not covered" >return Dn.empty;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.resolve(t),</span>o=<span class="cstat-no" title="statement not covered" >this.resolve(e),</span>i=<span class="cstat-no" title="statement not covered" >n?0:r.sharedDepth(e),</span>s=<span class="cstat-no" title="statement not covered" >r.start(i),</span>a=<span class="cstat-no" title="statement not covered" >r.node(i),</span>c=<span class="cstat-no" title="statement not covered" >a.content.cut(r.pos-s,o.pos-s);<span class="cstat-no" title="statement not covered" ></span>return new Dn(c,r.depth-i,o.depth-i)}</span>,er.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return zn(this.resolve(t),this.resolve(e),n)}</span>,er.prototype.nodeAt=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this;</span>;){var n=<span class="cstat-no" title="statement not covered" >e.content.findIndex(t),</span>r=<span class="cstat-no" title="statement not covered" >n.index,</span>o=<span class="cstat-no" title="statement not covered" >n.offset;<span class="cstat-no" title="statement not covered" ></span>if(e=e.maybeChild(r),!e)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(o==t||e.isText)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >t</span></span>-=o+1}</span>}</span>,er.prototype.childAfter=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.content.findIndex(t),</span>n=<span class="cstat-no" title="statement not covered" >e.index,</span>r=<span class="cstat-no" title="statement not covered" >e.offset;<span class="cstat-no" title="statement not covered" ></span>return{node:this.content.maybeChild(n),index:n,offset:r}}</span>,er.prototype.childBefore=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(0==t)<span class="cstat-no" title="statement not covered" >return{node:null,index:0,offset:0};v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.content.findIndex(t),</span>n=<span class="cstat-no" title="statement not covered" >e.index,</span>r=<span class="cstat-no" title="statement not covered" >e.offset;<span class="cstat-no" title="statement not covered" ></span>if(r&lt;t)<span class="cstat-no" title="statement not covered" >return{node:this.content.child(n),index:n,offset:r};v</span></span>ar o=<span class="cstat-no" title="statement not covered" >this.content.child(n-1);<span class="cstat-no" title="statement not covered" ></span>return{node:o,index:n-1,offset:r-o.nodeSize}}</span>,er.prototype.resolve=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Kn.resolveCached(this,t)}</span>,er.prototype.resolveNoCache=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Kn.resolve(this,t)}</span>,er.prototype.rangeHasMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return e&gt;t&amp;&amp;this.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n.isInSet(t.marks)&amp;&amp;(r=!0),!r}</span>)),r}</span>,nr.isBlock.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isBlock}</span>,nr.isTextblock.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isTextblock}</span>,nr.inlineContent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.inlineContent}</span>,nr.isInline.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isInline}</span>,nr.isText.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isText}</span>,nr.isLeaf.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isLeaf}</span>,nr.isAtom.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isAtom}</span>,er.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.type.spec.toDebugString)<span class="cstat-no" title="statement not covered" >return this.type.spec.toDebugString(this);v</span></span>ar t=<span class="cstat-no" title="statement not covered" >this.type.name;<span class="cstat-no" title="statement not covered" ></span>return this.content.size&amp;&amp;(t+="("+this.content.toStringInner()+")"),or(this.marks,t)}</span>,er.prototype.contentMatchAt=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.type.contentMatch.matchFragment(this.content,0,t);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >throw new Error("Called contentMatchAt on a node with invalid content");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,er.prototype.canReplace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=Cn.empty),void 0===r&amp;&amp;(r=0),void 0===o&amp;&amp;(o=n.childCount);v</span>ar i=<span class="cstat-no" title="statement not covered" >this.contentMatchAt(t).matchFragment(n,r,o),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.matchFragment(this.content,e);<span class="cstat-no" title="statement not covered" ></span>if(!s||!s.validEnd)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var a=<span class="cstat-no" title="statement not covered" >r;</span>a&lt;o;a++)<span class="cstat-no" title="statement not covered" >if(!this.type.allowsMarks(n.child(a).marks))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,er.prototype.canReplaceWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >if(r&amp;&amp;!this.type.allowsMarks(r))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >this.contentMatchAt(t).matchType(n),</span>i=<span class="cstat-no" title="statement not covered" >o&amp;&amp;o.matchFragment(this.content,e);<span class="cstat-no" title="statement not covered" ></span>return!!i&amp;&amp;i.validEnd}</span>,er.prototype.canAppend=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.content.size?this.canReplace(this.childCount,this.childCount,t.content):this.type.compatibleContent(t.type)}</span>,er.prototype.check=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.type.validContent(this.content))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid content for node "+this.type.name+": "+this.content.toString().slice(0,50));<span class="cstat-no" title="statement not covered" >f</span></span>or(var t=<span class="cstat-no" title="statement not covered" >An.none,</span>e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.marks.length;e++)<span class="cstat-no" title="statement not covered" >t=this.marks[e].addToSet(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(!An.sameSet(t,this.marks))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid collection of marks for node "+this.type.name+": "+this.marks.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.type.name}</span>)));<span class="cstat-no" title="statement not covered" >t</span></span>his.content.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.check()}</span>))}</span>,er.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >{type:this.type.name};<span class="cstat-no" title="statement not covered" ></span>for(var e in this.attrs){<span class="cstat-no" title="statement not covered" >t.attrs=this.attrs;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.content.size&amp;&amp;(t.content=this.content.toJSON()),this.marks.length&amp;&amp;(t.marks=this.marks.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toJSON()}</span>))),t}</span>,er.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Node.fromJSON");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(e.marks){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(e.marks))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid mark data for Node.fromJSON");<span class="cstat-no" title="statement not covered" >n</span></span>=e.marks.map(t.markFromJSON)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("text"==e.type){<span class="cstat-no" title="statement not covered" >if("string"!=typeof e.text)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid text node in JSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.text(e.text,n)}</span>v</span>ar r=<span class="cstat-no" title="statement not covered" >Cn.fromJSON(t,e.content);<span class="cstat-no" title="statement not covered" ></span>return t.nodeType(e.type).create(e.attrs,r,n)}</span>,Object.defineProperties(er.prototype,nr);v</span>ar rr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o){<span class="cstat-no" title="statement not covered" >if(t.call(this,e,n,null,o),!r)<span class="cstat-no" title="statement not covered" >throw new RangeError("Empty text nodes are not allowed");<span class="cstat-no" title="statement not covered" >t</span></span>his.text=r}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{textContent:{configurable:!0},nodeSize:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return e.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.spec.toDebugString?this.type.spec.toDebugString(this):or(this.marks,JSON.stringify(this.text))}</span>,n.textContent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.text}</span>,e.prototype.textBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.text.slice(t,e)}</span>,n.nodeSize.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.text.length}</span>,e.prototype.mark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t==this.marks?this:new e(this.type,this.attrs,this.text,t)}</span>,e.prototype.withText=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t==this.text?this:new e(this.type,this.attrs,t,this.marks)}</span>,e.prototype.cut=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===t&amp;&amp;(t=0),void 0===e&amp;&amp;(e=this.text.length),0==t&amp;&amp;e==this.text.length?this:this.withText(this.text.slice(t,e))}</span>,e.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.sameMarkup(t)&amp;&amp;this.text==t.text}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >t.prototype.toJSON.call(this);<span class="cstat-no" title="statement not covered" ></span>return e.text=this.text,e}</span>,Object.defineProperties(e.prototype,n),e}</span>(er);</span>function <span class="fstat-no" title="function not covered" >or(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t.length-1;</span>n&gt;=0;n--)<span class="cstat-no" title="statement not covered" >e=t[n].type.name+"("+e+")";<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>var ir=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.validEnd=t,this.next=[],this.wrapCache=[]}</span>,</span>sr=<span class="cstat-no" title="statement not covered" >{inlineContent:{configurable:!0},defaultType:{configurable:!0},edgeCount:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>ir.parse=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >new ar(t,e);<span class="cstat-no" title="statement not covered" ></span>if(null==n.next)<span class="cstat-no" title="statement not covered" >return ir.empty;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >lr(n);<span class="cstat-no" title="statement not covered" ></span>n.next&amp;&amp;n.err("Unexpected trailing text");v</span>ar o=<span class="cstat-no" title="statement not covered" >br(vr(r));<span class="cstat-no" title="statement not covered" ></span>return wr(o,n),o}</span>,ir.prototype.matchType=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.next.length;e+=2)<span class="cstat-no" title="statement not covered" >if(this.next[e]==t)<span class="cstat-no" title="statement not covered" >return this.next[e+1];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn null}</span>,ir.prototype.matchFragment=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=0),void 0===n&amp;&amp;(n=t.childCount);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >e;</span>r&amp;&amp;o&lt;n;o++)<span class="cstat-no" title="statement not covered" >r=r.matchType(t.child(o).type);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,sr.inlineContent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.next[0];<span class="cstat-no" title="statement not covered" ></span>return!!t&amp;&amp;t.isInline}</span>,sr.defaultType.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;this.next.length;t+=2){var e=<span class="cstat-no" title="statement not covered" >this.next[t];<span class="cstat-no" title="statement not covered" ></span>if(!e.isText&amp;&amp;!e.hasRequiredAttrs())<span class="cstat-no" title="statement not covered" >return e}</span></span>}</span>,ir.prototype.compatible=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.next.length;e+=2)<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.next.length;n+=2)<span class="cstat-no" title="statement not covered" >if(this.next[e]==t.next[n])<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn!1}</span>,ir.prototype.fillBefore=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=!1),void 0===n&amp;&amp;(n=0);v</span>ar r=<span class="cstat-no" title="statement not covered" >[this];</span>function <span class="fstat-no" title="function not covered" >o(</span>i,s){var a=<span class="cstat-no" title="statement not covered" >i.matchFragment(t,n);<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;(!e||a.validEnd))<span class="cstat-no" title="statement not covered" >return Cn.from(s.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.createAndFill()}</span>)));<span class="cstat-no" title="statement not covered" >f</span></span>or(var c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;i.next.length;c+=2){var l=<span class="cstat-no" title="statement not covered" >i.next[c],</span>p=<span class="cstat-no" title="statement not covered" >i.next[c+1];<span class="cstat-no" title="statement not covered" ></span>if(!l.isText&amp;&amp;!l.hasRequiredAttrs()&amp;&amp;-1==r.indexOf(p)){<span class="cstat-no" title="statement not covered" >r.push(p);v</span>ar u=<span class="cstat-no" title="statement not covered" >o(p,s.concat(l));<span class="cstat-no" title="statement not covered" ></span>if(u)<span class="cstat-no" title="statement not covered" >return u}</span></span>}</span>}<span class="cstat-no" title="statement not covered" ></span>return o(this,[])}</span>,ir.prototype.findWrapping=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.wrapCache.length;e+=2)<span class="cstat-no" title="statement not covered" >if(this.wrapCache[e]==t)<span class="cstat-no" title="statement not covered" >return this.wrapCache[e+1];v</span></span></span>ar n=<span class="cstat-no" title="statement not covered" >this.computeWrapping(t);<span class="cstat-no" title="statement not covered" ></span>return this.wrapCache.push(t,n),n}</span>,ir.prototype.computeWrapping=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>n=<span class="cstat-no" title="statement not covered" >[{match:this,type:null,via:null}];<span class="cstat-no" title="statement not covered" ></span>while(n.length){var r=<span class="cstat-no" title="statement not covered" >n.shift(),</span>o=<span class="cstat-no" title="statement not covered" >r.match;<span class="cstat-no" title="statement not covered" ></span>if(o.matchType(t)){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >r;</span>s.type;s=s.via)<span class="cstat-no" title="statement not covered" >i.push(s.type);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i.reverse()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.next.length;a+=2){var c=<span class="cstat-no" title="statement not covered" >o.next[a];<span class="cstat-no" title="statement not covered" ></span>c.isLeaf||c.hasRequiredAttrs()||c.name in e||r.type&amp;&amp;!o.next[a+1].validEnd||(n.push({match:c.contentMatch,type:c,via:r}),e[c.name]=!0)}</span>}</span>}</span>,sr.edgeCount.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.next.length&gt;&gt;1}</span>,ir.prototype.edge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t&lt;&lt;1;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;=this.next.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("There's no "+t+"th edge in this content match");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{type:this.next[e],next:this.next[e+1]}}</span>,ir.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >e(</span>n){<span class="cstat-no" title="statement not covered" >t.push(n);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;n.next.length;r+=2)<span class="cstat-no" title="statement not covered" >-1==t.indexOf(n.next[r])&amp;&amp;e(n.next[r])}<span class="cstat-no" title="statement not covered" ></span></span>return e(this),t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >n+(e.validEnd?"*":" ")+" ",</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.next.length;o+=2)<span class="cstat-no" title="statement not covered" >r+=(o?", ":"")+e.next[o].name+"-&gt;"+t.indexOf(e.next[o+1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>)).join("\n")}</span>,Object.defineProperties(ir.prototype,sr),ir.empty=new ir(!0);v</span>ar ar=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.string=t,this.nodeTypes=e,this.inline=null,this.pos=0,this.tokens=t.split(/\s*(?=\b|\W|$)/),""==this.tokens[this.tokens.length-1]&amp;&amp;this.tokens.pop(),""==this.tokens[0]&amp;&amp;this.tokens.shift()}</span>,</span>cr=<span class="cstat-no" title="statement not covered" >{next:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >lr(</span>t){var e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >e.push(pr(t))}</span>while(t.eat("|"));<span class="cstat-no" title="statement not covered" >r</span>eturn 1==e.length?e[0]:{type:"choice",exprs:e}}</span>function <span class="fstat-no" title="function not covered" >pr(</span>t){var e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >e.push(ur(t))}</span>while(t.next&amp;&amp;")"!=t.next&amp;&amp;"|"!=t.next);<span class="cstat-no" title="statement not covered" >r</span>eturn 1==e.length?e[0]:{type:"seq",exprs:e}}</span>function <span class="fstat-no" title="function not covered" >ur(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >mr(t);</span>;)<span class="cstat-no" title="statement not covered" >if(t.eat("+"))<span class="cstat-no" title="statement not covered" >e={type:"plus",expr:e};e</span>lse <span class="cstat-no" title="statement not covered" >if(t.eat("*"))<span class="cstat-no" title="statement not covered" >e={type:"star",expr:e};e</span>lse <span class="cstat-no" title="statement not covered" >if(t.eat("?"))<span class="cstat-no" title="statement not covered" >e={type:"opt",expr:e};e</span>lse{<span class="cstat-no" title="statement not covered" >if(!t.eat("{"))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >e</span></span>=dr(t,e)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >hr(</span>t){<span class="cstat-no" title="statement not covered" >/\D/.test(t.next)&amp;&amp;t.err("Expected number, got '"+t.next+"'");v</span>ar e=<span class="cstat-no" title="statement not covered" >Number(t.next);<span class="cstat-no" title="statement not covered" ></span>return t.pos++,e}</span>function <span class="fstat-no" title="function not covered" >dr(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >hr(t),</span>r=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>return t.eat(",")&amp;&amp;(r="}"!=t.next?hr(t):-1),t.eat("}")||t.err("Unclosed braced range"),{type:"range",min:n,max:r,expr:e}}</span>function <span class="fstat-no" title="function not covered" >fr(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.nodeTypes,</span>r=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return[r];v</span></span>ar o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var i in n){var s=<span class="cstat-no" title="statement not covered" >n[i];<span class="cstat-no" title="statement not covered" ></span>s.groups.indexOf(e)&gt;-1&amp;&amp;o.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0==o.length&amp;&amp;t.err("No node type or group '"+e+"' found"),o}</span>function <span class="fstat-no" title="function not covered" >mr(</span>t){<span class="cstat-no" title="statement not covered" >if(t.eat("(")){var e=<span class="cstat-no" title="statement not covered" >lr(t);<span class="cstat-no" title="statement not covered" ></span>return t.eat(")")||t.err("Missing closing paren"),e}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!/\W/.test(t.next)){var n=<span class="cstat-no" title="statement not covered" >fr(t,t.next).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null==t.inline?t.inline=e.isInline:t.inline!=e.isInline&amp;&amp;t.err("Mixing inline and block content"),{type:"name",value:e}}</span>));<span class="cstat-no" title="statement not covered" ></span>return t.pos++,1==n.length?n[0]:{type:"choice",exprs:n}}<span class="cstat-no" title="statement not covered" ></span>t</span>.err("Unexpected token '"+t.next+"'")}</span>function <span class="fstat-no" title="function not covered" >vr(</span>t){var e=<span class="cstat-no" title="statement not covered" >[[]];<span class="cstat-no" title="statement not covered" ></span>return o(i(t,0),n()),e;f</span>unction <span class="fstat-no" title="function not covered" >n(</span>){<span class="cstat-no" title="statement not covered" >return e.push([])-1}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,n,r){var o=<span class="cstat-no" title="statement not covered" >{term:r,to:n};<span class="cstat-no" title="statement not covered" ></span>return e[t].push(o),o}</span>function <span class="fstat-no" title="function not covered" >o(</span>t,e){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.to=e}</span>))}</span>function <span class="fstat-no" title="function not covered" >i(</span>t,e){<span class="cstat-no" title="statement not covered" >if("choice"==t.type)<span class="cstat-no" title="statement not covered" >return t.exprs.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t.concat(i(n,e))}</span>),[]);<span class="cstat-no" title="statement not covered" >i</span></span>f("seq"==t.type)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>;s++){var a=<span class="cstat-no" title="statement not covered" >i(t.exprs[s],e);<span class="cstat-no" title="statement not covered" ></span>if(s==t.exprs.length-1)<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >o</span></span>(a,e=n())}</span>e</span>lse{<span class="cstat-no" title="statement not covered" >if("star"==t.type){var c=<span class="cstat-no" title="statement not covered" >n();<span class="cstat-no" title="statement not covered" ></span>return r(e,c),o(i(t.expr,c),c),[r(c)]}<span class="cstat-no" title="statement not covered" ></span>i</span>f("plus"==t.type){var l=<span class="cstat-no" title="statement not covered" >n();<span class="cstat-no" title="statement not covered" ></span>return o(i(t.expr,e),l),o(i(t.expr,l),l),[r(l)]}<span class="cstat-no" title="statement not covered" ></span>i</span>f("opt"==t.type)<span class="cstat-no" title="statement not covered" >return[r(e)].concat(i(t.expr,e));<span class="cstat-no" title="statement not covered" >i</span></span>f("range"==t.type){<span class="cstat-no" title="statement not covered" >for(var p=<span class="cstat-no" title="statement not covered" >e,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;t.min;u++){var h=<span class="cstat-no" title="statement not covered" >n();<span class="cstat-no" title="statement not covered" ></span>o(i(t.expr,p),h),p=h}<span class="cstat-no" title="statement not covered" ></span>i</span>f(-1==t.max)<span class="cstat-no" title="statement not covered" >o(i(t.expr,p),p);e</span>lse <span class="cstat-no" title="statement not covered" >for(var d=<span class="cstat-no" title="statement not covered" >t.min;</span>d&lt;t.max;d++){var f=<span class="cstat-no" title="statement not covered" >n();<span class="cstat-no" title="statement not covered" ></span>r(p,f),o(i(t.expr,p),f),p=f}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn[r(p)]}<span class="cstat-no" title="statement not covered" ></span>i</span>f("name"==t.type)<span class="cstat-no" title="statement not covered" >return[r(e,null,t.value)]}</span></span>}</span>}function <span class="fstat-no" title="function not covered" >gr(</span>t,e){<span class="cstat-no" title="statement not covered" >return e-t}</span>function <span class="fstat-no" title="function not covered" >yr(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return r(e),n.sort(gr);f</span>unction <span class="fstat-no" title="function not covered" >r(</span>e){var o=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>if(1==o.length&amp;&amp;!o[0].term)<span class="cstat-no" title="statement not covered" >return r(o[0].to);<span class="cstat-no" title="statement not covered" >n</span></span>.push(e);<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;o.length;i++){var s=<span class="cstat-no" title="statement not covered" >o[i],</span>a=<span class="cstat-no" title="statement not covered" >s.term,</span>c=<span class="cstat-no" title="statement not covered" >s.to;<span class="cstat-no" title="statement not covered" ></span>a||-1!=n.indexOf(c)||r(c)}</span>}</span>}function <span class="fstat-no" title="function not covered" >br(</span>t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>return n(yr(t,0));f</span>unction <span class="fstat-no" title="function not covered" >n(</span>r){var o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t[e].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.term,</span>r=<span class="cstat-no" title="statement not covered" >e.to;<span class="cstat-no" title="statement not covered" ></span>if(n){var i=<span class="cstat-no" title="statement not covered" >o.indexOf(n),</span>s=<span class="cstat-no" title="statement not covered" >i&gt;-1&amp;&amp;o[i+1];<span class="cstat-no" title="statement not covered" ></span>yr(t,r).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >s||o.push(n,s=[]),-1==s.indexOf(t)&amp;&amp;s.push(t)}</span>))}</span>}</span>))}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >e[r.join(",")]=new ir(r.indexOf(t.length-1)&gt;-1),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;o.length;s+=2){var a=<span class="cstat-no" title="statement not covered" >o[s+1].sort(gr);<span class="cstat-no" title="statement not covered" ></span>i.next.push(o[s],e[a.join(",")]||n(a))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>}function <span class="fstat-no" title="function not covered" >wr(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >[t];</span>n&lt;r.length;n++){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >r[n],</span>i=<span class="cstat-no" title="statement not covered" >!o.validEnd,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.next.length;a+=2){var c=<span class="cstat-no" title="statement not covered" >o.next[a],</span>l=<span class="cstat-no" title="statement not covered" >o.next[a+1];<span class="cstat-no" title="statement not covered" ></span>s.push(c.name),!i||c.isText||c.hasRequiredAttrs()||(i=!1),-1==r.indexOf(l)&amp;&amp;r.push(l)}<span class="cstat-no" title="statement not covered" ></span>i</span>&amp;&amp;e.err("Only non-generatable nodes ("+s.join(", ")+") in a required position (see https://prosemirror.net/docs/guide/#generatable)")}</span>}</span>function <span class="fstat-no" title="function not covered" >Or(</span>t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>for(var n in t){var r=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>if(!r.hasDefault)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >e</span></span>[n]=r.default}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >kr(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>for(var r in t){var o=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e[r];<span class="cstat-no" title="statement not covered" ></span>if(void 0===o){var i=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>if(!i.hasDefault)<span class="cstat-no" title="statement not covered" >throw new RangeError("No value supplied for attribute "+r);<span class="cstat-no" title="statement not covered" >o</span></span>=i.default}<span class="cstat-no" title="statement not covered" ></span>n</span>[r]=o}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >xr(</span>t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >e[n]=new Cr(t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>cr.next.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.tokens[this.pos]}</span>,ar.prototype.eat=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.next==t&amp;&amp;(this.pos++||!0)}</span>,ar.prototype.err=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >throw new SyntaxError(t+" (in content expression '"+this.string+"')")}</span>,Object.defineProperties(ar.prototype,cr);v</span>ar Sr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.name=t,this.schema=e,this.spec=n,this.groups=n.group?n.group.split(" "):[],this.attrs=xr(n.attrs),this.defaultAttrs=Or(this.attrs),this.contentMatch=null,this.markSet=null,this.inlineContent=null,this.isBlock=!(n.inline||"text"==t),this.isText="text"==t}</span>,</span>Mr=<span class="cstat-no" title="statement not covered" >{isInline:{configurable:!0},isTextblock:{configurable:!0},isLeaf:{configurable:!0},isAtom:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>Mr.isInline.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!this.isBlock}</span>,Mr.isTextblock.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isBlock&amp;&amp;this.inlineContent}</span>,Mr.isLeaf.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.contentMatch==ir.empty}</span>,Mr.isAtom.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isLeaf||this.spec.atom}</span>,Sr.prototype.hasRequiredAttrs=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in this.attrs)<span class="cstat-no" title="statement not covered" >if(this.attrs[t].isRequired)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>,Sr.prototype.compatibleContent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this==t||this.contentMatch.compatible(t.contentMatch)}</span>,Sr.prototype.computeAttrs=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!t&amp;&amp;this.defaultAttrs?this.defaultAttrs:kr(this.attrs,t)}</span>,Sr.prototype.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(this.isText)<span class="cstat-no" title="statement not covered" >throw new Error("NodeType.create can't construct text nodes");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new er(this,this.computeAttrs(t),Cn.from(e),An.setFrom(n))}</span>,Sr.prototype.createChecked=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(e=Cn.from(e),!this.validContent(e))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid content for node "+this.name);<span class="cstat-no" title="statement not covered" >r</span></span>eturn new er(this,this.computeAttrs(t),e,An.setFrom(n))}</span>,Sr.prototype.createAndFill=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(t=this.computeAttrs(t),e=Cn.from(e),e.size){var r=<span class="cstat-no" title="statement not covered" >this.contentMatch.fillBefore(e);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >e</span></span>=r.append(e)}</span>v</span>ar o=<span class="cstat-no" title="statement not covered" >this.contentMatch.matchFragment(e).fillBefore(Cn.empty,!0);<span class="cstat-no" title="statement not covered" ></span>return o?new er(this,t,e.append(o),An.setFrom(n)):null}</span>,Sr.prototype.validContent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.contentMatch.matchFragment(t);<span class="cstat-no" title="statement not covered" ></span>if(!e||!e.validEnd)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.childCount;n++)<span class="cstat-no" title="statement not covered" >if(!this.allowsMarks(t.child(n).marks))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,Sr.prototype.allowsMarkType=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==this.markSet||this.markSet.indexOf(t)&gt;-1}</span>,Sr.prototype.allowsMarks=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(null==this.markSet)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(!this.allowsMarkType(t[e].type))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,Sr.prototype.allowedMarks=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(null==this.markSet)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e,n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >this.allowsMarkType(t[n].type)?e&amp;&amp;e.push(t[n]):e||(e=t.slice(0,n));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e?e.length?e:An.empty:t}</span>,Sr.compile=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >return n[t]=new Sr(t,e,r)}</span>));v</span>ar r=<span class="cstat-no" title="statement not covered" >e.spec.topNode||"doc";<span class="cstat-no" title="statement not covered" ></span>if(!n[r])<span class="cstat-no" title="statement not covered" >throw new RangeError("Schema is missing its top node type ('"+r+"')");<span class="cstat-no" title="statement not covered" >i</span></span>f(!n.text)<span class="cstat-no" title="statement not covered" >throw new RangeError("Every schema needs a 'text' type");<span class="cstat-no" title="statement not covered" >f</span></span>or(var o in n.text.attrs)<span class="cstat-no" title="statement not covered" >throw new RangeError("The text node type should not have attributes");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,Object.defineProperties(Sr.prototype,Mr);v</span>ar Cr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.hasDefault=Object.prototype.hasOwnProperty.call(t,"default"),this.default=t.default}</span>,</span>Er=<span class="cstat-no" title="statement not covered" >{isRequired:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>Er.isRequired.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!this.hasDefault}</span>,Object.defineProperties(Cr.prototype,Er);v</span>ar Tr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.name=t,this.schema=n,this.spec=r,this.attrs=xr(r.attrs),this.rank=e,this.excluded=null;v</span>ar o=<span class="cstat-no" title="statement not covered" >Or(this.attrs);<span class="cstat-no" title="statement not covered" ></span>this.instance=o&amp;&amp;new An(this,o)}</span>;<span class="cstat-no" title="statement not covered" ></span>Tr.prototype.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!t&amp;&amp;this.instance?this.instance:new An(this,kr(this.attrs,t))}</span>,Tr.compile=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,o){<span class="cstat-no" title="statement not covered" >return n[t]=new Tr(t,r++,e,o)}</span>)),n}</span>,Tr.prototype.removeFromSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >t[e].type==this&amp;&amp;(t=t.slice(0,e).concat(t.slice(e+1)),e--);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,Tr.prototype.isInSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(t[e].type==this)<span class="cstat-no" title="statement not covered" >return t[e]}</span></span></span>,Tr.prototype.excludes=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.excluded.indexOf(t)&gt;-1}</span>;v</span>ar Nr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e in this.spec={},t)<span class="cstat-no" title="statement not covered" >this.spec[e]=t[e];<span class="cstat-no" title="statement not covered" >t</span></span>his.spec.nodes=xn.from(t.nodes),this.spec.marks=xn.from(t.marks),this.nodes=Sr.compile(this.spec.nodes,this),this.marks=Tr.compile(this.spec.marks,this);v</span>ar n=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>for(var r in this.nodes){<span class="cstat-no" title="statement not covered" >if(r in this.marks)<span class="cstat-no" title="statement not covered" >throw new RangeError(r+" can not be both a node and a mark");v</span></span>ar o=<span class="cstat-no" title="statement not covered" >this.nodes[r],</span>i=<span class="cstat-no" title="statement not covered" >o.spec.content||"",</span>s=<span class="cstat-no" title="statement not covered" >o.spec.marks;<span class="cstat-no" title="statement not covered" ></span>o.contentMatch=n[i]||(n[i]=ir.parse(i,this.nodes)),o.inlineContent=o.contentMatch.inlineContent,o.markSet="_"==s?null:s?jr(this,s.split(" ")):""!=s&amp;&amp;o.inlineContent?null:[]}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var a in this.marks){var c=<span class="cstat-no" title="statement not covered" >this.marks[a],</span>l=<span class="cstat-no" title="statement not covered" >c.spec.excludes;<span class="cstat-no" title="statement not covered" ></span>c.excluded=null==l?[c]:""==l?[]:jr(this,l.split(" "))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.nodeFromJSON=this.nodeFromJSON.bind(this),this.markFromJSON=this.markFromJSON.bind(this),this.topNodeType=this.nodes[this.spec.topNode||"doc"],this.cached=Object.create(null),this.cached.wrappings=Object.create(null)}</span>;</span>function <span class="fstat-no" title="function not covered" >jr(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.length;r++){var o=<span class="cstat-no" title="statement not covered" >e[r],</span>i=<span class="cstat-no" title="statement not covered" >t.marks[o],</span>s=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >n.push(i);e</span>lse <span class="cstat-no" title="statement not covered" >for(var a in t.marks){var c=<span class="cstat-no" title="statement not covered" >t.marks[a];<span class="cstat-no" title="statement not covered" ></span>("_"==o||c.spec.group&amp;&amp;c.spec.group.split(" ").indexOf(o)&gt;-1)&amp;&amp;n.push(s=c)}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(!s)<span class="cstat-no" title="statement not covered" >throw new SyntaxError("Unknown mark type: '"+e[r]+"'")}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn n}<span class="cstat-no" title="statement not covered" ></span>Nr.prototype.node=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >if("string"==typeof t)<span class="cstat-no" title="statement not covered" >t=this.nodeType(t);e</span>lse{<span class="cstat-no" title="statement not covered" >if(!(t instanceof Sr))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid node type: "+t);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.schema!=this)<span class="cstat-no" title="statement not covered" >throw new RangeError("Node type from different schema used ("+t.name+")")}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t.createChecked(e,n,r)}</span>,Nr.prototype.text=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this.nodes.text;<span class="cstat-no" title="statement not covered" ></span>return new rr(n,n.defaultAttrs,t,An.setFrom(e))}</span>,Nr.prototype.mark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return"string"==typeof t&amp;&amp;(t=this.marks[t]),t.create(e)}</span>,Nr.prototype.nodeFromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return er.fromJSON(this,t)}</span>,Nr.prototype.markFromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return An.fromJSON(this,t)}</span>,Nr.prototype.nodeType=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.nodes[t];<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >throw new RangeError("Unknown node type: "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>;v</span>ar Ar=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.schema=t,this.rules=e,this.tags=[],this.styles=[],e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.tag?n.tags.push(t):t.style&amp;&amp;n.styles.push(t)}</span>)),this.normalizeLists=!this.tags.some((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!/^(ul|ol)\b/.test(e.tag)||!e.node)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.nodes[e.node];<span class="cstat-no" title="statement not covered" ></span>return n.contentMatch.matchType(n)}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>Ar.prototype.parse=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e={});v</span>ar n=<span class="cstat-no" title="statement not covered" >new Vr(this,e,!1);<span class="cstat-no" title="statement not covered" ></span>return n.addAll(t,null,e.from,e.to),n.finish()}</span>,Ar.prototype.parseSlice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e={});v</span>ar n=<span class="cstat-no" title="statement not covered" >new Vr(this,e,!0);<span class="cstat-no" title="statement not covered" ></span>return n.addAll(t,null,e.from,e.to),Dn.maxOpen(n.finish())}</span>,Ar.prototype.matchTag=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >n?this.tags.indexOf(n)+1:0;</span>r&lt;this.tags.length;r++){var o=<span class="cstat-no" title="statement not covered" >this.tags[r];<span class="cstat-no" title="statement not covered" ></span>if(Hr(t,o.tag)&amp;&amp;(void 0===o.namespace||t.namespaceURI==o.namespace)&amp;&amp;(!o.context||e.matchesContext(o.context))){<span class="cstat-no" title="statement not covered" >if(o.getAttrs){var i=<span class="cstat-no" title="statement not covered" >o.getAttrs(t);<span class="cstat-no" title="statement not covered" ></span>if(!1===i)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >o</span></span>.attrs=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>}</span>}</span>,Ar.prototype.matchStyle=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >r?this.styles.indexOf(r)+1:0;</span>o&lt;this.styles.length;o++){var i=<span class="cstat-no" title="statement not covered" >this.styles[o];<span class="cstat-no" title="statement not covered" ></span>if(!(0!=i.style.indexOf(t)||i.context&amp;&amp;!n.matchesContext(i.context)||i.style.length&gt;t.length&amp;&amp;(61!=i.style.charCodeAt(t.length)||i.style.slice(t.length+1)!=e))){<span class="cstat-no" title="statement not covered" >if(i.getAttrs){var s=<span class="cstat-no" title="statement not covered" >i.getAttrs(e);<span class="cstat-no" title="statement not covered" ></span>if(!1===s)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>.attrs=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>}</span>}</span>,Ar.schemaRules=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >n(</span>t){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >null==t.priority?50:t.priority,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.length;r++){var o=<span class="cstat-no" title="statement not covered" >e[r],</span>i=<span class="cstat-no" title="statement not covered" >null==o.priority?50:o.priority;<span class="cstat-no" title="statement not covered" ></span>if(i&lt;n)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>e</span>.splice(r,0,t)}</span>var r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >t.marks[e].spec.parseDOM;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n(t=Jr(t)),t.mark=e}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>for(var o in t.marks)<span class="cstat-no" title="statement not covered" >r(o);v</span></span>ar i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >t.nodes[s].spec.parseDOM;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n(t=Jr(t)),t.node=s}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>for(var s in t.nodes)<span class="cstat-no" title="statement not covered" >i();<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,Ar.fromSchema=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.cached.domParser||(t.cached.domParser=new Ar(t,Ar.schemaRules(t)))}</span>;v</span>ar Ir=<span class="cstat-no" title="statement not covered" >{address:!0,article:!0,aside:!0,blockquote:!0,canvas:!0,dd:!0,div:!0,dl:!0,fieldset:!0,figcaption:!0,figure:!0,footer:!0,form:!0,h1:!0,h2:!0,h3:!0,h4:!0,h5:!0,h6:!0,header:!0,hgroup:!0,hr:!0,li:!0,noscript:!0,ol:!0,output:!0,p:!0,pre:!0,section:!0,table:!0,tfoot:!0,ul:!0},</span>Dr=<span class="cstat-no" title="statement not covered" >{head:!0,noscript:!0,object:!0,script:!0,style:!0,title:!0},</span>Rr=<span class="cstat-no" title="statement not covered" >{ol:!0,ul:!0},</span>_r=<span class="cstat-no" title="statement not covered" >1,</span>Pr=<span class="cstat-no" title="statement not covered" >2,</span>zr=<span class="cstat-no" title="statement not covered" >4;</span>function <span class="fstat-no" title="function not covered" >Br(</span>t){<span class="cstat-no" title="statement not covered" >return(t?_r:0)|("full"===t?Pr:0)}</span>var Lr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o,i,s){<span class="cstat-no" title="statement not covered" >this.type=t,this.attrs=e,this.solid=o,this.match=i||(s&amp;zr?null:t.contentMatch),this.options=s,this.content=[],this.marks=n,this.activeMarks=An.none,this.pendingMarks=r,this.stashMarks=[]}</span>;<span class="cstat-no" title="statement not covered" ></span>Lr.prototype.findWrapping=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!this.match){<span class="cstat-no" title="statement not covered" >if(!this.type)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.type.contentMatch.fillBefore(Cn.from(t));<span class="cstat-no" title="statement not covered" ></span>if(!e){var n,r=<span class="cstat-no" title="statement not covered" >this.type.contentMatch;<span class="cstat-no" title="statement not covered" ></span>return(n=r.findWrapping(t.type))?(this.match=r,n):null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.match=this.type.contentMatch.matchFragment(e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.match.findWrapping(t.type)}</span>,Lr.prototype.finish=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!(this.options&amp;_r)){var e,n=<span class="cstat-no" title="statement not covered" >this.content[this.content.length-1];<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.isText&amp;&amp;(e=/[ \t\r\n\u000c]+$/.exec(n.text))&amp;&amp;(n.text.length==e[0].length?this.content.pop():this.content[this.content.length-1]=n.withText(n.text.slice(0,n.text.length-e[0].length)))}</span>v</span>ar r=<span class="cstat-no" title="statement not covered" >Cn.from(this.content);<span class="cstat-no" title="statement not covered" ></span>return!t&amp;&amp;this.match&amp;&amp;(r=r.append(this.match.fillBefore(Cn.empty,!0))),this.type?this.type.create(this.attrs,r,this.marks):r}</span>,Lr.prototype.popFromStashMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.stashMarks.length-1;</span>e&gt;=0;e--)<span class="cstat-no" title="statement not covered" >if(t.eq(this.stashMarks[e]))<span class="cstat-no" title="statement not covered" >return this.stashMarks.splice(e,1)[0]}</span></span></span>,Lr.prototype.applyPending=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >this.pendingMarks;</span>e&lt;n.length;e++){var r=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>(this.type?this.type.allowsMarkType(r.type):Wr(r.type,t))&amp;&amp;!r.isInSet(this.activeMarks)&amp;&amp;(this.activeMarks=r.addToSet(this.activeMarks),this.pendingMarks=r.removeFromSet(this.pendingMarks))}</span>}</span>,Lr.prototype.inlineContext=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:t.parentNode&amp;&amp;!Ir.hasOwnProperty(t.parentNode.nodeName.toLowerCase())}</span>;v</span>ar Vr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.parser=t,this.options=e,this.isOpen=n;v</span>ar r,o=<span class="cstat-no" title="statement not covered" >e.topNode,</span>i=<span class="cstat-no" title="statement not covered" >Br(e.preserveWhitespace)|(n?zr:0);<span class="cstat-no" title="statement not covered" ></span>r=o?new Lr(o.type,o.attrs,An.none,An.none,!0,e.topMatch||o.type.contentMatch,i):new Lr(n?null:t.schema.topNodeType,null,An.none,An.none,!0,null,i),this.nodes=[r],this.open=0,this.find=e.findPositions,this.needsBlock=!1}</span>,</span>$r=<span class="cstat-no" title="statement not covered" >{top:{configurable:!0},currentPos:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >Fr(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.firstChild,</span>n=<span class="cstat-no" title="statement not covered" >null;</span>e;e=e.nextSibling){var r=<span class="cstat-no" title="statement not covered" >1==e.nodeType?e.nodeName.toLowerCase():null;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;Rr.hasOwnProperty(r)&amp;&amp;n?(n.appendChild(e),e=n):"li"==r?n=e:r&amp;&amp;(n=null)}</span>}</span>function <span class="fstat-no" title="function not covered" >Hr(</span>t,e){<span class="cstat-no" title="statement not covered" >return(t.matches||t.msMatchesSelector||t.webkitMatchesSelector||t.mozMatchesSelector).call(t,e)}</span>function <span class="fstat-no" title="function not covered" >qr(</span>t){var e,n=<span class="cstat-no" title="statement not covered" >/\s*([\w-]+)\s*:\s*([^;]+)/g,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>while(e=n.exec(t))<span class="cstat-no" title="statement not covered" >r.push(e[1],e[2].trim());<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Jr(</span>t){var e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var n in t)<span class="cstat-no" title="statement not covered" >e[n]=t[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Wr(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >e.schema.nodes,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(r){var o=<span class="cstat-no" title="statement not covered" >n[r];<span class="cstat-no" title="statement not covered" ></span>if(o.allowsMarkType(t)){var i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.push(t);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.edgeCount;n++){var r=<span class="cstat-no" title="statement not covered" >t.edge(n),</span>o=<span class="cstat-no" title="statement not covered" >r.type,</span>a=<span class="cstat-no" title="statement not covered" >r.next;<span class="cstat-no" title="statement not covered" ></span>if(o==e)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(i.indexOf(a)&lt;0&amp;&amp;s(a))<span class="cstat-no" title="statement not covered" >return!0}</span></span>}</span>;<span class="cstat-no" title="statement not covered" ></span>return s(o.contentMatch)?{v:!0}:void 0}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>for(var o in n){var i=<span class="cstat-no" title="statement not covered" >r(o);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i.v}</span></span>}</span>function <span class="fstat-no" title="function not covered" >Kr(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >if(t.eq(e[n]))<span class="cstat-no" title="statement not covered" >return e[n]}<span class="cstat-no" title="statement not covered" ></span></span></span>$r.top.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.nodes[this.open]}</span>,Vr.prototype.addDOM=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(3==t.nodeType)<span class="cstat-no" title="statement not covered" >this.addTextNode(t);e</span>lse <span class="cstat-no" title="statement not covered" >if(1==t.nodeType){var e=<span class="cstat-no" title="statement not covered" >t.getAttribute("style"),</span>n=<span class="cstat-no" title="statement not covered" >e?this.readStyles(qr(e)):null,</span>r=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>if(null!=n)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n.length;o++)<span class="cstat-no" title="statement not covered" >this.addPendingMark(n[o]);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(this.addElement(t),null!=n)<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;n.length;i++)<span class="cstat-no" title="statement not covered" >this.removePendingMark(n[i],r)}</span></span></span>}</span></span>,Vr.prototype.addTextNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.nodeValue,</span>n=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>if(n.options&amp;Pr||n.inlineContext(t)||/[^ \t\r\n\u000c]/.test(e)){<span class="cstat-no" title="statement not covered" >if(n.options&amp;_r)<span class="cstat-no" title="statement not covered" >e=n.options&amp;Pr?e.replace(/\r\n?/g,"\n"):e.replace(/\r?\n|\r/g," ");e</span>lse <span class="cstat-no" title="statement not covered" >if(e=e.replace(/[ \t\r\n\u000c]+/g," "),/^[ \t\r\n\u000c]/.test(e)&amp;&amp;this.open==this.nodes.length-1){var r=<span class="cstat-no" title="statement not covered" >n.content[n.content.length-1],</span>o=<span class="cstat-no" title="statement not covered" >t.previousSibling;<span class="cstat-no" title="statement not covered" ></span>(!r||o&amp;&amp;"BR"==o.nodeName||r.isText&amp;&amp;/[ \t\r\n\u000c]$/.test(r.text))&amp;&amp;(e=e.slice(1))}<span class="cstat-no" title="statement not covered" ></span>e</span></span>&amp;&amp;this.insertNode(this.parser.schema.text(e)),this.findInText(t)}</span>else <span class="cstat-no" title="statement not covered" >this.findInside(t)}</span></span>,Vr.prototype.addElement=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n,r=<span class="cstat-no" title="statement not covered" >t.nodeName.toLowerCase();<span class="cstat-no" title="statement not covered" ></span>Rr.hasOwnProperty(r)&amp;&amp;this.parser.normalizeLists&amp;&amp;Fr(t);v</span>ar o=<span class="cstat-no" title="statement not covered" >this.options.ruleFromNode&amp;&amp;this.options.ruleFromNode(t)||(n=this.parser.matchTag(t,this,e));<span class="cstat-no" title="statement not covered" ></span>if(o?o.ignore:Dr.hasOwnProperty(r))<span class="cstat-no" title="statement not covered" >this.findInside(t),this.ignoreFallback(t);e</span>lse <span class="cstat-no" title="statement not covered" >if(!o||o.skip||o.closeParent){<span class="cstat-no" title="statement not covered" >o&amp;&amp;o.closeParent?this.open=Math.max(0,this.open-1):o&amp;&amp;o.skip.nodeType&amp;&amp;(t=o.skip);v</span>ar i,s=<span class="cstat-no" title="statement not covered" >this.top,</span>a=<span class="cstat-no" title="statement not covered" >this.needsBlock;<span class="cstat-no" title="statement not covered" ></span>if(Ir.hasOwnProperty(r))<span class="cstat-no" title="statement not covered" >i=!0,s.type||(this.needsBlock=!0);e</span>lse <span class="cstat-no" title="statement not covered" >if(!t.firstChild)<span class="cstat-no" title="statement not covered" >return void this.leafFallback(t);<span class="cstat-no" title="statement not covered" >t</span></span></span>his.addAll(t),i&amp;&amp;this.sync(s),this.needsBlock=a}</span>else <span class="cstat-no" title="statement not covered" >this.addElementByRule(t,o,!1===o.consuming?n:null)}</span></span></span>,Vr.prototype.leafFallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"BR"==t.nodeName&amp;&amp;this.top.type&amp;&amp;this.top.type.inlineContent&amp;&amp;this.addTextNode(t.ownerDocument.createTextNode("\n"))}</span>,Vr.prototype.ignoreFallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"BR"!=t.nodeName||this.top.type&amp;&amp;this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"))}</span>,Vr.prototype.readStyles=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >An.none;<span class="cstat-no" title="statement not covered" ></span>t:<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n+=2)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >null;</span>;){var o=<span class="cstat-no" title="statement not covered" >this.parser.matchStyle(t[n],t[n+1],this,r);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >continue t;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.ignore)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(e=this.parser.schema.marks[o.mark].create(o.attrs).addToSet(e),!1!==o.consuming)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span>=o}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn e}</span>,Vr.prototype.addElementByRule=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r,o,i,s,a=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e.node?(o=this.parser.schema.nodes[e.node],o.isLeaf?this.insertNode(o.create(e.attrs))||this.leafFallback(t):r=this.enter(o,e.attrs,e.preserveWhitespace)):(i=this.parser.schema.marks[e.mark],s=i.create(e.attrs),this.addPendingMark(s));v</span>ar c=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;o.isLeaf)<span class="cstat-no" title="statement not covered" >this.findInside(t);e</span>lse <span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >this.addElement(t,n);e</span>lse <span class="cstat-no" title="statement not covered" >if(e.getContent)<span class="cstat-no" title="statement not covered" >this.findInside(t),e.getContent(t,this.parser.schema).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a.insertNode(t)}</span>));e</span>lse{var l=<span class="cstat-no" title="statement not covered" >e.contentElement;<span class="cstat-no" title="statement not covered" ></span>"string"==typeof l?l=t.querySelector(l):"function"==typeof l&amp;&amp;(l=l(t)),l||(l=t),this.findAround(t,l,!0),this.addAll(l,r)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>&amp;&amp;(this.sync(c),this.open--),s&amp;&amp;this.removePendingMark(s,c)}</span>,Vr.prototype.addAll=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >n||0,</span>i=<span class="cstat-no" title="statement not covered" >n?t.childNodes[n]:t.firstChild,</span>s=<span class="cstat-no" title="statement not covered" >null==r?null:t.childNodes[r];</span>i!=s;i=i.nextSibling,++o)<span class="cstat-no" title="statement not covered" >this.findAtPoint(t,o),this.addDOM(i),e&amp;&amp;Ir.hasOwnProperty(i.nodeName.toLowerCase())&amp;&amp;this.sync(e);<span class="cstat-no" title="statement not covered" >t</span></span>his.findAtPoint(t,o)}</span>,Vr.prototype.findPlace=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e,n,r=<span class="cstat-no" title="statement not covered" >this.open;</span>r&gt;=0;r--){var o=<span class="cstat-no" title="statement not covered" >this.nodes[r],</span>i=<span class="cstat-no" title="statement not covered" >o.findWrapping(t);<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;(!e||e.length&gt;i.length)&amp;&amp;(e=i,n=o,!i.length))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.solid)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(!e)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.sync(n);<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;e.length;s++)<span class="cstat-no" title="statement not covered" >this.enterInner(e[s],null,!1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn!0}</span>,Vr.prototype.insertNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t.isInline&amp;&amp;this.needsBlock&amp;&amp;!this.top.type){var e=<span class="cstat-no" title="statement not covered" >this.textblockFromContext();<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;this.enterInner(e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.findPlace(t)){<span class="cstat-no" title="statement not covered" >this.closeExtra();v</span>ar n=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>n.applyPending(t.type),n.match&amp;&amp;(n.match=n.match.matchType(t.type));<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >n.activeMarks,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t.marks.length;o++)<span class="cstat-no" title="statement not covered" >n.type&amp;&amp;!n.type.allowsMarkType(t.marks[o].type)||(r=t.marks[o].addToSet(r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.content.push(t.mark(r)),!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>,Vr.prototype.enter=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this.findPlace(t.create(e));<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;this.enterInner(t,e,!0,n),r}</span>,Vr.prototype.enterInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.closeExtra();v</span>ar o=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>o.applyPending(t),o.match=o.match&amp;&amp;o.match.matchType(t,e);v</span>ar i=<span class="cstat-no" title="statement not covered" >null==r?o.options&amp;~zr:Br(r);<span class="cstat-no" title="statement not covered" ></span>o.options&amp;zr&amp;&amp;0==o.content.length&amp;&amp;(i|=zr),this.nodes.push(new Lr(t,e,o.activeMarks,o.pendingMarks,n,null,i)),this.open++}</span>,Vr.prototype.closeExtra=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.nodes.length-1;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;this.open){<span class="cstat-no" title="statement not covered" >for(;e&gt;this.open;e--)<span class="cstat-no" title="statement not covered" >this.nodes[e-1].content.push(this.nodes[e].finish(t));<span class="cstat-no" title="statement not covered" >t</span></span>his.nodes.length=this.open+1}</span>}</span>,Vr.prototype.finish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.open=0,this.closeExtra(this.isOpen),this.nodes[0].finish(this.isOpen||this.options.topOpen)}</span>,Vr.prototype.sync=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.open;</span>e&gt;=0;e--)<span class="cstat-no" title="statement not covered" >if(this.nodes[e]==t)<span class="cstat-no" title="statement not covered" >return void(this.open=e)}</span></span></span>,$r.currentPos.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.closeExtra();<span class="cstat-no" title="statement not covered" >f</span>or(var t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >this.open;</span>e&gt;=0;e--){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >this.nodes[e].content,</span>r=<span class="cstat-no" title="statement not covered" >n.length-1;</span>r&gt;=0;r--)<span class="cstat-no" title="statement not covered" >t+=n[r].nodeSize;<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;t++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,Vr.prototype.findAtPoint=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(this.find)<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.find.length;n++)<span class="cstat-no" title="statement not covered" >this.find[n].node==t&amp;&amp;this.find[n].offset==e&amp;&amp;(this.find[n].pos=this.currentPos)}</span></span></span>,Vr.prototype.findInside=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.find)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.find.length;e++)<span class="cstat-no" title="statement not covered" >null==this.find[e].pos&amp;&amp;1==t.nodeType&amp;&amp;t.contains(this.find[e].node)&amp;&amp;(this.find[e].pos=this.currentPos)}</span></span></span>,Vr.prototype.findAround=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(t!=e&amp;&amp;this.find)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.find.length;r++)<span class="cstat-no" title="statement not covered" >if(null==this.find[r].pos&amp;&amp;1==t.nodeType&amp;&amp;t.contains(this.find[r].node)){var o=<span class="cstat-no" title="statement not covered" >e.compareDocumentPosition(this.find[r].node);<span class="cstat-no" title="statement not covered" ></span>o&amp;(n?2:4)&amp;&amp;(this.find[r].pos=this.currentPos)}</span>}</span></span></span>,Vr.prototype.findInText=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.find)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.find.length;e++)<span class="cstat-no" title="statement not covered" >this.find[e].node==t&amp;&amp;(this.find[e].pos=this.currentPos-(t.nodeValue.length-this.find[e].offset))}</span></span></span>,Vr.prototype.matchesContext=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(t.indexOf("|")&gt;-1)<span class="cstat-no" title="statement not covered" >return t.split(/\s*\|\s*/).some(this.matchesContext,this);v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.split("/"),</span>r=<span class="cstat-no" title="statement not covered" >this.options.context,</span>o=<span class="cstat-no" title="statement not covered" >!this.isOpen&amp;&amp;(!r||r.parent.type==this.nodes[0].type),</span>i=<span class="cstat-no" title="statement not covered" >-(r?r.depth+1:0)+(o?0:1),</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,a){<span class="cstat-no" title="statement not covered" >for(;t&gt;=0;t--){var c=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>if(""==c){<span class="cstat-no" title="statement not covered" >if(t==n.length-1||0==t)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>or(;a&gt;=i;a--)<span class="cstat-no" title="statement not covered" >if(s(t-1,a))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>v</span>ar l=<span class="cstat-no" title="statement not covered" >a&gt;0||0==a&amp;&amp;o?e.nodes[a].type:r&amp;&amp;a&gt;=i?r.node(a-i).type:null;<span class="cstat-no" title="statement not covered" ></span>if(!l||l.name!=c&amp;&amp;-1==l.groups.indexOf(c))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >a</span></span>--}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>;<span class="cstat-no" title="statement not covered" ></span>return s(n.length-1,this.open)}</span>,Vr.prototype.textblockFromContext=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.options.context;<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.depth;</span>e&gt;=0;e--){var n=<span class="cstat-no" title="statement not covered" >t.node(e).contentMatchAt(t.indexAfter(e)).defaultType;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;n.isTextblock&amp;&amp;n.defaultAttrs)<span class="cstat-no" title="statement not covered" >return n}<span class="cstat-no" title="statement not covered" ></span></span>f</span></span>or(var r in this.parser.schema.nodes){var o=<span class="cstat-no" title="statement not covered" >this.parser.schema.nodes[r];<span class="cstat-no" title="statement not covered" ></span>if(o.isTextblock&amp;&amp;o.defaultAttrs)<span class="cstat-no" title="statement not covered" >return o}</span></span>}</span>,Vr.prototype.addPendingMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Kr(t,this.top.pendingMarks);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;this.top.stashMarks.push(e),this.top.pendingMarks=t.addToSet(this.top.pendingMarks)}</span>,Vr.prototype.removePendingMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >this.open;</span>n&gt;=0;n--){var r=<span class="cstat-no" title="statement not covered" >this.nodes[n],</span>o=<span class="cstat-no" title="statement not covered" >r.pendingMarks.lastIndexOf(t);<span class="cstat-no" title="statement not covered" ></span>if(o&gt;-1)<span class="cstat-no" title="statement not covered" >r.pendingMarks=t.removeFromSet(r.pendingMarks);e</span>lse{<span class="cstat-no" title="statement not covered" >r.activeMarks=t.removeFromSet(r.activeMarks);v</span>ar i=<span class="cstat-no" title="statement not covered" >r.popFromStashMark(t);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;r.type&amp;&amp;r.type.allowsMarkType(i.type)&amp;&amp;(r.activeMarks=i.addToSet(r.activeMarks))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r==e)<span class="cstat-no" title="statement not covered" >break}</span></span>}</span>,Object.defineProperties(Vr.prototype,$r);v</span>ar Ur=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.nodes=t||{},this.marks=e||{}}</span>;</span>function <span class="fstat-no" title="function not covered" >Gr(</span>t){var e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var n in t){var r=<span class="cstat-no" title="statement not covered" >t[n].spec.toDOM;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(e[n]=r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Yr(</span>t){<span class="cstat-no" title="statement not covered" >return t.document||window.document}<span class="cstat-no" title="statement not covered" ></span>Ur.prototype.serializeFragment=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>void 0===e&amp;&amp;(e={}),n||(n=Yr(e).createDocumentFragment());v</span>ar o=<span class="cstat-no" title="statement not covered" >n,</span>i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(i||t.marks.length){<span class="cstat-no" title="statement not covered" >i||(i=[]);v</span>ar n=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(n&lt;i.length&amp;&amp;s&lt;t.marks.length){var a=<span class="cstat-no" title="statement not covered" >t.marks[s];<span class="cstat-no" title="statement not covered" ></span>if(r.marks[a.type.name]){<span class="cstat-no" title="statement not covered" >if(!a.eq(i[n])||!1===a.type.spec.spanning)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>+=2,s++}</span>else <span class="cstat-no" title="statement not covered" >s++}<span class="cstat-no" title="statement not covered" ></span></span>w</span>hile(n&lt;i.length)<span class="cstat-no" title="statement not covered" >o=i.pop(),i.pop();<span class="cstat-no" title="statement not covered" >w</span></span>hile(s&lt;t.marks.length){var c=<span class="cstat-no" title="statement not covered" >t.marks[s++],</span>l=<span class="cstat-no" title="statement not covered" >r.serializeMark(c,t.isInline,e);<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;(i.push(c,o),o.appendChild(l.dom),o=l.contentDOM||l.dom)}</span>}<span class="cstat-no" title="statement not covered" ></span>o</span>.appendChild(r.serializeNodeInner(t,e))}</span>)),n}</span>,Ur.prototype.serializeNodeInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e={});v</span>ar n=<span class="cstat-no" title="statement not covered" >Ur.renderSpec(Yr(e),this.nodes[t.type.name](t)),</span>r=<span class="cstat-no" title="statement not covered" >n.dom,</span>o=<span class="cstat-no" title="statement not covered" >n.contentDOM;<span class="cstat-no" title="statement not covered" ></span>if(o){<span class="cstat-no" title="statement not covered" >if(t.isLeaf)<span class="cstat-no" title="statement not covered" >throw new RangeError("Content hole not allowed in a leaf node spec");<span class="cstat-no" title="statement not covered" >e</span></span>.onContent?e.onContent(t,o,e):this.serializeFragment(t.content,e,o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>,Ur.prototype.serializeNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e={});<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >this.serializeNodeInner(t,e),</span>r=<span class="cstat-no" title="statement not covered" >t.marks.length-1;</span>r&gt;=0;r--){var o=<span class="cstat-no" title="statement not covered" >this.serializeMark(t.marks[r],t.isInline,e);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;((o.contentDOM||o.dom).appendChild(n),n=o.dom)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>,Ur.prototype.serializeMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n={});v</span>ar r=<span class="cstat-no" title="statement not covered" >this.marks[t.type.name];<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;Ur.renderSpec(Yr(n),r(t,e))}</span>,Ur.renderSpec=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(void 0===n&amp;&amp;(n=null),"string"==typeof e)<span class="cstat-no" title="statement not covered" >return{dom:t.createTextNode(e)};<span class="cstat-no" title="statement not covered" >i</span></span>f(null!=e.nodeType)<span class="cstat-no" title="statement not covered" >return{dom:e};<span class="cstat-no" title="statement not covered" >i</span></span>f(e.dom&amp;&amp;null!=e.dom.nodeType)<span class="cstat-no" title="statement not covered" >return e;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >e[0],</span>o=<span class="cstat-no" title="statement not covered" >r.indexOf(" ");<span class="cstat-no" title="statement not covered" ></span>o&gt;0&amp;&amp;(n=r.slice(0,o),r=r.slice(o+1));v</span>ar i=<span class="cstat-no" title="statement not covered" >null,</span>s=<span class="cstat-no" title="statement not covered" >n?t.createElementNS(n,r):t.createElement(r),</span>a=<span class="cstat-no" title="statement not covered" >e[1],</span>c=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;"object"==typeof a&amp;&amp;null==a.nodeType&amp;&amp;!Array.isArray(a))<span class="cstat-no" title="statement not covered" >for(var l in c=2,a)<span class="cstat-no" title="statement not covered" >if(null!=a[l]){var p=<span class="cstat-no" title="statement not covered" >l.indexOf(" ");<span class="cstat-no" title="statement not covered" ></span>p&gt;0?s.setAttributeNS(l.slice(0,p),l.slice(p+1),a[l]):s.setAttribute(l,a[l])}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(var u=<span class="cstat-no" title="statement not covered" >c;</span>u&lt;e.length;u++){var h=<span class="cstat-no" title="statement not covered" >e[u];<span class="cstat-no" title="statement not covered" ></span>if(0===h){<span class="cstat-no" title="statement not covered" >if(u&lt;e.length-1||u&gt;c)<span class="cstat-no" title="statement not covered" >throw new RangeError("Content hole must be the only child of its parent node");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{dom:s,contentDOM:s}}</span>v</span>ar d=<span class="cstat-no" title="statement not covered" >Ur.renderSpec(t,h,n),</span>f=<span class="cstat-no" title="statement not covered" >d.dom,</span>m=<span class="cstat-no" title="statement not covered" >d.contentDOM;<span class="cstat-no" title="statement not covered" ></span>if(s.appendChild(f),m){<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >throw new RangeError("Multiple content holes");<span class="cstat-no" title="statement not covered" >i</span></span>=m}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{dom:s,contentDOM:i}}</span>,Ur.fromSchema=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.cached.domSerializer||(t.cached.domSerializer=new Ur(this.nodesFromSchema(t),this.marksFromSchema(t)))}</span>,Ur.nodesFromSchema=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Gr(t.nodes);<span class="cstat-no" title="statement not covered" ></span>return e.text||(e.text=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.text}</span>),e}</span>,Ur.marksFromSchema=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Gr(t.marks)}</span>;v</span>ar Xr=<span class="cstat-no" title="statement not covered" >65535,</span>Qr=<span class="cstat-no" title="statement not covered" >Math.pow(2,16);</span>function <span class="fstat-no" title="function not covered" >Zr(</span>t,e){<span class="cstat-no" title="statement not covered" >return t+e*Qr}</span>function <span class="fstat-no" title="function not covered" >to(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;Xr}</span>function <span class="fstat-no" title="function not covered" >eo(</span>t){<span class="cstat-no" title="statement not covered" >return(t-(t&amp;Xr))/Qr}</span>var no=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=!1),void 0===n&amp;&amp;(n=null),this.pos=t,this.deleted=e,this.recover=n}</span>,</span>ro=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=!1),this.ranges=t,this.inverted=e}</span>;<span class="cstat-no" title="statement not covered" ></span>ro.prototype.recover=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >to(t);<span class="cstat-no" title="statement not covered" ></span>if(!this.inverted)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;n;r++)<span class="cstat-no" title="statement not covered" >e+=this.ranges[3*r+2]-this.ranges[3*r+1];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this.ranges[3*n]+e+eo(t)}</span>,ro.prototype.mapResult=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=1),this._map(t,e,!1)}</span>,ro.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=1),this._map(t,e,!0)}</span>,ro.prototype._map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >this.inverted?2:1,</span>i=<span class="cstat-no" title="statement not covered" >this.inverted?1:2,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;this.ranges.length;s+=3){var a=<span class="cstat-no" title="statement not covered" >this.ranges[s]-(this.inverted?r:0);<span class="cstat-no" title="statement not covered" ></span>if(a&gt;t)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >this.ranges[s+o],</span>l=<span class="cstat-no" title="statement not covered" >this.ranges[s+i],</span>p=<span class="cstat-no" title="statement not covered" >a+c;<span class="cstat-no" title="statement not covered" ></span>if(t&lt;=p){var u=<span class="cstat-no" title="statement not covered" >c?t==a?-1:t==p?1:e:e,</span>h=<span class="cstat-no" title="statement not covered" >a+r+(u&lt;0?0:l);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return h;v</span></span>ar d=<span class="cstat-no" title="statement not covered" >t==(e&lt;0?a:p)?null:Zr(s/3,t-a);<span class="cstat-no" title="statement not covered" ></span>return new no(h,e&lt;0?t!=a:t!=p,d)}<span class="cstat-no" title="statement not covered" ></span>r</span>+=l-c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n?t+r:new no(t+r)}</span>,ro.prototype.touches=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >to(e),</span>o=<span class="cstat-no" title="statement not covered" >this.inverted?2:1,</span>i=<span class="cstat-no" title="statement not covered" >this.inverted?1:2,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;this.ranges.length;s+=3){var a=<span class="cstat-no" title="statement not covered" >this.ranges[s]-(this.inverted?n:0);<span class="cstat-no" title="statement not covered" ></span>if(a&gt;t)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >this.ranges[s+o],</span>l=<span class="cstat-no" title="statement not covered" >a+c;<span class="cstat-no" title="statement not covered" ></span>if(t&lt;=l&amp;&amp;s==3*r)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >n</span></span>+=this.ranges[s+i]-c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>,ro.prototype.forEach=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.inverted?2:1,</span>n=<span class="cstat-no" title="statement not covered" >this.inverted?1:2,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.ranges.length;r+=3){var i=<span class="cstat-no" title="statement not covered" >this.ranges[r],</span>s=<span class="cstat-no" title="statement not covered" >i-(this.inverted?o:0),</span>a=<span class="cstat-no" title="statement not covered" >i+(this.inverted?0:o),</span>c=<span class="cstat-no" title="statement not covered" >this.ranges[r+e],</span>l=<span class="cstat-no" title="statement not covered" >this.ranges[r+n];<span class="cstat-no" title="statement not covered" ></span>t(s,s+c,a,a+l),o+=l-c}</span>}</span>,ro.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new ro(this.ranges,!this.inverted)}</span>,ro.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.inverted?"-":"")+JSON.stringify(this.ranges)}</span>,ro.offset=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0==t?ro.empty:new ro(t&lt;0?[0,-t,0]:[0,0,t])}</span>,ro.empty=new ro([]);v</span>ar oo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.maps=t||[],this.from=n||0,this.to=null==r?this.maps.length:r,this.mirror=e}</span>;</span>function <span class="fstat-no" title="function not covered" >io(</span>t){var e=<span class="cstat-no" title="statement not covered" >Error.call(this,t);<span class="cstat-no" title="statement not covered" ></span>return e.__proto__=io.prototype,e}<span class="cstat-no" title="statement not covered" ></span>oo.prototype.slice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===t&amp;&amp;(t=0),void 0===e&amp;&amp;(e=this.maps.length),new oo(this.maps,this.mirror,t,e)}</span>,oo.prototype.copy=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new oo(this.maps.slice(),this.mirror&amp;&amp;this.mirror.slice(),this.from,this.to)}</span>,oo.prototype.appendMap=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.to=this.maps.push(t),null!=e&amp;&amp;this.setMirror(this.maps.length-1,e)}</span>,oo.prototype.appendMapping=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >this.maps.length;</span>e&lt;t.maps.length;e++){var r=<span class="cstat-no" title="statement not covered" >t.getMirror(e);<span class="cstat-no" title="statement not covered" ></span>this.appendMap(t.maps[e],null!=r&amp;&amp;r&lt;e?n+r:null)}</span>}</span>,oo.prototype.getMirror=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.mirror)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.mirror.length;e++)<span class="cstat-no" title="statement not covered" >if(this.mirror[e]==t)<span class="cstat-no" title="statement not covered" >return this.mirror[e+(e%2?-1:1)]}</span></span></span></span>,oo.prototype.setMirror=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.mirror||(this.mirror=[]),this.mirror.push(t,e)}</span>,oo.prototype.appendMappingInverted=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.maps.length-1,</span>n=<span class="cstat-no" title="statement not covered" >this.maps.length+t.maps.length;</span>e&gt;=0;e--){var r=<span class="cstat-no" title="statement not covered" >t.getMirror(e);<span class="cstat-no" title="statement not covered" ></span>this.appendMap(t.maps[e].invert(),null!=r&amp;&amp;r&gt;e?n-r-1:null)}</span>}</span>,oo.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >new oo;<span class="cstat-no" title="statement not covered" ></span>return t.appendMappingInverted(this),t}</span>,oo.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(void 0===e&amp;&amp;(e=1),this.mirror)<span class="cstat-no" title="statement not covered" >return this._map(t,e,!0);<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >this.from;</span>n&lt;this.to;n++)<span class="cstat-no" title="statement not covered" >t=this.maps[n].map(t,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,oo.prototype.mapResult=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=1),this._map(t,e,!1)}</span>,oo.prototype._map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >this.from;</span>o&lt;this.to;o++){var i=<span class="cstat-no" title="statement not covered" >this.maps[o],</span>s=<span class="cstat-no" title="statement not covered" >i.mapResult(t,e);<span class="cstat-no" title="statement not covered" ></span>if(null!=s.recover){var a=<span class="cstat-no" title="statement not covered" >this.getMirror(o);<span class="cstat-no" title="statement not covered" ></span>if(null!=a&amp;&amp;a&gt;o&amp;&amp;a&lt;this.to){<span class="cstat-no" title="statement not covered" >o=a,t=this.maps[a].recover(s.recover);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>.deleted&amp;&amp;(r=!0),t=s.pos}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n?t:new no(t,r)}</span>,io.prototype=Object.create(Error.prototype),io.prototype.constructor=io,io.prototype.name="TransformError";v</span>ar so=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.doc=t,this.steps=[],this.docs=[],this.mapping=new oo}</span>,</span>ao=<span class="cstat-no" title="statement not covered" >{before:{configurable:!0},docChanged:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >co(</span>){<span class="cstat-no" title="statement not covered" >throw new Error("Override me")}<span class="cstat-no" title="statement not covered" ></span>ao.before.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.docs.length?this.docs[0]:this.doc}</span>,so.prototype.step=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.maybeStep(t);<span class="cstat-no" title="statement not covered" ></span>if(e.failed)<span class="cstat-no" title="statement not covered" >throw new io(e.failed);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,so.prototype.maybeStep=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.apply(this.doc);<span class="cstat-no" title="statement not covered" ></span>return e.failed||this.addStep(t,e.doc),e}</span>,ao.docChanged.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.steps.length&gt;0}</span>,so.prototype.addStep=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.docs.push(this.doc),this.steps.push(t),this.mapping.appendMap(t.getMap()),this.doc=e}</span>,Object.defineProperties(so.prototype,ao);v</span>ar lo=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>po=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" ></span>po.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return co()}</span>,po.prototype.getMap=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return ro.empty}</span>,po.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return co()}</span>,po.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return co()}</span>,po.prototype.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null}</span>,po.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return co()}</span>,po.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e||!e.stepType)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Step.fromJSON");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >lo[e.stepType];<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new RangeError("No step type "+e.stepType+" defined");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.fromJSON(t,e)}</span>,po.jsonID=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t in lo)<span class="cstat-no" title="statement not covered" >throw new RangeError("Duplicate use of step JSON ID "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn lo[t]=e,e.prototype.jsonID=t,e}</span>;v</span>ar uo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.doc=t,this.failed=e}</span>;<span class="cstat-no" title="statement not covered" ></span>uo.ok=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new uo(t,null)}</span>,uo.fail=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new uo(null,t)}</span>,uo.fromReplace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return uo.ok(t.replace(e,n,r))}</span>catch(o){<span class="cstat-no" title="statement not covered" >if(o instanceof In)<span class="cstat-no" title="statement not covered" >return uo.fail(o.message);<span class="cstat-no" title="statement not covered" >t</span></span>hrow o}</span>}</span>;v</span>ar ho=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o){<span class="cstat-no" title="statement not covered" >t.call(this),this.from=e,this.to=n,this.slice=r,this.structure=!!o}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.structure&amp;&amp;mo(t,this.from,this.to)?uo.fail("Structure replace would overwrite content"):uo.fromReplace(t,this.from,this.to,this.slice)}</span>,e.prototype.getMap=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new ro([this.from,this.to-this.from,this.slice.size])}</span>,e.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new e(this.from,this.from+this.slice.size,t.slice(this.from,this.to))}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.mapResult(this.from,1),</span>r=<span class="cstat-no" title="statement not covered" >t.mapResult(this.to,-1);<span class="cstat-no" title="statement not covered" ></span>return n.deleted&amp;&amp;r.deleted?null:new e(n.pos,Math.max(n.pos,r.pos),this.slice)}</span>,e.prototype.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!(t instanceof e)||t.structure||this.structure)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.from+this.slice.size!=t.from||this.slice.openEnd||t.slice.openStart){<span class="cstat-no" title="statement not covered" >if(t.to!=this.from||this.slice.openStart||t.slice.openEnd)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.slice.size+t.slice.size==0?Dn.empty:new Dn(t.slice.content.append(this.slice.content),t.slice.openStart,this.slice.openEnd);<span class="cstat-no" title="statement not covered" ></span>return new e(t.from,this.to,n,this.structure)}</span>v</span>ar r=<span class="cstat-no" title="statement not covered" >this.slice.size+t.slice.size==0?Dn.empty:new Dn(this.slice.content.append(t.slice.content),this.slice.openStart,t.slice.openEnd);<span class="cstat-no" title="statement not covered" ></span>return new e(this.from,this.to+(t.to-t.from),r,this.structure)}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >{stepType:"replace",from:this.from,to:this.to};<span class="cstat-no" title="statement not covered" ></span>return this.slice.size&amp;&amp;(t.slice=this.slice.toJSON()),this.structure&amp;&amp;(t.structure=!0),t}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.from||"number"!=typeof n.to)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for ReplaceStep.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(n.from,n.to,Dn.fromJSON(t,n.slice),!!n.structure)}</span>,e}</span>(po);<span class="cstat-no" title="statement not covered" ></span>po.jsonID("replace",ho);v</span>ar fo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o,i,s,a){<span class="cstat-no" title="statement not covered" >t.call(this),this.from=e,this.to=n,this.gapFrom=r,this.gapTo=o,this.slice=i,this.insert=s,this.structure=!!a}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.structure&amp;&amp;(mo(t,this.from,this.gapFrom)||mo(t,this.gapTo,this.to)))<span class="cstat-no" title="statement not covered" >return uo.fail("Structure gap-replace would overwrite content");v</span></span>ar e=<span class="cstat-no" title="statement not covered" >t.slice(this.gapFrom,this.gapTo);<span class="cstat-no" title="statement not covered" ></span>if(e.openStart||e.openEnd)<span class="cstat-no" title="statement not covered" >return uo.fail("Gap is not a flat range");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.slice.insertAt(this.insert,e.content);<span class="cstat-no" title="statement not covered" ></span>return n?uo.fromReplace(t,this.from,this.to,n):uo.fail("Content does not fit in gap")}</span>,e.prototype.getMap=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new ro([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}</span>,e.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >this.gapTo-this.gapFrom;<span class="cstat-no" title="statement not covered" ></span>return new e(this.from,this.from+this.slice.size+n,this.from+this.insert,this.from+this.insert+n,t.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.mapResult(this.from,1),</span>r=<span class="cstat-no" title="statement not covered" >t.mapResult(this.to,-1),</span>o=<span class="cstat-no" title="statement not covered" >t.map(this.gapFrom,-1),</span>i=<span class="cstat-no" title="statement not covered" >t.map(this.gapTo,1);<span class="cstat-no" title="statement not covered" ></span>return n.deleted&amp;&amp;r.deleted||o&lt;n.pos||i&gt;r.pos?null:new e(n.pos,r.pos,o,i,this.slice,this.insert,this.structure)}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >{stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};<span class="cstat-no" title="statement not covered" ></span>return this.slice.size&amp;&amp;(t.slice=this.slice.toJSON()),this.structure&amp;&amp;(t.structure=!0),t}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.from||"number"!=typeof n.to||"number"!=typeof n.gapFrom||"number"!=typeof n.gapTo||"number"!=typeof n.insert)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(n.from,n.to,n.gapFrom,n.gapTo,Dn.fromJSON(t,n.slice),n.insert,!!n.structure)}</span>,e}</span>(po);</span>function <span class="fstat-no" title="function not covered" >mo(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.resolve(e),</span>o=<span class="cstat-no" title="statement not covered" >n-e,</span>i=<span class="cstat-no" title="statement not covered" >r.depth;<span class="cstat-no" title="statement not covered" ></span>while(o&gt;0&amp;&amp;i&gt;0&amp;&amp;r.indexAfter(i)==r.node(i).childCount)<span class="cstat-no" title="statement not covered" >i--,o--;<span class="cstat-no" title="statement not covered" >i</span></span>f(o&gt;0){var s=<span class="cstat-no" title="statement not covered" >r.node(i).maybeChild(r.indexAfter(i));<span class="cstat-no" title="statement not covered" ></span>while(o&gt;0){<span class="cstat-no" title="statement not covered" >if(!s||s.isLeaf)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >s</span></span>=s.firstChild,o--}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >vo(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return(0==e||t.canReplace(e,t.childCount))&amp;&amp;(n==t.childCount||t.canReplace(0,n))}</span>function <span class="fstat-no" title="function not covered" >go(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.parent,</span>n=<span class="cstat-no" title="statement not covered" >e.content.cutByIndex(t.startIndex,t.endIndex),</span>r=<span class="cstat-no" title="statement not covered" >t.depth;</span>;--r){var o=<span class="cstat-no" title="statement not covered" >t.$from.node(r),</span>i=<span class="cstat-no" title="statement not covered" >t.$from.index(r),</span>s=<span class="cstat-no" title="statement not covered" >t.$to.indexAfter(r);<span class="cstat-no" title="statement not covered" ></span>if(r&lt;t.depth&amp;&amp;o.canReplace(i,s,n))<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >i</span></span>f(0==r||o.type.spec.isolating||!vo(o,i,s))<span class="cstat-no" title="statement not covered" >break}</span></span>}</span>function <span class="fstat-no" title="function not covered" >yo(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=t);v</span>ar o=<span class="cstat-no" title="statement not covered" >wo(t,e),</span>i=<span class="cstat-no" title="statement not covered" >o&amp;&amp;Oo(r,e);<span class="cstat-no" title="statement not covered" ></span>return i?o.map(bo).concat({type:e,attrs:n}).concat(i.map(bo)):null}</span>function <span class="fstat-no" title="function not covered" >bo(</span>t){<span class="cstat-no" title="statement not covered" >return{type:t,attrs:null}}</span>function <span class="fstat-no" title="function not covered" >wo(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.parent,</span>r=<span class="cstat-no" title="statement not covered" >t.startIndex,</span>o=<span class="cstat-no" title="statement not covered" >t.endIndex,</span>i=<span class="cstat-no" title="statement not covered" >n.contentMatchAt(r).findWrapping(e);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >i.length?i[0]:e;<span class="cstat-no" title="statement not covered" ></span>return n.canReplaceWith(r,o,s)?i:null}</span>function <span class="fstat-no" title="function not covered" >Oo(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.parent,</span>r=<span class="cstat-no" title="statement not covered" >t.startIndex,</span>o=<span class="cstat-no" title="statement not covered" >t.endIndex,</span>i=<span class="cstat-no" title="statement not covered" >n.child(r),</span>s=<span class="cstat-no" title="statement not covered" >e.contentMatch.findWrapping(i.type);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >f</span></span>or(var a=<span class="cstat-no" title="statement not covered" >s.length?s[s.length-1]:e,</span>c=<span class="cstat-no" title="statement not covered" >a.contentMatch,</span>l=<span class="cstat-no" title="statement not covered" >r;</span>c&amp;&amp;l&lt;o;l++)<span class="cstat-no" title="statement not covered" >c=c.matchType(n.child(l).type);<span class="cstat-no" title="statement not covered" >r</span></span>eturn c&amp;&amp;c.validEnd?s:null}</span>function <span class="fstat-no" title="function not covered" >ko(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.resolve(e),</span>o=<span class="cstat-no" title="statement not covered" >r.index();<span class="cstat-no" title="statement not covered" ></span>return r.parent.canReplaceWith(o,o+1,n)}</span>function <span class="fstat-no" title="function not covered" >xo(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=1);v</span>ar o=<span class="cstat-no" title="statement not covered" >t.resolve(e),</span>i=<span class="cstat-no" title="statement not covered" >o.depth-n,</span>s=<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[r.length-1]||o.parent;<span class="cstat-no" title="statement not covered" ></span>if(i&lt;0||o.parent.type.spec.isolating||!o.parent.canReplace(o.index(),o.parent.childCount)||!s.type.validContent(o.parent.content.cutByIndex(o.index(),o.parent.childCount)))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var a=<span class="cstat-no" title="statement not covered" >o.depth-1,</span>c=<span class="cstat-no" title="statement not covered" >n-2;</span>a&gt;i;a--,c--){var l=<span class="cstat-no" title="statement not covered" >o.node(a),</span>p=<span class="cstat-no" title="statement not covered" >o.index(a);<span class="cstat-no" title="statement not covered" ></span>if(l.type.spec.isolating)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar u=<span class="cstat-no" title="statement not covered" >l.content.cutByIndex(p,l.childCount),</span>h=<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[c]||l;<span class="cstat-no" title="statement not covered" ></span>if(h!=l&amp;&amp;(u=u.replaceChild(0,h.type.create(h.attrs))),!l.canReplace(p+1,l.childCount)||!h.type.validContent(u))<span class="cstat-no" title="statement not covered" >return!1}</span></span>v</span>ar d=<span class="cstat-no" title="statement not covered" >o.indexAfter(i),</span>f=<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[0];<span class="cstat-no" title="statement not covered" ></span>return o.node(i).canReplaceWith(d,d,f?f.type:o.node(i+1).type)}</span>function <span class="fstat-no" title="function not covered" >So(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.resolve(e),</span>r=<span class="cstat-no" title="statement not covered" >n.index();<span class="cstat-no" title="statement not covered" ></span>return Mo(n.nodeBefore,n.nodeAfter)&amp;&amp;n.parent.canReplace(r,r+1)}</span>function <span class="fstat-no" title="function not covered" >Mo(</span>t,e){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;e&amp;&amp;!t.isLeaf&amp;&amp;t.canAppend(e)}</span>function <span class="fstat-no" title="function not covered" >Co(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.resolve(e);<span class="cstat-no" title="statement not covered" ></span>if(r.parent.canReplaceWith(r.index(),r.index(),n))<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(0==r.parentOffset)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >r.depth-1;</span>o&gt;=0;o--){var i=<span class="cstat-no" title="statement not covered" >r.index(o);<span class="cstat-no" title="statement not covered" ></span>if(r.node(o).canReplaceWith(i,i,n))<span class="cstat-no" title="statement not covered" >return r.before(o+1);<span class="cstat-no" title="statement not covered" >i</span></span>f(i&gt;0)<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span></span>i</span></span>f(r.parentOffset==r.parent.content.size)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >r.depth-1;</span>s&gt;=0;s--){var a=<span class="cstat-no" title="statement not covered" >r.indexAfter(s);<span class="cstat-no" title="statement not covered" ></span>if(r.node(s).canReplaceWith(a,a,n))<span class="cstat-no" title="statement not covered" >return r.after(s+1);<span class="cstat-no" title="statement not covered" >i</span></span>f(a&lt;r.node(s).childCount)<span class="cstat-no" title="statement not covered" >return null}</span></span>}</span></span>function <span class="fstat-no" title="function not covered" >Eo(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.resolve(e);<span class="cstat-no" title="statement not covered" ></span>if(!n.content.size)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >n.content,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;n.openStart;i++)<span class="cstat-no" title="statement not covered" >o=o.firstChild.content;<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >1;</span>s&lt;=(0==n.openStart&amp;&amp;n.size?2:1);s++)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >r.depth;</span>a&gt;=0;a--){var c=<span class="cstat-no" title="statement not covered" >a==r.depth?0:r.pos&lt;=(r.start(a+1)+r.end(a+1))/2?-1:1,</span>l=<span class="cstat-no" title="statement not covered" >r.index(a)+(c&gt;0?1:0),</span>p=<span class="cstat-no" title="statement not covered" >r.node(a),</span>u=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(1==s)<span class="cstat-no" title="statement not covered" >u=p.canReplace(l,l,o);e</span>lse{var h=<span class="cstat-no" title="statement not covered" >p.contentMatchAt(l).findWrapping(o.firstChild.type);<span class="cstat-no" title="statement not covered" ></span>u=h&amp;&amp;p.canReplaceWith(l,l,h[0])}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u)<span class="cstat-no" title="statement not covered" >return 0==c?r.pos:c&lt;0?r.before(a+1):r.after(a+1)}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn null}</span>function <span class="fstat-no" title="function not covered" >To(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t.childCount;o++){var i=<span class="cstat-no" title="statement not covered" >t.child(o);<span class="cstat-no" title="statement not covered" ></span>i.content.size&amp;&amp;(i=i.copy(To(i.content,e,i))),i.isInline&amp;&amp;(i=e(i,n,o)),r.push(i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Cn.fromArray(r)}<span class="cstat-no" title="statement not covered" ></span>po.jsonID("replaceAround",fo),so.prototype.lift=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t.$from,</span>r=<span class="cstat-no" title="statement not covered" >t.$to,</span>o=<span class="cstat-no" title="statement not covered" >t.depth,</span>i=<span class="cstat-no" title="statement not covered" >n.before(o+1),</span>s=<span class="cstat-no" title="statement not covered" >r.after(o+1),</span>a=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >s,</span>l=<span class="cstat-no" title="statement not covered" >Cn.empty,</span>p=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >o,</span>h=<span class="cstat-no" title="statement not covered" >!1;</span>u&gt;e;u--)<span class="cstat-no" title="statement not covered" >h||n.index(u)&gt;0?(h=!0,l=Cn.from(n.node(u).copy(l)),p++):a--;<span class="cstat-no" title="statement not covered" >f</span></span>or(var d=<span class="cstat-no" title="statement not covered" >Cn.empty,</span>f=<span class="cstat-no" title="statement not covered" >0,</span>m=<span class="cstat-no" title="statement not covered" >o,</span>v=<span class="cstat-no" title="statement not covered" >!1;</span>m&gt;e;m--)<span class="cstat-no" title="statement not covered" >v||r.after(m+1)&lt;r.end(m)?(v=!0,d=Cn.from(r.node(m).copy(d)),f++):c++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.step(new fo(a,c,i,s,new Dn(l.append(d),p,f),l.size-p,!0))}</span>,so.prototype.wrap=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >Cn.empty,</span>r=<span class="cstat-no" title="statement not covered" >e.length-1;</span>r&gt;=0;r--)<span class="cstat-no" title="statement not covered" >n=Cn.from(e[r].type.create(e[r].attrs,n));v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t.start,</span>i=<span class="cstat-no" title="statement not covered" >t.end;<span class="cstat-no" title="statement not covered" ></span>return this.step(new fo(o,i,o,i,new Dn(n,0,0),e.length,!0))}</span>,so.prototype.setBlockType=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(void 0===e&amp;&amp;(e=t),!n.isTextblock)<span class="cstat-no" title="statement not covered" >throw new RangeError("Type given to setBlockType should be a textblock");v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this.steps.length;<span class="cstat-no" title="statement not covered" ></span>return this.doc.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t.isTextblock&amp;&amp;!t.hasMarkup(n,r)&amp;&amp;ko(o.doc,o.mapping.slice(i).map(e),n)){<span class="cstat-no" title="statement not covered" >o.clearIncompatible(o.mapping.slice(i).map(e,1),n);v</span>ar s=<span class="cstat-no" title="statement not covered" >o.mapping.slice(i),</span>a=<span class="cstat-no" title="statement not covered" >s.map(e,1),</span>c=<span class="cstat-no" title="statement not covered" >s.map(e+t.nodeSize,1);<span class="cstat-no" title="statement not covered" ></span>return o.step(new fo(a,c,a+1,c-1,new Dn(Cn.from(n.create(r,null,t.marks)),0,0),1,!0)),!1}</span>}</span>)),this}</span>,so.prototype.setNodeMarkup=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >this.doc.nodeAt(t);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >throw new RangeError("No node at given position");<span class="cstat-no" title="statement not covered" >e</span></span>||(e=o.type);v</span>ar i=<span class="cstat-no" title="statement not covered" >e.create(n,null,r||o.marks);<span class="cstat-no" title="statement not covered" ></span>if(o.isLeaf)<span class="cstat-no" title="statement not covered" >return this.replaceWith(t,t+o.nodeSize,i);<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.validContent(o.content))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid content for node type "+e.name);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.step(new fo(t,t+o.nodeSize,t+1,t+o.nodeSize-1,new Dn(Cn.from(i),0,0),1,!0))}</span>,so.prototype.split=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=1);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >this.doc.resolve(t),</span>o=<span class="cstat-no" title="statement not covered" >Cn.empty,</span>i=<span class="cstat-no" title="statement not covered" >Cn.empty,</span>s=<span class="cstat-no" title="statement not covered" >r.depth,</span>a=<span class="cstat-no" title="statement not covered" >r.depth-e,</span>c=<span class="cstat-no" title="statement not covered" >e-1;</span>s&gt;a;s--,c--){<span class="cstat-no" title="statement not covered" >o=Cn.from(r.node(s).copy(o));v</span>ar l=<span class="cstat-no" title="statement not covered" >n&amp;&amp;n[c];<span class="cstat-no" title="statement not covered" ></span>i=Cn.from(l?l.type.create(l.attrs,i):r.node(s).copy(i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.step(new ho(t,t,new Dn(o.append(i),e,e),!0))}</span>,so.prototype.join=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=1);v</span>ar n=<span class="cstat-no" title="statement not covered" >new ho(t-e,t+e,Dn.empty,!0);<span class="cstat-no" title="statement not covered" ></span>return this.step(n)}</span>;v</span>ar No=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r){<span class="cstat-no" title="statement not covered" >t.call(this),this.from=e,this.to=n,this.mark=r}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.slice(this.from,this.to),</span>r=<span class="cstat-no" title="statement not covered" >t.resolve(this.from),</span>o=<span class="cstat-no" title="statement not covered" >r.node(r.sharedDepth(this.to)),</span>i=<span class="cstat-no" title="statement not covered" >new Dn(To(n.content,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t.isAtom&amp;&amp;n.type.allowsMarkType(e.mark.type)?t.mark(e.mark.addToSet(t.marks)):t}</span>),o),n.openStart,n.openEnd);<span class="cstat-no" title="statement not covered" ></span>return uo.fromReplace(t,this.from,this.to,i)}</span>,e.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new jo(this.from,this.to,this.mark)}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.mapResult(this.from,1),</span>r=<span class="cstat-no" title="statement not covered" >t.mapResult(this.to,-1);<span class="cstat-no" title="statement not covered" ></span>return n.deleted&amp;&amp;r.deleted||n.pos&gt;=r.pos?null:new e(n.pos,r.pos,this.mark)}</span>,e.prototype.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t instanceof e&amp;&amp;t.mark.eq(this.mark)&amp;&amp;this.from&lt;=t.to&amp;&amp;this.to&gt;=t.from)<span class="cstat-no" title="statement not covered" >return new e(Math.min(this.from,t.from),Math.max(this.to,t.to),this.mark)}</span></span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.from||"number"!=typeof n.to)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for AddMarkStep.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(n.from,n.to,t.markFromJSON(n.mark))}</span>,e}</span>(po);<span class="cstat-no" title="statement not covered" ></span>po.jsonID("addMark",No);v</span>ar jo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r){<span class="cstat-no" title="statement not covered" >t.call(this),this.from=e,this.to=n,this.mark=r}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.slice(this.from,this.to),</span>r=<span class="cstat-no" title="statement not covered" >new Dn(To(n.content,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.mark(e.mark.removeFromSet(t.marks))}</span>)),n.openStart,n.openEnd);<span class="cstat-no" title="statement not covered" ></span>return uo.fromReplace(t,this.from,this.to,r)}</span>,e.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new No(this.from,this.to,this.mark)}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.mapResult(this.from,1),</span>r=<span class="cstat-no" title="statement not covered" >t.mapResult(this.to,-1);<span class="cstat-no" title="statement not covered" ></span>return n.deleted&amp;&amp;r.deleted||n.pos&gt;=r.pos?null:new e(n.pos,r.pos,this.mark)}</span>,e.prototype.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t instanceof e&amp;&amp;t.mark.eq(this.mark)&amp;&amp;this.from&lt;=t.to&amp;&amp;this.to&gt;=t.from)<span class="cstat-no" title="statement not covered" >return new e(Math.min(this.from,t.from),Math.max(this.to,t.to),this.mark)}</span></span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.from||"number"!=typeof n.to)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(n.from,n.to,t.markFromJSON(n.mark))}</span>,e}</span>(po);</span>function <span class="fstat-no" title="function not covered" >Ao(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >if(void 0===n&amp;&amp;(n=e),void 0===r&amp;&amp;(r=Dn.empty),e==n&amp;&amp;!r.size)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t.resolve(e),</span>i=<span class="cstat-no" title="statement not covered" >t.resolve(n);<span class="cstat-no" title="statement not covered" ></span>return Io(o,i,r)?new ho(e,n,r):new Do(o,i,r).fit()}</span>function <span class="fstat-no" title="function not covered" >Io(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return!n.openStart&amp;&amp;!n.openEnd&amp;&amp;t.start()==e.start()&amp;&amp;t.parent.canReplace(t.index(),e.index(),n.content)}<span class="cstat-no" title="statement not covered" ></span>po.jsonID("removeMark",jo),so.prototype.addMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >null,</span>a=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return this.doc.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(r,c,l){<span class="cstat-no" title="statement not covered" >if(r.isInline){var p=<span class="cstat-no" title="statement not covered" >r.marks;<span class="cstat-no" title="statement not covered" ></span>if(!n.isInSet(p)&amp;&amp;l.type.allowsMarkType(n.type)){<span class="cstat-no" title="statement not covered" >for(var u=<span class="cstat-no" title="statement not covered" >Math.max(c,t),</span>h=<span class="cstat-no" title="statement not covered" >Math.min(c+r.nodeSize,e),</span>d=<span class="cstat-no" title="statement not covered" >n.addToSet(p),</span>f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;p.length;f++)<span class="cstat-no" title="statement not covered" >p[f].isInSet(d)||(s&amp;&amp;s.to==u&amp;&amp;s.mark.eq(p[f])?s.to=h:o.push(s=new jo(u,h,p[f])));<span class="cstat-no" title="statement not covered" >a</span></span>&amp;&amp;a.to==u?a.to=h:i.push(a=new No(u,h,n))}</span>}</span>}</span>)),o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return r.step(t)}</span>)),i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return r.step(t)}</span>)),this}</span>,so.prototype.removeMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>void 0===n&amp;&amp;(n=null);v</span>ar o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.doc.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(r,s){<span class="cstat-no" title="statement not covered" >if(r.isInline){<span class="cstat-no" title="statement not covered" >i++;v</span>ar a=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(n instanceof Tr){var c,l=<span class="cstat-no" title="statement not covered" >r.marks;<span class="cstat-no" title="statement not covered" ></span>while(c=n.isInSet(l))<span class="cstat-no" title="statement not covered" >(a||(a=[])).push(c),l=c.removeFromSet(l)}</span></span>else <span class="cstat-no" title="statement not covered" >n?n.isInSet(r.marks)&amp;&amp;(a=[n]):a=r.marks;<span class="cstat-no" title="statement not covered" >i</span></span>f(a&amp;&amp;a.length)<span class="cstat-no" title="statement not covered" >for(var p=<span class="cstat-no" title="statement not covered" >Math.min(s+r.nodeSize,e),</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;a.length;u++){<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >a[u],</span>d=<span class="cstat-no" title="statement not covered" >void 0,</span>f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;o.length;f++){var m=<span class="cstat-no" title="statement not covered" >o[f];<span class="cstat-no" title="statement not covered" ></span>m.step==i-1&amp;&amp;h.eq(o[f].style)&amp;&amp;(d=m)}<span class="cstat-no" title="statement not covered" ></span>d</span>?(d.to=p,d.step=i):o.push({style:h,from:Math.max(s,t),to:p,step:i})}</span>}</span></span>}</span>)),o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return r.step(new jo(t.from,t.to,t.style))}</span>)),this}</span>,so.prototype.clearIncompatible=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=e.contentMatch);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >this.doc.nodeAt(t),</span>o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >t+1,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;r.childCount;s++){var a=<span class="cstat-no" title="statement not covered" >r.child(s),</span>c=<span class="cstat-no" title="statement not covered" >i+a.nodeSize,</span>l=<span class="cstat-no" title="statement not covered" >n.matchType(a.type,a.attrs);<span class="cstat-no" title="statement not covered" ></span>if(l){<span class="cstat-no" title="statement not covered" >n=l;<span class="cstat-no" title="statement not covered" >f</span>or(var p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;a.marks.length;p++)<span class="cstat-no" title="statement not covered" >e.allowsMarkType(a.marks[p].type)||this.step(new jo(i,c,a.marks[p]))}</span></span>else <span class="cstat-no" title="statement not covered" >o.push(new ho(i,c,Dn.empty));<span class="cstat-no" title="statement not covered" >i</span></span>=c}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!n.validEnd){var u=<span class="cstat-no" title="statement not covered" >n.fillBefore(Cn.empty,!0);<span class="cstat-no" title="statement not covered" ></span>this.replace(i,i,new Dn(u,0,0))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var h=<span class="cstat-no" title="statement not covered" >o.length-1;</span>h&gt;=0;h--)<span class="cstat-no" title="statement not covered" >this.step(o[h]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,so.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=t),void 0===n&amp;&amp;(n=Dn.empty);v</span>ar r=<span class="cstat-no" title="statement not covered" >Ao(this.doc,t,e,n);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;this.step(r),this}</span>,so.prototype.replaceWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return this.replace(t,e,new Dn(Cn.from(n),0,0))}</span>,so.prototype.delete=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.replace(t,e,Dn.empty)}</span>,so.prototype.insert=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.replaceWith(t,t,e)}</span>;v</span>ar Do=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.$to=e,this.$from=t,this.unplaced=n,this.frontier=[];<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;=t.depth;r++){var o=<span class="cstat-no" title="statement not covered" >t.node(r);<span class="cstat-no" title="statement not covered" ></span>this.frontier.push({type:o.type,match:o.contentMatchAt(t.indexAfter(r))})}<span class="cstat-no" title="statement not covered" ></span>t</span>his.placed=Cn.empty;<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >t.depth;</span>i&gt;0;i--)<span class="cstat-no" title="statement not covered" >this.placed=Cn.from(t.node(i).copy(this.placed))}</span></span>,</span>Ro=<span class="cstat-no" title="statement not covered" >{depth:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >_o(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return 0==e?t.cutByIndex(n):t.replaceChild(0,t.firstChild.copy(_o(t.firstChild.content,e-1,n)))}</span>function <span class="fstat-no" title="function not covered" >Po(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return 0==e?t.append(n):t.replaceChild(t.childCount-1,t.lastChild.copy(Po(t.lastChild.content,e-1,n)))}</span>function <span class="fstat-no" title="function not covered" >zo(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e;n++)<span class="cstat-no" title="statement not covered" >t=t.firstChild.content;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Bo(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(e&lt;=0)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t.content;<span class="cstat-no" title="statement not covered" ></span>return e&gt;1&amp;&amp;(r=r.replaceChild(0,Bo(r.firstChild,e-1,1==r.childCount?n-1:0))),e&gt;0&amp;&amp;(r=t.type.contentMatch.fillBefore(r).append(r),n&lt;=0&amp;&amp;(r=r.append(t.type.contentMatch.matchFragment(r).fillBefore(Cn.empty,!0)))),t.copy(r)}</span>function <span class="fstat-no" title="function not covered" >Lo(</span>t,e,n,r,o){var i=<span class="cstat-no" title="statement not covered" >t.node(e),</span>s=<span class="cstat-no" title="statement not covered" >o?t.indexAfter(e):t.index(e);<span class="cstat-no" title="statement not covered" ></span>if(s==i.childCount&amp;&amp;!n.compatibleContent(i.type))<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >r.fillBefore(i.content,!0,s);<span class="cstat-no" title="statement not covered" ></span>return a&amp;&amp;!Vo(n,i.content,s)?a:null}</span>function <span class="fstat-no" title="function not covered" >Vo(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >n;</span>r&lt;e.childCount;r++)<span class="cstat-no" title="statement not covered" >if(!t.allowsMarks(e.child(r).marks))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >$o(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >if(e&lt;n){var i=<span class="cstat-no" title="statement not covered" >t.firstChild;<span class="cstat-no" title="statement not covered" ></span>t=t.replaceChild(0,i.copy($o(i.content,e+1,n,r,i)))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e&gt;r){var s=<span class="cstat-no" title="statement not covered" >o.contentMatchAt(0),</span>a=<span class="cstat-no" title="statement not covered" >s.fillBefore(t).append(t);<span class="cstat-no" title="statement not covered" ></span>t=a.append(s.matchFragment(a).fillBefore(Cn.empty,!0))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Fo(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >Math.min(t.depth,e.depth),</span>o=<span class="cstat-no" title="statement not covered" >r;</span>o&gt;=0;o--){var i=<span class="cstat-no" title="statement not covered" >t.start(o);<span class="cstat-no" title="statement not covered" ></span>if(i&lt;t.pos-(t.depth-o)||e.end(o)&gt;e.pos+(e.depth-o)||t.node(o).type.spec.isolating||e.node(o).type.spec.isolating)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>==e.start(o)&amp;&amp;n.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="cstat-no" title="statement not covered" ></span>Ro.depth.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.frontier.length-1}</span>,Do.prototype.fit=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >while(this.unplaced.size){var t=<span class="cstat-no" title="statement not covered" >this.findFittable();<span class="cstat-no" title="statement not covered" ></span>t?this.placeNodes(t):this.openMore()||this.dropNode()}</span>v</span>ar e=<span class="cstat-no" title="statement not covered" >this.mustMoveInline(),</span>n=<span class="cstat-no" title="statement not covered" >this.placed.size-this.depth-this.$from.depth,</span>r=<span class="cstat-no" title="statement not covered" >this.$from,</span>o=<span class="cstat-no" title="statement not covered" >this.close(e&lt;0?this.$to:r.doc.resolve(e));<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this.placed,</span>s=<span class="cstat-no" title="statement not covered" >r.depth,</span>a=<span class="cstat-no" title="statement not covered" >o.depth;<span class="cstat-no" title="statement not covered" ></span>while(s&amp;&amp;a&amp;&amp;1==i.childCount)<span class="cstat-no" title="statement not covered" >i=i.firstChild.content,s--,a--;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >new Dn(i,s,a);<span class="cstat-no" title="statement not covered" ></span>return e&gt;-1?new fo(r.pos,e,this.$to.pos,this.$to.end(),c,n):c.size||r.pos!=this.$to.pos?new ho(r.pos,o.pos,c):void 0}</span>,Do.prototype.findFittable=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >1;</span>t&lt;=2;t++)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.unplaced.openStart;</span>e&gt;=0;e--){var n=<span class="cstat-no" title="statement not covered" >void 0,</span>r=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>e?(r=zo(this.unplaced.content,e-1).firstChild,n=r.content):n=this.unplaced.content;<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >n.firstChild,</span>i=<span class="cstat-no" title="statement not covered" >this.depth;</span>i&gt;=0;i--){var s=<span class="cstat-no" title="statement not covered" >this.frontier[i],</span>a=<span class="cstat-no" title="statement not covered" >s.type,</span>c=<span class="cstat-no" title="statement not covered" >s.match,</span>l=<span class="cstat-no" title="statement not covered" >void 0,</span>p=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>if(1==t&amp;&amp;(o?c.matchType(o.type)||(p=c.fillBefore(Cn.from(o),!1)):a.compatibleContent(r.type)))<span class="cstat-no" title="statement not covered" >return{sliceDepth:e,frontierDepth:i,parent:r,inject:p};<span class="cstat-no" title="statement not covered" >i</span></span>f(2==t&amp;&amp;o&amp;&amp;(l=c.findWrapping(o.type)))<span class="cstat-no" title="statement not covered" >return{sliceDepth:e,frontierDepth:i,parent:r,wrap:l};<span class="cstat-no" title="statement not covered" >i</span></span>f(r&amp;&amp;c.matchType(r.type))<span class="cstat-no" title="statement not covered" >break}</span></span>}</span>}</span></span>,Do.prototype.openMore=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.unplaced,</span>e=<span class="cstat-no" title="statement not covered" >t.content,</span>n=<span class="cstat-no" title="statement not covered" >t.openStart,</span>r=<span class="cstat-no" title="statement not covered" >t.openEnd,</span>o=<span class="cstat-no" title="statement not covered" >zo(e,n);<span class="cstat-no" title="statement not covered" ></span>return!(!o.childCount||o.firstChild.isLeaf)&amp;&amp;(this.unplaced=new Dn(e,n+1,Math.max(r,o.size+n&gt;=e.size-r?n+1:0)),!0)}</span>,Do.prototype.dropNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.unplaced,</span>e=<span class="cstat-no" title="statement not covered" >t.content,</span>n=<span class="cstat-no" title="statement not covered" >t.openStart,</span>r=<span class="cstat-no" title="statement not covered" >t.openEnd,</span>o=<span class="cstat-no" title="statement not covered" >zo(e,n);<span class="cstat-no" title="statement not covered" ></span>if(o.childCount&lt;=1&amp;&amp;n&gt;0){var i=<span class="cstat-no" title="statement not covered" >e.size-n&lt;=n+o.size;<span class="cstat-no" title="statement not covered" ></span>this.unplaced=new Dn(_o(e,n-1,1),n-1,i?n-1:r)}</span>else <span class="cstat-no" title="statement not covered" >this.unplaced=new Dn(_o(e,n,1),n,r)}</span></span>,Do.prototype.placeNodes=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.sliceDepth,</span>n=<span class="cstat-no" title="statement not covered" >t.frontierDepth,</span>r=<span class="cstat-no" title="statement not covered" >t.parent,</span>o=<span class="cstat-no" title="statement not covered" >t.inject,</span>i=<span class="cstat-no" title="statement not covered" >t.wrap;<span class="cstat-no" title="statement not covered" ></span>while(this.depth&gt;n)<span class="cstat-no" title="statement not covered" >this.closeFrontierNode();<span class="cstat-no" title="statement not covered" >i</span></span>f(i)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >this.openFrontierNode(i[s]);v</span></span></span>ar a=<span class="cstat-no" title="statement not covered" >this.unplaced,</span>c=<span class="cstat-no" title="statement not covered" >r?r.content:a.content,</span>l=<span class="cstat-no" title="statement not covered" >a.openStart-e,</span>p=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >this.frontier[n],</span>d=<span class="cstat-no" title="statement not covered" >h.match,</span>f=<span class="cstat-no" title="statement not covered" >h.type;<span class="cstat-no" title="statement not covered" ></span>if(o){<span class="cstat-no" title="statement not covered" >for(var m=<span class="cstat-no" title="statement not covered" >0;</span>m&lt;o.childCount;m++)<span class="cstat-no" title="statement not covered" >u.push(o.child(m));<span class="cstat-no" title="statement not covered" >d</span></span>=d.matchFragment(o)}</span>v</span>ar v=<span class="cstat-no" title="statement not covered" >c.size+e-(a.content.size-a.openEnd);<span class="cstat-no" title="statement not covered" ></span>while(p&lt;c.childCount){var g=<span class="cstat-no" title="statement not covered" >c.child(p),</span>y=<span class="cstat-no" title="statement not covered" >d.matchType(g.type);<span class="cstat-no" title="statement not covered" ></span>if(!y)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >p</span></span>++,(p&gt;1||0==l||g.content.size)&amp;&amp;(d=y,u.push(Bo(g.mark(f.allowedMarks(g.marks)),1==p?l:0,p==c.childCount?v:-1)))}</span>v</span>ar b=<span class="cstat-no" title="statement not covered" >p==c.childCount;<span class="cstat-no" title="statement not covered" ></span>b||(v=-1),this.placed=Po(this.placed,n,Cn.from(u)),this.frontier[n].match=d,b&amp;&amp;v&lt;0&amp;&amp;r&amp;&amp;r.type==this.frontier[this.depth].type&amp;&amp;this.frontier.length&gt;1&amp;&amp;this.closeFrontierNode();<span class="cstat-no" title="statement not covered" >f</span>or(var w=<span class="cstat-no" title="statement not covered" >0,</span>O=<span class="cstat-no" title="statement not covered" >c;</span>w&lt;v;w++){var k=<span class="cstat-no" title="statement not covered" >O.lastChild;<span class="cstat-no" title="statement not covered" ></span>this.frontier.push({type:k.type,match:k.contentMatchAt(k.childCount)}),O=k.content}<span class="cstat-no" title="statement not covered" ></span>t</span>his.unplaced=b?0==e?Dn.empty:new Dn(_o(a.content,e-1,1),e-1,v&lt;0?a.openEnd:e-1):new Dn(_o(a.content,e,p),a.openStart,a.openEnd)}</span>,Do.prototype.mustMoveInline=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.$to.parent.isTextblock||this.$to.end()==this.$to.pos)<span class="cstat-no" title="statement not covered" >return-1;v</span></span>ar t,e=<span class="cstat-no" title="statement not covered" >this.frontier[this.depth];<span class="cstat-no" title="statement not covered" ></span>if(!e.type.isTextblock||!Lo(this.$to,this.$to.depth,e.type,e.match,!1)||this.$to.depth==this.depth&amp;&amp;(t=this.findCloseLevel(this.$to))&amp;&amp;t.depth==this.depth)<span class="cstat-no" title="statement not covered" >return-1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.$to,</span>r=<span class="cstat-no" title="statement not covered" >n.depth,</span>o=<span class="cstat-no" title="statement not covered" >this.$to.after(r);<span class="cstat-no" title="statement not covered" ></span>while(r&gt;1&amp;&amp;o==this.$to.end(--r))<span class="cstat-no" title="statement not covered" >++o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>,Do.prototype.findCloseLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t:<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >Math.min(this.depth,t.depth);</span>e&gt;=0;e--){var n=<span class="cstat-no" title="statement not covered" >this.frontier[e],</span>r=<span class="cstat-no" title="statement not covered" >n.match,</span>o=<span class="cstat-no" title="statement not covered" >n.type,</span>i=<span class="cstat-no" title="statement not covered" >e&lt;t.depth&amp;&amp;t.end(e+1)==t.pos+(t.depth-(e+1)),</span>s=<span class="cstat-no" title="statement not covered" >Lo(t,e,o,r,i);<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >e-1;</span>a&gt;=0;a--){var c=<span class="cstat-no" title="statement not covered" >this.frontier[a],</span>l=<span class="cstat-no" title="statement not covered" >c.match,</span>p=<span class="cstat-no" title="statement not covered" >c.type,</span>u=<span class="cstat-no" title="statement not covered" >Lo(t,a,p,l,!0);<span class="cstat-no" title="statement not covered" ></span>if(!u||u.childCount)<span class="cstat-no" title="statement not covered" >continue t}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{depth:e,fit:s,move:i?t.doc.resolve(t.after(e+1)):t}}</span>}</span>}</span></span>,Do.prototype.close=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.findCloseLevel(t);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >w</span></span>hile(this.depth&gt;e.depth)<span class="cstat-no" title="statement not covered" >this.closeFrontierNode();<span class="cstat-no" title="statement not covered" >e</span></span>.fit.childCount&amp;&amp;(this.placed=Po(this.placed,e.depth,e.fit)),t=e.move;<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >e.depth+1;</span>n&lt;=t.depth;n++){var r=<span class="cstat-no" title="statement not covered" >t.node(n),</span>o=<span class="cstat-no" title="statement not covered" >r.type.contentMatch.fillBefore(r.content,!0,t.index(n));<span class="cstat-no" title="statement not covered" ></span>this.openFrontierNode(r.type,r.attrs,o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,Do.prototype.openFrontierNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this.frontier[this.depth];<span class="cstat-no" title="statement not covered" ></span>r.match=r.match.matchType(t),this.placed=Po(this.placed,this.depth,Cn.from(t.create(e,n))),this.frontier.push({type:t,match:t.contentMatch})}</span>,Do.prototype.closeFrontierNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.frontier.pop(),</span>e=<span class="cstat-no" title="statement not covered" >t.match.fillBefore(Cn.empty,!0);<span class="cstat-no" title="statement not covered" ></span>e.childCount&amp;&amp;(this.placed=Po(this.placed,this.frontier.length,e))}</span>,Object.defineProperties(Do.prototype,Ro),so.prototype.replaceRange=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(!n.size)<span class="cstat-no" title="statement not covered" >return this.deleteRange(t,e);v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.doc.resolve(t),</span>o=<span class="cstat-no" title="statement not covered" >this.doc.resolve(e);<span class="cstat-no" title="statement not covered" ></span>if(Io(r,o,n))<span class="cstat-no" title="statement not covered" >return this.step(new ho(t,e,n));v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Fo(r,this.doc.resolve(e));<span class="cstat-no" title="statement not covered" ></span>0==i[i.length-1]&amp;&amp;i.pop();v</span>ar s=<span class="cstat-no" title="statement not covered" >-(r.depth+1);<span class="cstat-no" title="statement not covered" ></span>i.unshift(s);<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >r.depth,</span>c=<span class="cstat-no" title="statement not covered" >r.pos-1;</span>a&gt;0;a--,c--){var l=<span class="cstat-no" title="statement not covered" >r.node(a).type.spec;<span class="cstat-no" title="statement not covered" ></span>if(l.defining||l.isolating)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>.indexOf(a)&gt;-1?s=a:r.before(a)==c&amp;&amp;i.splice(1,0,-a)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var p=<span class="cstat-no" title="statement not covered" >i.indexOf(s),</span>u=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >n.openStart,</span>d=<span class="cstat-no" title="statement not covered" >n.content,</span>f=<span class="cstat-no" title="statement not covered" >0;</span>;f++){var m=<span class="cstat-no" title="statement not covered" >d.firstChild;<span class="cstat-no" title="statement not covered" ></span>if(u.push(m),f==n.openStart)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >d</span></span>=m.content}<span class="cstat-no" title="statement not covered" ></span>h</span>&gt;0&amp;&amp;u[h-1].type.spec.defining&amp;&amp;r.node(p).type!=u[h-1].type?h-=1:h&gt;=2&amp;&amp;u[h-1].isTextblock&amp;&amp;u[h-2].type.spec.defining&amp;&amp;r.node(p).type!=u[h-2].type&amp;&amp;(h-=2);<span class="cstat-no" title="statement not covered" >f</span>or(var v=<span class="cstat-no" title="statement not covered" >n.openStart;</span>v&gt;=0;v--){var g=<span class="cstat-no" title="statement not covered" >(v+h+1)%(n.openStart+1),</span>y=<span class="cstat-no" title="statement not covered" >u[g];<span class="cstat-no" title="statement not covered" ></span>if(y)<span class="cstat-no" title="statement not covered" >for(var b=<span class="cstat-no" title="statement not covered" >0;</span>b&lt;i.length;b++){var w=<span class="cstat-no" title="statement not covered" >i[(b+p)%i.length],</span>O=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>w&lt;0&amp;&amp;(O=!1,w=-w);v</span>ar k=<span class="cstat-no" title="statement not covered" >r.node(w-1),</span>x=<span class="cstat-no" title="statement not covered" >r.index(w-1);<span class="cstat-no" title="statement not covered" ></span>if(k.canReplaceWith(x,x,y.type,y.marks))<span class="cstat-no" title="statement not covered" >return this.replace(r.before(w),O?o.after(w):e,new Dn($o(n.content,0,n.openStart,g),g,n.openEnd))}</span></span>}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var S=<span class="cstat-no" title="statement not covered" >this.steps.length,</span>M=<span class="cstat-no" title="statement not covered" >i.length-1;</span>M&gt;=0;M--){<span class="cstat-no" title="statement not covered" >if(this.replace(t,e,n),this.steps.length&gt;S)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar C=<span class="cstat-no" title="statement not covered" >i[M];<span class="cstat-no" title="statement not covered" ></span>C&lt;0||(t=r.before(C),e=o.after(C))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>,so.prototype.replaceRangeWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(!n.isInline&amp;&amp;t==e&amp;&amp;this.doc.resolve(t).parent.content.size){var r=<span class="cstat-no" title="statement not covered" >Co(this.doc,t,n.type);<span class="cstat-no" title="statement not covered" ></span>null!=r&amp;&amp;(t=e=r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.replaceRange(t,e,new Dn(Cn.from(n),0,0))}</span>,so.prototype.deleteRange=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >this.doc.resolve(t),</span>r=<span class="cstat-no" title="statement not covered" >this.doc.resolve(e),</span>o=<span class="cstat-no" title="statement not covered" >Fo(n,r),</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;o.length;i++){var s=<span class="cstat-no" title="statement not covered" >o[i],</span>a=<span class="cstat-no" title="statement not covered" >i==o.length-1;<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;0==s||n.node(s).type.contentMatch.validEnd)<span class="cstat-no" title="statement not covered" >return this.delete(n.start(s),r.end(s));<span class="cstat-no" title="statement not covered" >i</span></span>f(s&gt;0&amp;&amp;(a||n.node(s-1).canReplace(n.index(s-1),r.indexAfter(s-1))))<span class="cstat-no" title="statement not covered" >return this.delete(n.before(s),r.after(s))}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var c=<span class="cstat-no" title="statement not covered" >1;</span>c&lt;=n.depth&amp;&amp;c&lt;=r.depth;c++)<span class="cstat-no" title="statement not covered" >if(t-n.start(c)==n.depth-c&amp;&amp;e&gt;n.end(c)&amp;&amp;r.end(c)-e!=r.depth-c)<span class="cstat-no" title="statement not covered" >return this.delete(n.before(c),e);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this.delete(t,e)}</span>;v</span>ar Ho=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>qo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.ranges=n||[new Wo(t.min(e),t.max(e))],this.$anchor=t,this.$head=e}</span>,</span>Jo=<span class="cstat-no" title="statement not covered" >{anchor:{configurable:!0},head:{configurable:!0},from:{configurable:!0},to:{configurable:!0},$from:{configurable:!0},$to:{configurable:!0},empty:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>Jo.anchor.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$anchor.pos}</span>,Jo.head.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$head.pos}</span>,Jo.from.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.pos}</span>,Jo.to.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$to.pos}</span>,Jo.$from.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.ranges[0].$from}</span>,Jo.$to.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.ranges[0].$to}</span>,Jo.empty.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >this.ranges,</span>e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(t[e].$from.pos!=t[e].$to.pos)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,qo.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.node(0).slice(this.from,this.to,!0)}</span>,qo.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=Dn.empty);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >e.content.lastChild,</span>r=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.openEnd;o++)<span class="cstat-no" title="statement not covered" >r=n,n=n.lastChild;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >t.steps.length,</span>s=<span class="cstat-no" title="statement not covered" >this.ranges,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;s.length;a++){var c=<span class="cstat-no" title="statement not covered" >s[a],</span>l=<span class="cstat-no" title="statement not covered" >c.$from,</span>p=<span class="cstat-no" title="statement not covered" >c.$to,</span>u=<span class="cstat-no" title="statement not covered" >t.mapping.slice(i);<span class="cstat-no" title="statement not covered" ></span>t.replaceRange(u.map(l.pos),u.map(p.pos),a?Dn.empty:e),0==a&amp;&amp;ti(t,i,(n?n.isInline:r&amp;&amp;r.isTextblock)?-1:1)}</span>}</span>,qo.prototype.replaceWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t.steps.length,</span>r=<span class="cstat-no" title="statement not covered" >this.ranges,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;r.length;o++){var i=<span class="cstat-no" title="statement not covered" >r[o],</span>s=<span class="cstat-no" title="statement not covered" >i.$from,</span>a=<span class="cstat-no" title="statement not covered" >i.$to,</span>c=<span class="cstat-no" title="statement not covered" >t.mapping.slice(n),</span>l=<span class="cstat-no" title="statement not covered" >c.map(s.pos),</span>p=<span class="cstat-no" title="statement not covered" >c.map(a.pos);<span class="cstat-no" title="statement not covered" ></span>o?t.deleteRange(l,p):(t.replaceRangeWith(l,p,e),ti(t,n,e.isInline?-1:1))}</span>}</span>,qo.findFrom=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.parent.inlineContent?new Ko(t):Zo(t.node(0),t.parent,t.pos,t.index(),e,n);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >t.depth-1;</span>o&gt;=0;o--){var i=<span class="cstat-no" title="statement not covered" >e&lt;0?Zo(t.node(0),t.node(o),t.before(o+1),t.index(o),e,n):Zo(t.node(0),t.node(o),t.after(o+1),t.index(o)+1,e,n);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i}</span></span>}</span>,qo.near=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=1),this.findFrom(t,e)||this.findFrom(t,-e)||new Xo(t.node(0))}</span>,qo.atStart=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Zo(t,t,0,0,1)||new Xo(t)}</span>,qo.atEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Zo(t,t,t.content.size,t.childCount,-1)||new Xo(t)}</span>,qo.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e||!e.type)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Selection.fromJSON");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >Ho[e.type];<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new RangeError("No selection type "+e.type+" defined");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.fromJSON(t,e)}</span>,qo.jsonID=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t in Ho)<span class="cstat-no" title="statement not covered" >throw new RangeError("Duplicate use of selection JSON ID "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Ho[t]=e,e.prototype.jsonID=t,e}</span>,qo.prototype.getBookmark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Ko.between(this.$anchor,this.$head).getBookmark()}</span>,Object.defineProperties(qo.prototype,Jo),qo.prototype.visible=!0;v</span>ar Wo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.$from=t,this.$to=e}</span>,</span>Ko=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=e),t.call(this,e,n)}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{$cursor:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return n.$cursor.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$anchor.pos==this.$head.pos?this.$head:null}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){var o=<span class="cstat-no" title="statement not covered" >n.resolve(r.map(this.head));<span class="cstat-no" title="statement not covered" ></span>if(!o.parent.inlineContent)<span class="cstat-no" title="statement not covered" >return t.near(o);v</span></span>ar i=<span class="cstat-no" title="statement not covered" >n.resolve(r.map(this.anchor));<span class="cstat-no" title="statement not covered" ></span>return new e(i.parent.inlineContent?i:o,o)}</span>,e.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(void 0===n&amp;&amp;(n=Dn.empty),t.prototype.replace.call(this,e,n),n==Dn.empty){var r=<span class="cstat-no" title="statement not covered" >this.$from.marksAcross(this.$to);<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;e.ensureMarks(r)}</span>}</span>,e.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof e&amp;&amp;t.anchor==this.anchor&amp;&amp;t.head==this.head}</span>,e.prototype.getBookmark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Uo(this.anchor,this.head)}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{type:"text",anchor:this.anchor,head:this.head}}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.anchor||"number"!=typeof n.head)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for TextSelection.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(t.resolve(n.anchor),t.resolve(n.head))}</span>,e.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=e);v</span>ar r=<span class="cstat-no" title="statement not covered" >t.resolve(e);<span class="cstat-no" title="statement not covered" ></span>return new this(r,n==e?r:t.resolve(n))}</span>,e.between=<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o){var i=<span class="cstat-no" title="statement not covered" >n.pos-r.pos;<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;!i||(o=i&gt;=0?1:-1),!r.parent.inlineContent){var s=<span class="cstat-no" title="statement not covered" >t.findFrom(r,o,!0)||t.findFrom(r,-o,!0);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return t.near(r,o);<span class="cstat-no" title="statement not covered" >r</span></span>=s.$head}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n.parent.inlineContent||(0==i?n=r:(n=(t.findFrom(n,-o,!0)||t.findFrom(n,o,!0)).$anchor,n.pos&lt;r.pos!=i&lt;0&amp;&amp;(n=r))),new e(n,r)}</span>,Object.defineProperties(e.prototype,n),e}</span>(qo);<span class="cstat-no" title="statement not covered" ></span>qo.jsonID("text",Ko);v</span>ar Uo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.anchor=t,this.head=e}</span>;<span class="cstat-no" title="statement not covered" ></span>Uo.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Uo(t.map(this.anchor),t.map(this.head))}</span>,Uo.prototype.resolve=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Ko.between(t.resolve(this.anchor),t.resolve(this.head))}</span>;v</span>ar Go=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e){var n=<span class="cstat-no" title="statement not covered" >e.nodeAfter,</span>r=<span class="cstat-no" title="statement not covered" >e.node(0).resolve(e.pos+n.nodeSize);<span class="cstat-no" title="statement not covered" ></span>t.call(this,e,r),this.node=n}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){var o=<span class="cstat-no" title="statement not covered" >r.mapResult(this.anchor),</span>i=<span class="cstat-no" title="statement not covered" >o.deleted,</span>s=<span class="cstat-no" title="statement not covered" >o.pos,</span>a=<span class="cstat-no" title="statement not covered" >n.resolve(s);<span class="cstat-no" title="statement not covered" ></span>return i?t.near(a):new e(a)}</span>,e.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Dn(Cn.from(this.node),0,0)}</span>,e.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof e&amp;&amp;t.anchor==this.anchor}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{type:"node",anchor:this.anchor}}</span>,e.prototype.getBookmark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Yo(this.anchor)}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.anchor)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for NodeSelection.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(t.resolve(n.anchor))}</span>,e.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new this(t.resolve(e))}</span>,e.isSelectable=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!t.isText&amp;&amp;!1!==t.type.spec.selectable}</span>,e}</span>(qo);<span class="cstat-no" title="statement not covered" ></span>Go.prototype.visible=!1,qo.jsonID("node",Go);v</span>ar Yo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.anchor=t}</span>;<span class="cstat-no" title="statement not covered" ></span>Yo.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.mapResult(this.anchor),</span>n=<span class="cstat-no" title="statement not covered" >e.deleted,</span>r=<span class="cstat-no" title="statement not covered" >e.pos;<span class="cstat-no" title="statement not covered" ></span>return n?new Uo(r,r):new Yo(r)}</span>,Yo.prototype.resolve=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.resolve(this.anchor),</span>n=<span class="cstat-no" title="statement not covered" >e.nodeAfter;<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;Go.isSelectable(n)?new Go(e):qo.near(e)}</span>;v</span>ar Xo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e){<span class="cstat-no" title="statement not covered" >t.call(this,e.resolve(0),e.resolve(e.content.size))}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(void 0===n&amp;&amp;(n=Dn.empty),n==Dn.empty){<span class="cstat-no" title="statement not covered" >e.delete(0,e.doc.content.size);v</span>ar r=<span class="cstat-no" title="statement not covered" >t.atStart(e.doc);<span class="cstat-no" title="statement not covered" ></span>r.eq(e.selection)||e.setSelection(r)}</span>else <span class="cstat-no" title="statement not covered" >t.prototype.replace.call(this,e,n)}</span></span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{type:"all"}}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new e(t)}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new e(t)}</span>,e.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof e}</span>,e.prototype.getBookmark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Qo}</span>,e}</span>(qo);<span class="cstat-no" title="statement not covered" ></span>qo.jsonID("all",Xo);v</span>ar Qo=<span class="cstat-no" title="statement not covered" >{map:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,resolve:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Xo(t)}</span>};</span>function <span class="fstat-no" title="function not covered" >Zo(</span>t,e,n,r,o,i){<span class="cstat-no" title="statement not covered" >if(e.inlineContent)<span class="cstat-no" title="statement not covered" >return Ko.create(t,n);<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >r-(o&gt;0?0:1);</span>o&gt;0?s&lt;e.childCount:s&gt;=0;s+=o){var a=<span class="cstat-no" title="statement not covered" >e.child(s);<span class="cstat-no" title="statement not covered" ></span>if(a.isAtom){<span class="cstat-no" title="statement not covered" >if(!i&amp;&amp;Go.isSelectable(a))<span class="cstat-no" title="statement not covered" >return Go.create(t,n-(o&lt;0?a.nodeSize:0))}</span></span>else{var c=<span class="cstat-no" title="statement not covered" >Zo(t,a,n+o,o&lt;0?a.childCount:0,o,i);<span class="cstat-no" title="statement not covered" ></span>if(c)<span class="cstat-no" title="statement not covered" >return c}<span class="cstat-no" title="statement not covered" ></span></span>n</span>+=a.nodeSize*o}</span>}</span>function <span class="fstat-no" title="function not covered" >ti(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.steps.length-1;<span class="cstat-no" title="statement not covered" ></span>if(!(r&lt;e)){var o=<span class="cstat-no" title="statement not covered" >t.steps[r];<span class="cstat-no" title="statement not covered" ></span>if(o instanceof ho||o instanceof fo){var i,s=<span class="cstat-no" title="statement not covered" >t.mapping.maps[r];<span class="cstat-no" title="statement not covered" ></span>s.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >null==i&amp;&amp;(i=r)}</span>)),t.setSelection(qo.near(t.doc.resolve(i),n))}</span>}</span>}</span>var ei=<span class="cstat-no" title="statement not covered" >1,</span>ni=<span class="cstat-no" title="statement not covered" >2,</span>ri=<span class="cstat-no" title="statement not covered" >4,</span>oi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e){<span class="cstat-no" title="statement not covered" >t.call(this,e.doc),this.time=Date.now(),this.curSelection=e.selection,this.curSelectionFor=0,this.storedMarks=e.storedMarks,this.updated=0,this.meta=Object.create(null)}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{selection:{configurable:!0},selectionSet:{configurable:!0},storedMarksSet:{configurable:!0},isGeneric:{configurable:!0},scrolledIntoView:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return n.selection.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.curSelectionFor&lt;this.steps.length&amp;&amp;(this.curSelection=this.curSelection.map(this.doc,this.mapping.slice(this.curSelectionFor)),this.curSelectionFor=this.steps.length),this.curSelection}</span>,e.prototype.setSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t.$from.doc!=this.doc)<span class="cstat-no" title="statement not covered" >throw new RangeError("Selection passed to setSelection must point at the current document");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.curSelection=t,this.curSelectionFor=this.steps.length,this.updated=(this.updated|ei)&amp;~ni,this.storedMarks=null,this}</span>,n.selectionSet.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.updated&amp;ei)&gt;0}</span>,e.prototype.setStoredMarks=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.storedMarks=t,this.updated|=ni,this}</span>,e.prototype.ensureMarks=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return An.sameSet(this.storedMarks||this.selection.$from.marks(),t)||this.setStoredMarks(t),this}</span>,e.prototype.addStoredMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.ensureMarks(t.addToSet(this.storedMarks||this.selection.$head.marks()))}</span>,e.prototype.removeStoredMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.ensureMarks(t.removeFromSet(this.storedMarks||this.selection.$head.marks()))}</span>,n.storedMarksSet.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.updated&amp;ni)&gt;0}</span>,e.prototype.addStep=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >t.prototype.addStep.call(this,e,n),this.updated=this.updated&amp;~ni,this.storedMarks=null}</span>,e.prototype.setTime=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.time=t,this}</span>,e.prototype.replaceSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.selection.replace(this,t),this}</span>,e.prototype.replaceSelectionWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this.selection;<span class="cstat-no" title="statement not covered" ></span>return!1!==e&amp;&amp;(t=t.mark(this.storedMarks||(n.empty?n.$from.marks():n.$from.marksAcross(n.$to)||An.none))),n.replaceWith(this,t),this}</span>,e.prototype.deleteSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.selection.replace(this),this}</span>,e.prototype.insertText=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=e);v</span>ar r=<span class="cstat-no" title="statement not covered" >this.doc.type.schema;<span class="cstat-no" title="statement not covered" ></span>if(null==e)<span class="cstat-no" title="statement not covered" >return t?this.replaceSelectionWith(r.text(t),!0):this.deleteSelection();<span class="cstat-no" title="statement not covered" >i</span></span>f(!t)<span class="cstat-no" title="statement not covered" >return this.deleteRange(e,n);v</span></span>ar o=<span class="cstat-no" title="statement not covered" >this.storedMarks;<span class="cstat-no" title="statement not covered" ></span>if(!o){var i=<span class="cstat-no" title="statement not covered" >this.doc.resolve(e);<span class="cstat-no" title="statement not covered" ></span>o=n==e?i.marks():i.marksAcross(this.doc.resolve(n))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.replaceRangeWith(e,n,r.text(t,o)),this.selection.empty||this.setSelection(qo.near(this.selection.$to)),this}</span>,e.prototype.setMeta=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.meta["string"==typeof t?t:t.key]=e,this}</span>,e.prototype.getMeta=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.meta["string"==typeof t?t:t.key]}</span>,n.isGeneric.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in this.meta)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!0}</span>,e.prototype.scrollIntoView=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.updated|=ri,this}</span>,n.scrolledIntoView.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.updated&amp;ri)&gt;0}</span>,Object.defineProperties(e.prototype,n),e}</span>(so);</span>function <span class="fstat-no" title="function not covered" >ii(</span>t,e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;t?t.bind(e):t}</span>var si=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.name=t,this.init=ii(e.init,n),this.apply=ii(e.apply,n)}</span>,</span>ai=<span class="cstat-no" title="statement not covered" >[new si("doc",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.doc||t.schema.topNodeType.createAndFill()}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.doc}</span>}),new si("selection",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.selection||qo.atStart(e.doc)}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.selection}</span>}),new si("storedMarks",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.storedMarks||null}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return r.selection.$cursor?t.storedMarks:null}</span>}),new si("scrollToSelection",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 0}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.scrolledIntoView?e+1:e}</span>})],</span>ci=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.schema=t,this.fields=ai.concat(),this.plugins=[],this.pluginsByKey=Object.create(null),e&amp;&amp;e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(n.pluginsByKey[t.key])<span class="cstat-no" title="statement not covered" >throw new RangeError("Adding different instances of a keyed plugin ("+t.key+")");<span class="cstat-no" title="statement not covered" >n</span></span>.plugins.push(t),n.pluginsByKey[t.key]=t,t.spec.state&amp;&amp;n.fields.push(new si(t.key,t.spec.state,t))}</span>))}</span>,</span>li=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.config=t}</span>,</span>pi=<span class="cstat-no" title="statement not covered" >{schema:{configurable:!0},plugins:{configurable:!0},tr:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>pi.schema.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.config.schema}</span>,pi.plugins.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.config.plugins}</span>,li.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.applyTransaction(t).state}</span>,li.prototype.filterTransaction=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=-1);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.config.plugins.length;n++)<span class="cstat-no" title="statement not covered" >if(n!=e){var r=<span class="cstat-no" title="statement not covered" >this.config.plugins[n];<span class="cstat-no" title="statement not covered" ></span>if(r.spec.filterTransaction&amp;&amp;!r.spec.filterTransaction.call(r,t,this))<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn!0}</span>,li.prototype.applyTransaction=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!this.filterTransaction(t))<span class="cstat-no" title="statement not covered" >return{state:this,transactions:[]};<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >[t],</span>n=<span class="cstat-no" title="statement not covered" >this.applyInner(t),</span>r=<span class="cstat-no" title="statement not covered" >null;</span>;){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.config.plugins.length;i++){var s=<span class="cstat-no" title="statement not covered" >this.config.plugins[i];<span class="cstat-no" title="statement not covered" ></span>if(s.spec.appendTransaction){var a=<span class="cstat-no" title="statement not covered" >r?r[i].n:0,</span>c=<span class="cstat-no" title="statement not covered" >r?r[i].state:this,</span>l=<span class="cstat-no" title="statement not covered" >a&lt;e.length&amp;&amp;s.spec.appendTransaction.call(s,a?e.slice(a):e,c,n);<span class="cstat-no" title="statement not covered" ></span>if(l&amp;&amp;n.filterTransaction(l,i)){<span class="cstat-no" title="statement not covered" >if(l.setMeta("appendedTransaction",t),!r){<span class="cstat-no" title="statement not covered" >r=[];<span class="cstat-no" title="statement not covered" >f</span>or(var p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;this.config.plugins.length;p++)<span class="cstat-no" title="statement not covered" >r.push(p&lt;i?{state:n,n:e.length}:{state:this,n:0})}<span class="cstat-no" title="statement not covered" ></span></span>e</span>.push(l),n=n.applyInner(l),o=!0}<span class="cstat-no" title="statement not covered" ></span>r</span>&amp;&amp;(r[i]={state:n,n:e.length})}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!o)<span class="cstat-no" title="statement not covered" >return{state:n,transactions:e}}</span></span>}</span>,li.prototype.applyInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t.before.eq(this.doc))<span class="cstat-no" title="statement not covered" >throw new RangeError("Applying a mismatched transaction");<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >new li(this.config),</span>n=<span class="cstat-no" title="statement not covered" >this.config.fields,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;n.length;r++){var o=<span class="cstat-no" title="statement not covered" >n[r];<span class="cstat-no" title="statement not covered" ></span>e[o.name]=o.apply(t,this[o.name],this,e)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;ui.length;i++)<span class="cstat-no" title="statement not covered" >ui[i](this,t,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,pi.tr.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new oi(this)}</span>,li.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >new ci(t.doc?t.doc.type.schema:t.schema,t.plugins),</span>n=<span class="cstat-no" title="statement not covered" >new li(e),</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.fields.length;r++)<span class="cstat-no" title="statement not covered" >n[e.fields[r].name]=e.fields[r].init(t,n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,li.prototype.reconfigure=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >new ci(this.schema,t.plugins),</span>n=<span class="cstat-no" title="statement not covered" >e.fields,</span>r=<span class="cstat-no" title="statement not covered" >new li(e),</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n.length;o++){var i=<span class="cstat-no" title="statement not covered" >n[o].name;<span class="cstat-no" title="statement not covered" ></span>r[i]=this.hasOwnProperty(i)?this[i]:n[o].init(t,r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>,li.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >{doc:this.doc.toJSON(),selection:this.selection.toJSON()};<span class="cstat-no" title="statement not covered" ></span>if(this.storedMarks&amp;&amp;(e.storedMarks=this.storedMarks.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toJSON()}</span>))),t&amp;&amp;"object"==typeof t)<span class="cstat-no" title="statement not covered" >for(var n in t){<span class="cstat-no" title="statement not covered" >if("doc"==n||"selection"==n)<span class="cstat-no" title="statement not covered" >throw new RangeError("The JSON fields `doc` and `selection` are reserved");v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t[n],</span>o=<span class="cstat-no" title="statement not covered" >r.spec.state;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;o.toJSON&amp;&amp;(e[n]=o.toJSON.call(r,this[r.key]))}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>,li.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for EditorState.fromJSON");<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.schema)<span class="cstat-no" title="statement not covered" >throw new RangeError("Required config field 'schema' missing");v</span></span>ar r=<span class="cstat-no" title="statement not covered" >new ci(t.schema,t.plugins),</span>o=<span class="cstat-no" title="statement not covered" >new li(r);<span class="cstat-no" title="statement not covered" ></span>return r.fields.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >if("doc"==r.name)<span class="cstat-no" title="statement not covered" >o.doc=er.fromJSON(t.schema,e.doc);e</span>lse <span class="cstat-no" title="statement not covered" >if("selection"==r.name)<span class="cstat-no" title="statement not covered" >o.selection=qo.fromJSON(o.doc,e.selection);e</span>lse <span class="cstat-no" title="statement not covered" >if("storedMarks"==r.name)<span class="cstat-no" title="statement not covered" >e.storedMarks&amp;&amp;(o.storedMarks=e.storedMarks.map(t.schema.markFromJSON));e</span>lse{<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >for(var i in n){var s=<span class="cstat-no" title="statement not covered" >n[i],</span>a=<span class="cstat-no" title="statement not covered" >s.spec.state;<span class="cstat-no" title="statement not covered" ></span>if(s.key==r.name&amp;&amp;a&amp;&amp;a.fromJSON&amp;&amp;Object.prototype.hasOwnProperty.call(e,i))<span class="cstat-no" title="statement not covered" >return void(o[r.name]=a.fromJSON.call(s,t,e[i],o))}<span class="cstat-no" title="statement not covered" ></span></span>o</span></span>[r.name]=r.init(t,o)}</span>}</span></span></span>)),o}</span>,li.addApplyListener=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >ui.push(t)}</span>,li.removeApplyListener=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >ui.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>e&gt;-1&amp;&amp;ui.splice(e,1)}</span>,Object.defineProperties(li.prototype,pi);v</span>ar ui=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >hi(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r in t){var o=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>o instanceof Function?o=o.bind(e):"handleDOMEvents"==r&amp;&amp;(o=hi(o,e,{})),n[r]=o}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>var di=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.props={},t.props&amp;&amp;hi(t.props,this,this.props),this.spec=t,this.key=t.key?t.key.key:mi("plugin")}</span>;<span class="cstat-no" title="statement not covered" ></span>di.prototype.getState=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t[this.key]}</span>;v</span>ar fi=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>function <span class="fstat-no" title="function not covered" >mi(</span>t){<span class="cstat-no" title="statement not covered" >return t in fi?t+"$"+ ++fi[t]:(fi[t]=0,t+"$")}</span>var vi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >void 0===t&amp;&amp;(t="key"),this.key=mi(t)}</span>;<span class="cstat-no" title="statement not covered" ></span>vi.prototype.get=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.config.pluginsByKey[this.key]}</span>,vi.prototype.getState=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t[this.key]}</span>;v</span>ar gi=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if("undefined"!=typeof navigator&amp;&amp;"undefined"!=typeof document){var yi=<span class="cstat-no" title="statement not covered" >/Edge\/(\d+)/.exec(navigator.userAgent),</span>bi=<span class="cstat-no" title="statement not covered" >/MSIE \d/.test(navigator.userAgent),</span>wi=<span class="cstat-no" title="statement not covered" >/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);<span class="cstat-no" title="statement not covered" ></span>gi.mac=/Mac/.test(navigator.platform);v</span>ar Oi=<span class="cstat-no" title="statement not covered" >gi.ie=!!(bi||wi||yi);<span class="cstat-no" title="statement not covered" ></span>gi.ie_version=bi?document.documentMode||6:wi?+wi[1]:yi?+yi[1]:null,gi.gecko=!Oi&amp;&amp;/gecko\/(\d+)/i.test(navigator.userAgent),gi.gecko_version=gi.gecko&amp;&amp;+(/Firefox\/(\d+)/.exec(navigator.userAgent)||[0,0])[1];v</span>ar ki=<span class="cstat-no" title="statement not covered" >!Oi&amp;&amp;/Chrome\/(\d+)/.exec(navigator.userAgent);<span class="cstat-no" title="statement not covered" ></span>gi.chrome=!!ki,gi.chrome_version=ki&amp;&amp;+ki[1],gi.safari=!Oi&amp;&amp;/Apple Computer/.test(navigator.vendor),gi.ios=gi.safari&amp;&amp;(/Mobile\/\w+/.test(navigator.userAgent)||navigator.maxTouchPoints&gt;2),gi.android=/Android \d/.test(navigator.userAgent),gi.webkit="webkitFontSmoothing"in document.documentElement.style,gi.webkit_version=gi.webkit&amp;&amp;+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]}</span>v</span>ar xi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>;e++)<span class="cstat-no" title="statement not covered" >if(t=t.previousSibling,!t)<span class="cstat-no" title="statement not covered" >return e}</span></span></span>,</span>Si=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.assignedSlot||t.parentNode;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;11==e.nodeType?e.host:e}</span>,</span>Mi=<span class="cstat-no" title="statement not covered" >null,</span>Ci=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >Mi||(Mi=document.createRange());<span class="cstat-no" title="statement not covered" ></span>return r.setEnd(t,null==n?t.nodeValue.length:n),r.setStart(t,e||0),r}</span>,</span>Ei=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return n&amp;&amp;(Ni(t,e,n,r,-1)||Ni(t,e,n,r,1))}</span>,</span>Ti=<span class="cstat-no" title="statement not covered" >/^(img|br|input|textarea|hr)$/i;</span>function <span class="fstat-no" title="function not covered" >Ni(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >for(;;){<span class="cstat-no" title="statement not covered" >if(t==n&amp;&amp;e==r)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(e==(o&lt;0?0:ji(t))){var i=<span class="cstat-no" title="statement not covered" >t.parentNode;<span class="cstat-no" title="statement not covered" ></span>if(1!=i.nodeType||Ii(t)||Ti.test(t.nodeName)||"false"==t.contentEditable)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >e</span></span>=xi(t)+(o&lt;0?0:1),t=i}</span>else{<span class="cstat-no" title="statement not covered" >if(1!=t.nodeType)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(t=t.childNodes[e+(o&lt;0?-1:0)],"false"==t.contentEditable)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >e</span></span>=o&lt;0?ji(t):0}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >ji(</span>t){<span class="cstat-no" title="statement not covered" >return 3==t.nodeType?t.nodeValue.length:t.childNodes.length}</span>function <span class="fstat-no" title="function not covered" >Ai(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0==e,</span>o=<span class="cstat-no" title="statement not covered" >e==ji(t);</span>r||o;){<span class="cstat-no" title="statement not covered" >if(t==n)<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >xi(t);<span class="cstat-no" title="statement not covered" ></span>if(t=t.parentNode,!t)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>=r&amp;&amp;0==i,o=o&amp;&amp;i==ji(t)}</span>}</span>function <span class="fstat-no" title="function not covered" >Ii(</span>t){<span class="cstat-no" title="statement not covered" >for(var e,n=<span class="cstat-no" title="statement not covered" >t;</span>n;n=n.parentNode)<span class="cstat-no" title="statement not covered" >if(e=n.pmViewDesc)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e&amp;&amp;e.node&amp;&amp;e.node.isBlock&amp;&amp;(e.dom==t||e.contentDOM==t)}</span>var Di=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.isCollapsed;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;gi.chrome&amp;&amp;t.rangeCount&amp;&amp;!t.getRangeAt(0).collapsed&amp;&amp;(e=!1),e}</span>;</span>function <span class="fstat-no" title="function not covered" >Ri(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >document.createEvent("Event");<span class="cstat-no" title="statement not covered" ></span>return n.initEvent("keydown",!0,!0),n.keyCode=t,n.key=n.code=e,n}</span>function <span class="fstat-no" title="function not covered" >_i(</span>t){<span class="cstat-no" title="statement not covered" >return{left:0,right:t.documentElement.clientWidth,top:0,bottom:t.documentElement.clientHeight}}</span>function <span class="fstat-no" title="function not covered" >Pi(</span>t,e){<span class="cstat-no" title="statement not covered" >return"number"==typeof t?t:t[e]}</span>function <span class="fstat-no" title="function not covered" >zi(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.getBoundingClientRect(),</span>n=<span class="cstat-no" title="statement not covered" >e.width/t.offsetWidth||1,</span>r=<span class="cstat-no" title="statement not covered" >e.height/t.offsetHeight||1;<span class="cstat-no" title="statement not covered" ></span>return{left:e.left,right:e.left+t.clientWidth*n,top:e.top,bottom:e.top+t.clientHeight*r}}</span>function <span class="fstat-no" title="function not covered" >Bi(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >t.someProp("scrollThreshold")||0,</span>o=<span class="cstat-no" title="statement not covered" >t.someProp("scrollMargin")||5,</span>i=<span class="cstat-no" title="statement not covered" >t.dom.ownerDocument,</span>s=<span class="cstat-no" title="statement not covered" >n||t.dom;</span>;s=Si(s)){<span class="cstat-no" title="statement not covered" >if(!s)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(1==s.nodeType){var a=<span class="cstat-no" title="statement not covered" >s==i.body||1!=s.nodeType,</span>c=<span class="cstat-no" title="statement not covered" >a?_i(i):zi(s),</span>l=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e.top&lt;c.top+Pi(r,"top")?p=-(c.top-e.top+Pi(o,"top")):e.bottom&gt;c.bottom-Pi(r,"bottom")&amp;&amp;(p=e.bottom-c.bottom+Pi(o,"bottom")),e.left&lt;c.left+Pi(r,"left")?l=-(c.left-e.left+Pi(o,"left")):e.right&gt;c.right-Pi(r,"right")&amp;&amp;(l=e.right-c.right+Pi(o,"right")),l||p)<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >i.defaultView.scrollBy(l,p);e</span>lse{var u=<span class="cstat-no" title="statement not covered" >s.scrollLeft,</span>h=<span class="cstat-no" title="statement not covered" >s.scrollTop;<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;(s.scrollTop+=p),l&amp;&amp;(s.scrollLeft+=l);v</span>ar d=<span class="cstat-no" title="statement not covered" >s.scrollLeft-u,</span>f=<span class="cstat-no" title="statement not covered" >s.scrollTop-h;<span class="cstat-no" title="statement not covered" ></span>e={left:e.left-d,top:e.top-f,right:e.right-d,bottom:e.bottom-f}}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(a)<span class="cstat-no" title="statement not covered" >break}</span></span>}</span>}</span>function <span class="fstat-no" title="function not covered" >Li(</span>t){<span class="cstat-no" title="statement not covered" >for(var e,n,r=<span class="cstat-no" title="statement not covered" >t.dom.getBoundingClientRect(),</span>o=<span class="cstat-no" title="statement not covered" >Math.max(0,r.top),</span>i=<span class="cstat-no" title="statement not covered" >(r.left+r.right)/2,</span>s=<span class="cstat-no" title="statement not covered" >o+1;</span>s&lt;Math.min(innerHeight,r.bottom);s+=5){var a=<span class="cstat-no" title="statement not covered" >t.root.elementFromPoint(i,s);<span class="cstat-no" title="statement not covered" ></span>if(a!=t.dom&amp;&amp;t.dom.contains(a)){var c=<span class="cstat-no" title="statement not covered" >a.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>if(c.top&gt;=o-20){<span class="cstat-no" title="statement not covered" >e=a,n=c.top;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{refDOM:e,refTop:n,stack:Vi(t.dom)}}</span>function <span class="fstat-no" title="function not covered" >Vi(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >t.ownerDocument;</span>t;t=Si(t))<span class="cstat-no" title="statement not covered" >if(e.push({dom:t,top:t.scrollTop,left:t.scrollLeft}),t==n)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >$i(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.refDOM,</span>n=<span class="cstat-no" title="statement not covered" >t.refTop,</span>r=<span class="cstat-no" title="statement not covered" >t.stack,</span>o=<span class="cstat-no" title="statement not covered" >e?e.getBoundingClientRect().top:0;<span class="cstat-no" title="statement not covered" ></span>Fi(r,0==o?0:o-n)}</span>function <span class="fstat-no" title="function not covered" >Fi(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++){var r=<span class="cstat-no" title="statement not covered" >t[n],</span>o=<span class="cstat-no" title="statement not covered" >r.dom,</span>i=<span class="cstat-no" title="statement not covered" >r.top,</span>s=<span class="cstat-no" title="statement not covered" >r.left;<span class="cstat-no" title="statement not covered" ></span>o.scrollTop!=i+e&amp;&amp;(o.scrollTop=i+e),o.scrollLeft!=s&amp;&amp;(o.scrollLeft=s)}</span>}</span>var Hi=<span class="cstat-no" title="statement not covered" >null;</span>function <span class="fstat-no" title="function not covered" >qi(</span>t){<span class="cstat-no" title="statement not covered" >if(t.setActive)<span class="cstat-no" title="statement not covered" >return t.setActive();<span class="cstat-no" title="statement not covered" >i</span></span>f(Hi)<span class="cstat-no" title="statement not covered" >return t.focus(Hi);v</span></span>ar e=<span class="cstat-no" title="statement not covered" >Vi(t);<span class="cstat-no" title="statement not covered" ></span>t.focus(null==Hi?{<span class="fstat-no" title="function not covered" >ge</span>t preventScroll(){<span class="cstat-no" title="statement not covered" >return Hi={preventScroll:!0},!0}</span>}:void 0),Hi||(Hi=!1,Fi(e,0))}</span>function <span class="fstat-no" title="function not covered" >Ji(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n,r,o=<span class="cstat-no" title="statement not covered" >2e8,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >e.top,</span>a=<span class="cstat-no" title="statement not covered" >e.top,</span>c=<span class="cstat-no" title="statement not covered" >t.firstChild,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>c;c=c.nextSibling,l++){var p=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>if(1==c.nodeType)<span class="cstat-no" title="statement not covered" >p=c.getClientRects();e</span>lse{<span class="cstat-no" title="statement not covered" >if(3!=c.nodeType)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >p</span></span>=Ci(c).getClientRects()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;p.length;u++){var h=<span class="cstat-no" title="statement not covered" >p[u];<span class="cstat-no" title="statement not covered" ></span>if(h.top&lt;=s&amp;&amp;h.bottom&gt;=a){<span class="cstat-no" title="statement not covered" >s=Math.max(h.bottom,s),a=Math.min(h.top,a);v</span>ar d=<span class="cstat-no" title="statement not covered" >h.left&gt;e.left?h.left-e.left:h.right&lt;e.left?e.left-h.right:0;<span class="cstat-no" title="statement not covered" ></span>if(d&lt;o){<span class="cstat-no" title="statement not covered" >n=c,o=d,r=d&amp;&amp;3==n.nodeType?{left:h.right&lt;e.left?h.right:h.left,top:e.top}:e,1==c.nodeType&amp;&amp;d&amp;&amp;(i=l+(e.left&gt;=(h.left+h.right)/2?1:0));<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>}<span class="cstat-no" title="statement not covered" ></span>!</span>n&amp;&amp;(e.left&gt;=h.right&amp;&amp;e.top&gt;=h.top||e.left&gt;=h.left&amp;&amp;e.top&gt;=h.bottom)&amp;&amp;(i=l+1)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n&amp;&amp;3==n.nodeType?Wi(n,r):!n||o&amp;&amp;1==n.nodeType?{node:t,offset:i}:Ji(n,r)}</span>function <span class="fstat-no" title="function not covered" >Wi(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t.nodeValue.length,</span>r=<span class="cstat-no" title="statement not covered" >document.createRange(),</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n;o++){<span class="cstat-no" title="statement not covered" >r.setEnd(t,o+1),r.setStart(t,o);v</span>ar i=<span class="cstat-no" title="statement not covered" >Zi(r,1);<span class="cstat-no" title="statement not covered" ></span>if(i.top!=i.bottom&amp;&amp;Ki(e,i))<span class="cstat-no" title="statement not covered" >return{node:t,offset:o+(e.left&gt;=(i.left+i.right)/2?1:0)}}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{node:t,offset:0}}</span>function <span class="fstat-no" title="function not covered" >Ki(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.left&gt;=e.left-1&amp;&amp;t.left&lt;=e.right+1&amp;&amp;t.top&gt;=e.top-1&amp;&amp;t.top&lt;=e.bottom+1}</span>function <span class="fstat-no" title="function not covered" >Ui(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.parentNode;<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;/^li$/i.test(n.nodeName)&amp;&amp;e.left&lt;t.getBoundingClientRect().left?n:t}</span>function <span class="fstat-no" title="function not covered" >Gi(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >Ji(e,n),</span>o=<span class="cstat-no" title="statement not covered" >r.node,</span>i=<span class="cstat-no" title="statement not covered" >r.offset,</span>s=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>if(1==o.nodeType&amp;&amp;!o.firstChild){var a=<span class="cstat-no" title="statement not covered" >o.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>s=a.left!=a.right&amp;&amp;n.left&gt;(a.left+a.right)/2?1:-1}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.docView.posFromDOM(o,i,s)}</span>function <span class="fstat-no" title="function not covered" >Yi(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >-1,</span>i=<span class="cstat-no" title="statement not covered" >e;</span>;){<span class="cstat-no" title="statement not covered" >if(i==t.dom)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >t.docView.nearestDesc(i,!0);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(s.node.isBlock&amp;&amp;s.parent){var a=<span class="cstat-no" title="statement not covered" >s.dom.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>if(a.left&gt;r.left||a.top&gt;r.top)<span class="cstat-no" title="statement not covered" >o=s.posBefore;e</span>lse{<span class="cstat-no" title="statement not covered" >if(!(a.right&lt;r.left||a.bottom&lt;r.top))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>=s.posAfter}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>=s.dom.parentNode}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o&gt;-1?o:t.docView.posFromDOM(e,n)}</span>function <span class="fstat-no" title="function not covered" >Xi(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.childNodes.length;<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;n.top&lt;n.bottom)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >Math.max(0,Math.min(r-1,Math.floor(r*(e.top-n.top)/(n.bottom-n.top))-2)),</span>i=<span class="cstat-no" title="statement not covered" >o;</span>;){var s=<span class="cstat-no" title="statement not covered" >t.childNodes[i];<span class="cstat-no" title="statement not covered" ></span>if(1==s.nodeType)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >s.getClientRects(),</span>c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;a.length;c++){var l=<span class="cstat-no" title="statement not covered" >a[c];<span class="cstat-no" title="statement not covered" ></span>if(Ki(e,l))<span class="cstat-no" title="statement not covered" >return Xi(s,e,l)}<span class="cstat-no" title="statement not covered" ></span></span>i</span></span>f((i=(i+1)%r)==o)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Qi(</span>t,e){var n,r,o,i,s=<span class="cstat-no" title="statement not covered" >t.root;<span class="cstat-no" title="statement not covered" ></span>if(s.caretPositionFromPoint)<span class="cstat-no" title="statement not covered" >try{var a=<span class="cstat-no" title="statement not covered" >s.caretPositionFromPoint(e.left,e.top);<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(n=a,o=n.offsetNode,i=n.offset)}</span>catch(v){}<span class="cstat-no" title="statement not covered" >i</span></span>f(!o&amp;&amp;s.caretRangeFromPoint){var c=<span class="cstat-no" title="statement not covered" >s.caretRangeFromPoint(e.left,e.top);<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;(r=c,o=r.startContainer,i=r.startOffset)}</span>v</span>ar l,p=<span class="cstat-no" title="statement not covered" >s.elementFromPoint(e.left,e.top+1);<span class="cstat-no" title="statement not covered" ></span>if(!p||!t.dom.contains(1!=p.nodeType?p.parentNode:p)){var u=<span class="cstat-no" title="statement not covered" >t.dom.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>if(!Ki(e,u))<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(p=Xi(t.dom,e,u),!p)<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(gi.safari)<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >p;</span>o&amp;&amp;h;h=Si(h))<span class="cstat-no" title="statement not covered" >h.draggable&amp;&amp;(o=i=null);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(p=Ui(p,e),o){<span class="cstat-no" title="statement not covered" >if(gi.gecko&amp;&amp;1==o.nodeType&amp;&amp;(i=Math.min(i,o.childNodes.length),i&lt;o.childNodes.length)){var d,f=<span class="cstat-no" title="statement not covered" >o.childNodes[i];<span class="cstat-no" title="statement not covered" ></span>"IMG"==f.nodeName&amp;&amp;(d=f.getBoundingClientRect()).right&lt;=e.left&amp;&amp;d.bottom&gt;e.top&amp;&amp;i++}<span class="cstat-no" title="statement not covered" ></span>o</span>==t.dom&amp;&amp;i==o.childNodes.length-1&amp;&amp;1==o.lastChild.nodeType&amp;&amp;e.top&gt;o.lastChild.getBoundingClientRect().bottom?l=t.state.doc.content.size:0!=i&amp;&amp;1==o.nodeType&amp;&amp;"BR"==o.childNodes[i-1].nodeName||(l=Yi(t,o,i,e))}<span class="cstat-no" title="statement not covered" ></span>n</span>ull==l&amp;&amp;(l=Gi(t,p,e));v</span>ar m=<span class="cstat-no" title="statement not covered" >t.docView.nearestDesc(p,!0);<span class="cstat-no" title="statement not covered" ></span>return{pos:l,inside:m?m.posAtStart-m.border:-1}}</span>function <span class="fstat-no" title="function not covered" >Zi(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.getClientRects();<span class="cstat-no" title="statement not covered" ></span>return n.length?n[e&lt;0?0:n.length-1]:t.getBoundingClientRect()}</span>var ts=<span class="cstat-no" title="statement not covered" >/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;</span>function <span class="fstat-no" title="function not covered" >es(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.docView.domFromPos(e,n&lt;0?-1:1),</span>o=<span class="cstat-no" title="statement not covered" >r.node,</span>i=<span class="cstat-no" title="statement not covered" >r.offset,</span>s=<span class="cstat-no" title="statement not covered" >gi.webkit||gi.gecko;<span class="cstat-no" title="statement not covered" ></span>if(3==o.nodeType){<span class="cstat-no" title="statement not covered" >if(!s||!ts.test(o.nodeValue)&amp;&amp;(n&lt;0?i:i!=o.nodeValue.length)){var a=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >i,</span>l=<span class="cstat-no" title="statement not covered" >n&lt;0?1:-1;<span class="cstat-no" title="statement not covered" ></span>return n&lt;0&amp;&amp;!i?(c++,l=-1):n&gt;=0&amp;&amp;i==o.nodeValue.length?(a--,l=1):n&lt;0?a--:c++,ns(Zi(Ci(o,a,c),l),l&lt;0)}</span>v</span>ar p=<span class="cstat-no" title="statement not covered" >Zi(Ci(o,i,i),n);<span class="cstat-no" title="statement not covered" ></span>if(gi.gecko&amp;&amp;i&amp;&amp;/\s/.test(o.nodeValue[i-1])&amp;&amp;i&lt;o.nodeValue.length){var u=<span class="cstat-no" title="statement not covered" >Zi(Ci(o,i-1,i-1),-1);<span class="cstat-no" title="statement not covered" ></span>if(u.top==p.top){var h=<span class="cstat-no" title="statement not covered" >Zi(Ci(o,i,i+1),-1);<span class="cstat-no" title="statement not covered" ></span>if(h.top!=p.top)<span class="cstat-no" title="statement not covered" >return ns(h,h.left&lt;u.left)}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn p}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!t.state.doc.resolve(e).parent.inlineContent){<span class="cstat-no" title="statement not covered" >if(i&amp;&amp;(n&lt;0||i==ji(o))){var d=<span class="cstat-no" title="statement not covered" >o.childNodes[i-1];<span class="cstat-no" title="statement not covered" ></span>if(1==d.nodeType)<span class="cstat-no" title="statement not covered" >return rs(d.getBoundingClientRect(),!1)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(i&lt;ji(o)){var f=<span class="cstat-no" title="statement not covered" >o.childNodes[i];<span class="cstat-no" title="statement not covered" ></span>if(1==f.nodeType)<span class="cstat-no" title="statement not covered" >return rs(f.getBoundingClientRect(),!0)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn rs(o.getBoundingClientRect(),n&gt;=0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i&amp;&amp;(n&lt;0||i==ji(o))){var m=<span class="cstat-no" title="statement not covered" >o.childNodes[i-1],</span>v=<span class="cstat-no" title="statement not covered" >3==m.nodeType?Ci(m,ji(m)-(s?0:1)):1!=m.nodeType||"BR"==m.nodeName&amp;&amp;m.nextSibling?null:m;<span class="cstat-no" title="statement not covered" ></span>if(v)<span class="cstat-no" title="statement not covered" >return ns(Zi(v,1),!1)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(i&lt;ji(o)){var g=<span class="cstat-no" title="statement not covered" >o.childNodes[i];<span class="cstat-no" title="statement not covered" ></span>while(g.pmViewDesc&amp;&amp;g.pmViewDesc.ignoreForCoords)<span class="cstat-no" title="statement not covered" >g=g.nextSibling;v</span></span>ar y=<span class="cstat-no" title="statement not covered" >g?3==g.nodeType?Ci(g,0,s?0:1):1==g.nodeType?g:null:null;<span class="cstat-no" title="statement not covered" ></span>if(y)<span class="cstat-no" title="statement not covered" >return ns(Zi(y,-1),!0)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn ns(Zi(3==o.nodeType?Ci(o):o,-n),n&gt;=0)}</span>function <span class="fstat-no" title="function not covered" >ns(</span>t,e){<span class="cstat-no" title="statement not covered" >if(0==t.width)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e?t.left:t.right;<span class="cstat-no" title="statement not covered" ></span>return{top:t.top,bottom:t.bottom,left:n,right:n}}</span>function <span class="fstat-no" title="function not covered" >rs(</span>t,e){<span class="cstat-no" title="statement not covered" >if(0==t.height)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e?t.top:t.bottom;<span class="cstat-no" title="statement not covered" ></span>return{top:n,bottom:n,left:t.left,right:t.right}}</span>function <span class="fstat-no" title="function not covered" >is(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.state,</span>o=<span class="cstat-no" title="statement not covered" >t.root.activeElement;<span class="cstat-no" title="statement not covered" ></span>r!=e&amp;&amp;t.updateState(e),o!=t.dom&amp;&amp;t.focus();<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return n()}</span>finally{<span class="cstat-no" title="statement not covered" >r!=e&amp;&amp;t.updateState(r),o!=t.dom&amp;&amp;o&amp;&amp;o.focus()}</span>}</span>function <span class="fstat-no" title="function not covered" >ss(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >e.selection,</span>o=<span class="cstat-no" title="statement not covered" >"up"==n?r.$from:r.$to;<span class="cstat-no" title="statement not covered" ></span>return is(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.docView.domFromPos(o.pos,"up"==n?-1:1),</span>r=<span class="cstat-no" title="statement not covered" >e.node;</span>;){var i=<span class="cstat-no" title="statement not covered" >t.docView.nearestDesc(r,!0);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(i.node.isBlock){<span class="cstat-no" title="statement not covered" >r=i.dom;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>=i.dom.parentNode}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var s=<span class="cstat-no" title="statement not covered" >es(t,o.pos,1),</span>a=<span class="cstat-no" title="statement not covered" >r.firstChild;</span>a;a=a.nextSibling){var c=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>if(1==a.nodeType)<span class="cstat-no" title="statement not covered" >c=a.getClientRects();e</span>lse{<span class="cstat-no" title="statement not covered" >if(3!=a.nodeType)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >c</span></span>=Ci(a,0,a.nodeValue.length).getClientRects()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;c.length;l++){var p=<span class="cstat-no" title="statement not covered" >c[l];<span class="cstat-no" title="statement not covered" ></span>if(p.bottom&gt;p.top+1&amp;&amp;("up"==n?s.top-p.top&gt;2*(p.bottom-s.top):p.bottom-s.bottom&gt;2*(s.bottom-p.top)))<span class="cstat-no" title="statement not covered" >return!1}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>))}</span>var as=<span class="cstat-no" title="statement not covered" >/[\u0590-\u08ac]/;</span>function <span class="fstat-no" title="function not covered" >cs(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >e.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.$head;<span class="cstat-no" title="statement not covered" ></span>if(!o.parent.isTextblock)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >o.parentOffset,</span>s=<span class="cstat-no" title="statement not covered" >!i,</span>a=<span class="cstat-no" title="statement not covered" >i==o.parent.content.size,</span>c=<span class="cstat-no" title="statement not covered" >t.root.getSelection();<span class="cstat-no" title="statement not covered" ></span>return as.test(o.parent.textContent)&amp;&amp;c.modify?is(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >c.getRangeAt(0),</span>r=<span class="cstat-no" title="statement not covered" >c.focusNode,</span>i=<span class="cstat-no" title="statement not covered" >c.focusOffset,</span>s=<span class="cstat-no" title="statement not covered" >c.caretBidiLevel;<span class="cstat-no" title="statement not covered" ></span>c.modify("move",n,"character");v</span>ar a=<span class="cstat-no" title="statement not covered" >o.depth?t.docView.domAfterPos(o.before()):t.dom,</span>l=<span class="cstat-no" title="statement not covered" >!a.contains(1==c.focusNode.nodeType?c.focusNode:c.focusNode.parentNode)||r==c.focusNode&amp;&amp;i==c.focusOffset;<span class="cstat-no" title="statement not covered" ></span>return c.removeAllRanges(),c.addRange(e),null!=s&amp;&amp;(c.caretBidiLevel=s),l}</span>)):"left"==n||"backward"==n?s:a}</span>var ls=<span class="cstat-no" title="statement not covered" >null,</span>ps=<span class="cstat-no" title="statement not covered" >null,</span>us=<span class="cstat-no" title="statement not covered" >!1;</span>function <span class="fstat-no" title="function not covered" >hs(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return ls==e&amp;&amp;ps==n?us:(ls=e,ps=n,us="up"==n||"down"==n?ss(t,e,n):cs(t,e,n))}</span>var ds=<span class="cstat-no" title="statement not covered" >0,</span>fs=<span class="cstat-no" title="statement not covered" >1,</span>ms=<span class="cstat-no" title="statement not covered" >2,</span>vs=<span class="cstat-no" title="statement not covered" >3,</span>gs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.parent=t,this.children=e,this.dom=n,n.pmViewDesc=this,this.contentDOM=r,this.dirty=ds}</span>,</span>ys=<span class="cstat-no" title="statement not covered" >{size:{configurable:!0},border:{configurable:!0},posBefore:{configurable:!0},posAtStart:{configurable:!0},posAfter:{configurable:!0},posAtEnd:{configurable:!0},contentLost:{configurable:!0},domAtom:{configurable:!0},ignoreForCoords:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>gs.prototype.matchesWidget=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>,gs.prototype.matchesMark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>,gs.prototype.matchesNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>,gs.prototype.matchesHack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!1}</span>,gs.prototype.parseRule=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return null}</span>,gs.prototype.stopEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>,ys.size.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.children.length;e++)<span class="cstat-no" title="statement not covered" >t+=this.children[e].size;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,ys.border.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 0}</span>,gs.prototype.destroy=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.parent=null,this.dom.pmViewDesc==this&amp;&amp;(this.dom.pmViewDesc=null);<span class="cstat-no" title="statement not covered" >f</span>or(var t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;this.children.length;t++)<span class="cstat-no" title="statement not covered" >this.children[t].destroy()}</span></span>,gs.prototype.posBeforeChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >this.posAtStart;</span>e&lt;this.children.length;e++){var r=<span class="cstat-no" title="statement not covered" >this.children[e];<span class="cstat-no" title="statement not covered" ></span>if(r==t)<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >n</span></span>+=r.size}</span>}</span>,ys.posBefore.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.parent.posBeforeChild(this)}</span>,ys.posAtStart.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.parent?this.parent.posBeforeChild(this)+this.border:0}</span>,ys.posAfter.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.posBefore+this.size}</span>,ys.posAtEnd.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.posAtStart+this.size-2*this.border}</span>,gs.prototype.localPosFromDOM=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(this.contentDOM&amp;&amp;this.contentDOM.contains(1==t.nodeType?t:t.parentNode)){<span class="cstat-no" title="statement not covered" >if(n&lt;0){var r,o;<span class="cstat-no" title="statement not covered" >if(t==this.contentDOM)<span class="cstat-no" title="statement not covered" >r=t.childNodes[e-1];e</span>lse{<span class="cstat-no" title="statement not covered" >while(t.parentNode!=this.contentDOM)<span class="cstat-no" title="statement not covered" >t=t.parentNode;<span class="cstat-no" title="statement not covered" >r</span></span>=t.previousSibling}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(r&amp;&amp;(!(o=r.pmViewDesc)||o.parent!=this))<span class="cstat-no" title="statement not covered" >r=r.previousSibling;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r?this.posBeforeChild(o)+o.size:this.posAtStart}</span>v</span>ar i,s;<span class="cstat-no" title="statement not covered" >if(t==this.contentDOM)<span class="cstat-no" title="statement not covered" >i=t.childNodes[e];e</span>lse{<span class="cstat-no" title="statement not covered" >while(t.parentNode!=this.contentDOM)<span class="cstat-no" title="statement not covered" >t=t.parentNode;<span class="cstat-no" title="statement not covered" >i</span></span>=t.nextSibling}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(i&amp;&amp;(!(s=i.pmViewDesc)||s.parent!=this))<span class="cstat-no" title="statement not covered" >i=i.nextSibling;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i?this.posBeforeChild(s):this.posAtEnd}</span>v</span>ar a;<span class="cstat-no" title="statement not covered" >if(t==this.dom&amp;&amp;this.contentDOM)<span class="cstat-no" title="statement not covered" >a=e&gt;xi(this.contentDOM);e</span>lse <span class="cstat-no" title="statement not covered" >if(this.contentDOM&amp;&amp;this.contentDOM!=this.dom&amp;&amp;this.dom.contains(this.contentDOM))<span class="cstat-no" title="statement not covered" >a=2&amp;t.compareDocumentPosition(this.contentDOM);e</span>lse <span class="cstat-no" title="statement not covered" >if(this.dom.firstChild){<span class="cstat-no" title="statement not covered" >if(0==e)<span class="cstat-no" title="statement not covered" >for(var c=<span class="cstat-no" title="statement not covered" >t;</span>;c=c.parentNode){<span class="cstat-no" title="statement not covered" >if(c==this.dom){<span class="cstat-no" title="statement not covered" >a=!1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(c.parentNode.firstChild!=c)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>i</span></span>f(null==a&amp;&amp;e==t.childNodes.length)<span class="cstat-no" title="statement not covered" >for(var l=<span class="cstat-no" title="statement not covered" >t;</span>;l=l.parentNode){<span class="cstat-no" title="statement not covered" >if(l==this.dom){<span class="cstat-no" title="statement not covered" >a=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l.parentNode.lastChild!=l)<span class="cstat-no" title="statement not covered" >break}</span></span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span></span>eturn(null==a?n&gt;0:a)?this.posAtEnd:this.posAtStart}</span>,gs.prototype.nearestDesc=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >!0,</span>r=<span class="cstat-no" title="statement not covered" >t;</span>r;r=r.parentNode){var o=<span class="cstat-no" title="statement not covered" >this.getDesc(r);<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;(!e||o.node)){<span class="cstat-no" title="statement not covered" >if(!n||!o.nodeDOM||(1==o.nodeDOM.nodeType?o.nodeDOM.contains(1==t.nodeType?t:t.parentNode):o.nodeDOM==t))<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >n</span></span>=!1}</span>}</span>}</span>,gs.prototype.getDesc=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.pmViewDesc,</span>n=<span class="cstat-no" title="statement not covered" >e;</span>n;n=n.parent)<span class="cstat-no" title="statement not covered" >if(n==this)<span class="cstat-no" title="statement not covered" >return e}</span></span></span>,gs.prototype.posFromDOM=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >t;</span>r;r=r.parentNode){var o=<span class="cstat-no" title="statement not covered" >this.getDesc(r);<span class="cstat-no" title="statement not covered" ></span>if(o)<span class="cstat-no" title="statement not covered" >return o.localPosFromDOM(t,e,n)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn-1}</span>,gs.prototype.descAt=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.children.length;e++){var r=<span class="cstat-no" title="statement not covered" >this.children[e],</span>o=<span class="cstat-no" title="statement not covered" >n+r.size;<span class="cstat-no" title="statement not covered" ></span>if(n==t&amp;&amp;o!=n){<span class="cstat-no" title="statement not covered" >while(!r.border&amp;&amp;r.children.length)<span class="cstat-no" title="statement not covered" >r=r.children[0];<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t&lt;o)<span class="cstat-no" title="statement not covered" >return r.descAt(t-n-r.border);<span class="cstat-no" title="statement not covered" >n</span></span>=o}</span>}</span>,gs.prototype.domFromPos=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!this.contentDOM)<span class="cstat-no" title="statement not covered" >return{node:this.dom,offset:0};<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.children.length;n++){var i=<span class="cstat-no" title="statement not covered" >this.children[n],</span>s=<span class="cstat-no" title="statement not covered" >o+i.size;<span class="cstat-no" title="statement not covered" ></span>if(s&gt;t||i instanceof Cs){<span class="cstat-no" title="statement not covered" >r=t-o;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>o</span>=s}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r)<span class="cstat-no" title="statement not covered" >return this.children[n].domFromPos(r-this.children[n].border,e);<span class="cstat-no" title="statement not covered" >f</span></span>or(var a=<span class="cstat-no" title="statement not covered" >void 0;</span>n&amp;&amp;!(a=this.children[n-1]).size&amp;&amp;a instanceof ws&amp;&amp;a.widget.type.side&gt;=0;n--);<span class="cstat-no" title="statement not covered" >i</span>f(e&lt;=0){<span class="cstat-no" title="statement not covered" >for(var c,l=<span class="cstat-no" title="statement not covered" >!0;</span>;n--,l=!1)<span class="cstat-no" title="statement not covered" >if(c=n?this.children[n-1]:null,!c||c.dom.parentNode==this.contentDOM)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn c&amp;&amp;e&amp;&amp;l&amp;&amp;!c.border&amp;&amp;!c.domAtom?c.domFromPos(c.size,e):{node:this.contentDOM,offset:c?xi(c.dom)+1:0}}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var p,u=<span class="cstat-no" title="statement not covered" >!0;</span>;n++,u=!1)<span class="cstat-no" title="statement not covered" >if(p=n&lt;this.children.length?this.children[n]:null,!p||p.dom.parentNode==this.contentDOM)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn p&amp;&amp;u&amp;&amp;!p.border&amp;&amp;!p.domAtom?p.domFromPos(0,e):{node:this.contentDOM,offset:p?xi(p.dom):this.contentDOM.childNodes.length}}</span>,gs.prototype.parseRange=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(void 0===n&amp;&amp;(n=0),0==this.children.length)<span class="cstat-no" title="statement not covered" >return{node:this.contentDOM,from:t,to:e,fromOffset:0,toOffset:this.contentDOM.childNodes.length};<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=<span class="cstat-no" title="statement not covered" >-1,</span>o=<span class="cstat-no" title="statement not covered" >-1,</span>i=<span class="cstat-no" title="statement not covered" >n,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>;s++){var a=<span class="cstat-no" title="statement not covered" >this.children[s],</span>c=<span class="cstat-no" title="statement not covered" >i+a.size;<span class="cstat-no" title="statement not covered" ></span>if(-1==r&amp;&amp;t&lt;=c){var l=<span class="cstat-no" title="statement not covered" >i+a.border;<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=l&amp;&amp;e&lt;=c-a.border&amp;&amp;a.node&amp;&amp;a.contentDOM&amp;&amp;this.contentDOM.contains(a.contentDOM))<span class="cstat-no" title="statement not covered" >return a.parseRange(t,e,l);<span class="cstat-no" title="statement not covered" >t</span></span>=i;<span class="cstat-no" title="statement not covered" >f</span>or(var p=<span class="cstat-no" title="statement not covered" >s;</span>p&gt;0;p--){var u=<span class="cstat-no" title="statement not covered" >this.children[p-1];<span class="cstat-no" title="statement not covered" ></span>if(u.size&amp;&amp;u.dom.parentNode==this.contentDOM&amp;&amp;!u.emptyChildAt(1)){<span class="cstat-no" title="statement not covered" >r=xi(u.dom)+1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span>-=u.size}<span class="cstat-no" title="statement not covered" ></span>-</span>1==r&amp;&amp;(r=0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r&gt;-1&amp;&amp;(c&gt;e||s==this.children.length-1)){<span class="cstat-no" title="statement not covered" >e=c;<span class="cstat-no" title="statement not covered" >f</span>or(var h=<span class="cstat-no" title="statement not covered" >s+1;</span>h&lt;this.children.length;h++){var d=<span class="cstat-no" title="statement not covered" >this.children[h];<span class="cstat-no" title="statement not covered" ></span>if(d.size&amp;&amp;d.dom.parentNode==this.contentDOM&amp;&amp;!d.emptyChildAt(-1)){<span class="cstat-no" title="statement not covered" >o=xi(d.dom);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>e</span>+=d.size}<span class="cstat-no" title="statement not covered" ></span>-</span>1==o&amp;&amp;(o=this.contentDOM.childNodes.length);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>=c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{node:this.contentDOM,from:t,to:e,fromOffset:r,toOffset:o}}</span>,gs.prototype.emptyChildAt=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.border||!this.contentDOM||!this.children.length)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.children[t&lt;0?0:this.children.length-1];<span class="cstat-no" title="statement not covered" ></span>return 0==e.size||e.emptyChildAt(t)}</span>,gs.prototype.domAfterPos=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.domFromPos(t,0),</span>n=<span class="cstat-no" title="statement not covered" >e.node,</span>r=<span class="cstat-no" title="statement not covered" >e.offset;<span class="cstat-no" title="statement not covered" ></span>if(1!=n.nodeType||r==n.childNodes.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("No node after pos "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.childNodes[r]}</span>,gs.prototype.setSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >Math.min(t,e),</span>i=<span class="cstat-no" title="statement not covered" >Math.max(t,e),</span>s=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;this.children.length;s++){var c=<span class="cstat-no" title="statement not covered" >this.children[s],</span>l=<span class="cstat-no" title="statement not covered" >a+c.size;<span class="cstat-no" title="statement not covered" ></span>if(o&gt;a&amp;&amp;i&lt;l)<span class="cstat-no" title="statement not covered" >return c.setSelection(t-a-c.border,e-a-c.border,n,r);<span class="cstat-no" title="statement not covered" >a</span></span>=l}</span>v</span>ar p=<span class="cstat-no" title="statement not covered" >this.domFromPos(t,t?-1:1),</span>u=<span class="cstat-no" title="statement not covered" >e==t?p:this.domFromPos(e,e?-1:1),</span>h=<span class="cstat-no" title="statement not covered" >n.getSelection(),</span>d=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if((gi.gecko||gi.safari)&amp;&amp;t==e){var f=<span class="cstat-no" title="statement not covered" >p.node,</span>m=<span class="cstat-no" title="statement not covered" >p.offset;<span class="cstat-no" title="statement not covered" ></span>if(3==f.nodeType){<span class="cstat-no" title="statement not covered" >if(d=m&amp;&amp;"\n"==f.nodeValue[m-1],d&amp;&amp;m==f.nodeValue.length)<span class="cstat-no" title="statement not covered" >for(var v=<span class="cstat-no" title="statement not covered" >f,</span>g=<span class="cstat-no" title="statement not covered" >void 0;</span>v;v=v.parentNode){<span class="cstat-no" title="statement not covered" >if(g=v.nextSibling){<span class="cstat-no" title="statement not covered" >"BR"==g.nodeName&amp;&amp;(p=u={node:g.parentNode,offset:xi(g)+1});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>v</span>ar y=<span class="cstat-no" title="statement not covered" >v.pmViewDesc;<span class="cstat-no" title="statement not covered" ></span>if(y&amp;&amp;y.node&amp;&amp;y.node.isBlock)<span class="cstat-no" title="statement not covered" >break}</span></span>}</span></span>else{var b=<span class="cstat-no" title="statement not covered" >f.childNodes[m-1];<span class="cstat-no" title="statement not covered" ></span>d=b&amp;&amp;("BR"==b.nodeName||"false"==b.contentEditable)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(gi.gecko&amp;&amp;h.focusNode&amp;&amp;h.focusNode!=u.node&amp;&amp;1==h.focusNode.nodeType){var w=<span class="cstat-no" title="statement not covered" >h.focusNode.childNodes[h.focusOffset];<span class="cstat-no" title="statement not covered" ></span>w&amp;&amp;"false"==w.contentEditable&amp;&amp;(r=!0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r||d&amp;&amp;gi.safari||!Ei(p.node,p.offset,h.anchorNode,h.anchorOffset)||!Ei(u.node,u.offset,h.focusNode,h.focusOffset)){var O=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if((h.extend||t==e)&amp;&amp;!d){<span class="cstat-no" title="statement not covered" >h.collapse(p.node,p.offset);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >t!=e&amp;&amp;h.extend(u.node,u.offset),O=!0}</span>catch(S){<span class="cstat-no" title="statement not covered" >if(!(S instanceof DOMException))<span class="cstat-no" title="statement not covered" >throw S}</span></span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!O){<span class="cstat-no" title="statement not covered" >if(t&gt;e){var k=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>p=u,u=k}</span>v</span>ar x=<span class="cstat-no" title="statement not covered" >document.createRange();<span class="cstat-no" title="statement not covered" ></span>x.setEnd(u.node,u.offset),x.setStart(p.node,p.offset),h.removeAllRanges(),h.addRange(x)}</span>}</span>}</span>,gs.prototype.ignoreMutation=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!this.contentDOM&amp;&amp;"selection"!=t.type}</span>,ys.contentLost.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.contentDOM&amp;&amp;this.contentDOM!=this.dom&amp;&amp;!this.dom.contains(this.contentDOM)}</span>,gs.prototype.markDirty=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.children.length;r++){var o=<span class="cstat-no" title="statement not covered" >this.children[r],</span>i=<span class="cstat-no" title="statement not covered" >n+o.size;<span class="cstat-no" title="statement not covered" ></span>if(n==i?t&lt;=i&amp;&amp;e&gt;=n:t&lt;i&amp;&amp;e&gt;n){var s=<span class="cstat-no" title="statement not covered" >n+o.border,</span>a=<span class="cstat-no" title="statement not covered" >i-o.border;<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=s&amp;&amp;e&lt;=a)<span class="cstat-no" title="statement not covered" >return this.dirty=t==n||e==i?ms:fs,void(t!=s||e!=a||!o.contentLost&amp;&amp;o.dom.parentNode==this.contentDOM?o.markDirty(t-s,e-s):o.dirty=vs);<span class="cstat-no" title="statement not covered" >o</span></span>.dirty=o.dom==o.contentDOM&amp;&amp;o.dom.parentNode==this.contentDOM?ms:vs}<span class="cstat-no" title="statement not covered" ></span>n</span>=i}<span class="cstat-no" title="statement not covered" ></span>t</span>his.dirty=ms}</span>,gs.prototype.markParentsDirty=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >1,</span>e=<span class="cstat-no" title="statement not covered" >this.parent;</span>e;e=e.parent,t++){var n=<span class="cstat-no" title="statement not covered" >1==t?ms:fs;<span class="cstat-no" title="statement not covered" ></span>e.dirty&lt;n&amp;&amp;(e.dirty=n)}</span>}</span>,ys.domAtom.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>,ys.ignoreForCoords.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>,Object.defineProperties(gs.prototype,ys);v</span>ar bs=<span class="cstat-no" title="statement not covered" >[],</span>ws=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o){var i,s=<span class="cstat-no" title="statement not covered" >n.type.toDOM;<span class="cstat-no" title="statement not covered" ></span>if("function"==typeof s&amp;&amp;(s=s(r,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i?i.parent?i.parent.posBeforeChild(i):void 0:o}</span>))),!n.type.spec.raw){<span class="cstat-no" title="statement not covered" >if(1!=s.nodeType){var a=<span class="cstat-no" title="statement not covered" >document.createElement("span");<span class="cstat-no" title="statement not covered" ></span>a.appendChild(s),s=a}<span class="cstat-no" title="statement not covered" ></span>s</span>.contentEditable=!1,s.classList.add("ProseMirror-widget")}<span class="cstat-no" title="statement not covered" ></span>t</span>.call(this,e,bs,s,null),this.widget=n,i=this}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{domAtom:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return e.prototype.matchesWidget=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.dirty==ds&amp;&amp;t.type.eq(this.widget.type)}</span>,e.prototype.parseRule=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{ignore:!0}}</span>,e.prototype.stopEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.widget.spec.stopEvent;<span class="cstat-no" title="statement not covered" ></span>return!!e&amp;&amp;e(t)}</span>,e.prototype.ignoreMutation=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"selection"!=t.type||this.widget.spec.ignoreSelection}</span>,n.domAtom.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!0}</span>,Object.defineProperties(e.prototype,n),e}</span>(gs),</span>Os=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o){<span class="cstat-no" title="statement not covered" >t.call(this,e,bs,n,null),this.textDOM=r,this.text=o}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{size:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return n.size.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.text.length}</span>,e.prototype.localPosFromDOM=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t!=this.textDOM?this.posAtStart+(e?this.size:0):this.posAtStart+e}</span>,e.prototype.domFromPos=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{node:this.textDOM,offset:t}}</span>,e.prototype.ignoreMutation=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"characterData"===t.type&amp;&amp;t.target.nodeValue==t.oldValue}</span>,Object.defineProperties(e.prototype,n),e}</span>(gs),</span>ks=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o){<span class="cstat-no" title="statement not covered" >t.call(this,e,[],r,o),this.mark=n}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,r,o){var i=<span class="cstat-no" title="statement not covered" >o.nodeViews[n.type.name],</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i(n,o,r);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;s.dom||(s=Ur.renderSpec(document,n.type.spec.toDOM(n,r))),new e(t,n,s.dom,s.contentDOM||s.dom)}</span>,e.prototype.parseRule=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{mark:this.mark.type.name,attrs:this.mark.attrs,contentElement:this.contentDOM}}</span>,e.prototype.matchesMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.dirty!=vs&amp;&amp;this.mark.eq(t)}</span>,e.prototype.markDirty=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(t.prototype.markDirty.call(this,e,n),this.dirty!=ds){var r=<span class="cstat-no" title="statement not covered" >this.parent;<span class="cstat-no" title="statement not covered" ></span>while(!r.node)<span class="cstat-no" title="statement not covered" >r=r.parent;<span class="cstat-no" title="statement not covered" >r</span></span>.dirty&lt;this.dirty&amp;&amp;(r.dirty=this.dirty),this.dirty=ds}</span>}</span>,e.prototype.slice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,r){var o=<span class="cstat-no" title="statement not covered" >e.create(this.parent,this.mark,!0,r),</span>i=<span class="cstat-no" title="statement not covered" >this.children,</span>s=<span class="cstat-no" title="statement not covered" >this.size;<span class="cstat-no" title="statement not covered" ></span>n&lt;s&amp;&amp;(i=qs(i,n,s,r)),t&gt;0&amp;&amp;(i=qs(i,0,t,r));<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length;a++)<span class="cstat-no" title="statement not covered" >i[a].parent=o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o.children=i,o}</span>,e}</span>(gs),</span>xs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o,i,s,a,c,l){<span class="cstat-no" title="statement not covered" >t.call(this,e,n.isLeaf?bs:[],i,s),this.nodeDOM=a,this.node=n,this.outerDeco=r,this.innerDeco=o,s&amp;&amp;this.updateChildren(c,l)}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{size:{configurable:!0},border:{configurable:!0},domAtom:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return e.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,r,o,i,s){var a,c,l=<span class="cstat-no" title="statement not covered" >i.nodeViews[n.type.name],</span>p=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l(n,i,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return c?c.parent?c.parent.posBeforeChild(c):void 0:s}</span>),r,o),</span>u=<span class="cstat-no" title="statement not covered" >p&amp;&amp;p.dom,</span>h=<span class="cstat-no" title="statement not covered" >p&amp;&amp;p.contentDOM;<span class="cstat-no" title="statement not covered" ></span>if(n.isText)<span class="cstat-no" title="statement not covered" >if(u){<span class="cstat-no" title="statement not covered" >if(3!=u.nodeType)<span class="cstat-no" title="statement not covered" >throw new RangeError("Text must be rendered as a DOM text node")}</span></span>else <span class="cstat-no" title="statement not covered" >u=document.createTextNode(n.text);e</span></span>lse <span class="cstat-no" title="statement not covered" >u||(a=Ur.renderSpec(document,n.type.spec.toDOM(n)),u=a.dom,h=a.contentDOM);<span class="cstat-no" title="statement not covered" >h</span></span>||n.isText||"BR"==u.nodeName||(u.hasAttribute("contenteditable")||(u.contentEditable=!1),n.type.spec.draggable&amp;&amp;(u.draggable=!0));v</span>ar d=<span class="cstat-no" title="statement not covered" >u;<span class="cstat-no" title="statement not covered" ></span>return u=Rs(u,r,n),p?c=new Es(t,n,r,o,u,h,d,p,i,s+1):n.isText?new Ms(t,n,r,o,u,d,i):new e(t,n,r,o,u,h,d,i,s+1)}</span>,e.prototype.parseRule=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.node.type.spec.reparseInView)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >{node:this.node.type.name,attrs:this.node.attrs};<span class="cstat-no" title="statement not covered" ></span>return this.node.type.spec.code&amp;&amp;(e.preserveWhitespace="full"),this.contentDOM&amp;&amp;!this.contentLost?e.contentElement=this.contentDOM:e.getContent=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.contentDOM?Cn.empty:t.node.content}</span>,e}</span>,e.prototype.matchesNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return this.dirty==ds&amp;&amp;t.eq(this.node)&amp;&amp;_s(e,this.outerDeco)&amp;&amp;n.eq(this.innerDeco)}</span>,n.size.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node.nodeSize}</span>,n.border.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node.isLeaf?0:1}</span>,e.prototype.updateChildren=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >this.node.inlineContent,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>i=<span class="cstat-no" title="statement not covered" >t.composing&amp;&amp;this.localCompositionInfo(t,e),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.pos&gt;-1?i:null,</span>a=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.pos&lt;0,</span>c=<span class="cstat-no" title="statement not covered" >new zs(this,s&amp;&amp;s.node);<span class="cstat-no" title="statement not covered" ></span>Vs(this.node,this.innerDeco,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,i,s){<span class="cstat-no" title="statement not covered" >e.spec.marks?c.syncToMarks(e.spec.marks,r,t):e.type.side&gt;=0&amp;&amp;!s&amp;&amp;c.syncToMarks(i==n.node.childCount?An.none:n.node.child(i).marks,r,t),c.placeWidget(e,t,o)}</span>),(<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,s,l){var p;<span class="cstat-no" title="statement not covered" >c.syncToMarks(e.marks,r,t),c.findNodeMatch(e,n,s,l)||a&amp;&amp;t.state.selection.from&gt;o&amp;&amp;t.state.selection.to&lt;o+e.nodeSize&amp;&amp;(p=c.findIndexWithChild(i.node))&gt;-1&amp;&amp;c.updateNodeAt(e,n,s,p,t)||c.updateNextNode(e,n,s,t,l)||c.addNode(e,n,s,t,o),o+=e.nodeSize}</span>)),c.syncToMarks(bs,r,t),this.node.isTextblock&amp;&amp;c.addTextblockHacks(),c.destroyRest(),(c.changed||this.dirty==ms)&amp;&amp;(s&amp;&amp;this.protectLocalComposition(t,s),Ts(this.contentDOM,this.children,t),gi.ios&amp;&amp;$s(this.dom))}</span>,e.prototype.localCompositionInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >t.state.selection,</span>r=<span class="cstat-no" title="statement not covered" >n.from,</span>o=<span class="cstat-no" title="statement not covered" >n.to;<span class="cstat-no" title="statement not covered" ></span>if(!(!(t.state.selection instanceof Ko)||r&lt;e||o&gt;e+this.node.content.size)){var i=<span class="cstat-no" title="statement not covered" >t.root.getSelection(),</span>s=<span class="cstat-no" title="statement not covered" >Fs(i.focusNode,i.focusOffset);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;this.dom.contains(s.parentNode)){<span class="cstat-no" title="statement not covered" >if(this.node.inlineContent){var a=<span class="cstat-no" title="statement not covered" >s.nodeValue,</span>c=<span class="cstat-no" title="statement not covered" >Hs(this.node.content,a,r-e,o-e);<span class="cstat-no" title="statement not covered" ></span>return c&lt;0?null:{node:s,pos:c,text:a}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{node:s,pos:-1}}</span>}</span>}</span>,e.prototype.protectLocalComposition=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >e.node,</span>r=<span class="cstat-no" title="statement not covered" >e.pos,</span>o=<span class="cstat-no" title="statement not covered" >e.text;<span class="cstat-no" title="statement not covered" ></span>if(!this.getDesc(n)){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >n;</span>;i=i.parentNode){<span class="cstat-no" title="statement not covered" >if(i.parentNode==this.contentDOM)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >w</span></span>hile(i.previousSibling)<span class="cstat-no" title="statement not covered" >i.parentNode.removeChild(i.previousSibling);<span class="cstat-no" title="statement not covered" >w</span></span>hile(i.nextSibling)<span class="cstat-no" title="statement not covered" >i.parentNode.removeChild(i.nextSibling);<span class="cstat-no" title="statement not covered" >i</span></span>.pmViewDesc&amp;&amp;(i.pmViewDesc=null)}</span>v</span>ar s=<span class="cstat-no" title="statement not covered" >new Os(this,i,n,o);<span class="cstat-no" title="statement not covered" ></span>t.compositionNodes.push(s),this.children=qs(this.children,r,r+o.length,t,s)}</span>}</span>,e.prototype.update=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return!(this.dirty==vs||!t.sameMarkup(this.node))&amp;&amp;(this.updateInner(t,e,n,r),!0)}</span>,e.prototype.updateInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.updateOuterDeco(e),this.node=t,this.innerDeco=n,this.contentDOM&amp;&amp;this.updateChildren(r,this.posAtStart),this.dirty=ds}</span>,e.prototype.updateOuterDeco=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!_s(t,this.outerDeco)){var e=<span class="cstat-no" title="statement not covered" >1!=this.nodeDOM.nodeType,</span>n=<span class="cstat-no" title="statement not covered" >this.dom;<span class="cstat-no" title="statement not covered" ></span>this.dom=Is(this.dom,this.nodeDOM,As(this.outerDeco,this.node,e),As(t,this.node,e)),this.dom!=n&amp;&amp;(n.pmViewDesc=null,this.dom.pmViewDesc=this),this.outerDeco=t}</span>}</span>,e.prototype.selectNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.nodeDOM.classList.add("ProseMirror-selectednode"),!this.contentDOM&amp;&amp;this.node.type.spec.draggable||(this.dom.draggable=!0)}</span>,e.prototype.deselectNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.nodeDOM.classList.remove("ProseMirror-selectednode"),!this.contentDOM&amp;&amp;this.node.type.spec.draggable||this.dom.removeAttribute("draggable")}</span>,n.domAtom.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node.isAtom}</span>,Object.defineProperties(e.prototype,n),e}</span>(gs);</span>function <span class="fstat-no" title="function not covered" >Ss(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >return Rs(r,e,t),new xs(null,t,e,n,r,r,r,o,0)}</span>var Ms=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o,i,s,a){<span class="cstat-no" title="statement not covered" >t.call(this,e,n,r,o,i,null,s,a)}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{domAtom:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return e.prototype.parseRule=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.nodeDOM.parentNode;<span class="cstat-no" title="statement not covered" ></span>while(t&amp;&amp;t!=this.dom&amp;&amp;!t.pmIsDeco)<span class="cstat-no" title="statement not covered" >t=t.parentNode;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{skip:t||!0}}</span>,e.prototype.update=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return!(this.dirty==vs||this.dirty!=ds&amp;&amp;!this.inParent()||!t.sameMarkup(this.node))&amp;&amp;(this.updateOuterDeco(e),this.dirty==ds&amp;&amp;t.text==this.node.text||t.text==this.nodeDOM.nodeValue||(this.nodeDOM.nodeValue=t.text,r.trackWrites==this.nodeDOM&amp;&amp;(r.trackWrites=null)),this.node=t,this.dirty=ds,!0)}</span>,e.prototype.inParent=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >this.parent.contentDOM,</span>e=<span class="cstat-no" title="statement not covered" >this.nodeDOM;</span>e;e=e.parentNode)<span class="cstat-no" title="statement not covered" >if(e==t)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>,e.prototype.domFromPos=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{node:this.nodeDOM,offset:t}}</span>,e.prototype.localPosFromDOM=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r){<span class="cstat-no" title="statement not covered" >return e==this.nodeDOM?this.posAtStart+Math.min(n,this.node.text.length):t.prototype.localPosFromDOM.call(this,e,n,r)}</span>,e.prototype.ignoreMutation=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"characterData"!=t.type&amp;&amp;"selection"!=t.type}</span>,e.prototype.slice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,r){var o=<span class="cstat-no" title="statement not covered" >this.node.cut(t,n),</span>i=<span class="cstat-no" title="statement not covered" >document.createTextNode(o.text);<span class="cstat-no" title="statement not covered" ></span>return new e(this.parent,o,this.outerDeco,this.innerDeco,i,i,r)}</span>,e.prototype.markDirty=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >t.prototype.markDirty.call(this,e,n),this.dom==this.nodeDOM||0!=e&amp;&amp;n!=this.nodeDOM.nodeValue.length||(this.dirty=vs)}</span>,n.domAtom.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!1}</span>,Object.defineProperties(e.prototype,n),e}</span>(xs),</span>Cs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>){<span class="cstat-no" title="statement not covered" >t.apply(this,arguments)}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{domAtom:{configurable:!0},ignoreForCoords:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return e.prototype.parseRule=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{ignore:!0}}</span>,e.prototype.matchesHack=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.dirty==ds&amp;&amp;this.dom.nodeName==t}</span>,n.domAtom.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!0}</span>,n.ignoreForCoords.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"IMG"==this.dom.nodeName}</span>,Object.defineProperties(e.prototype,n),e}</span>(gs),</span>Es=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o,i,s,a,c,l,p){<span class="cstat-no" title="statement not covered" >t.call(this,e,n,r,o,i,s,a,l,p),this.spec=c}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.update=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r,o){<span class="cstat-no" title="statement not covered" >if(this.dirty==vs)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.spec.update){var i=<span class="cstat-no" title="statement not covered" >this.spec.update(e,n,r);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;this.updateInner(e,n,r,o),i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!(!this.contentDOM&amp;&amp;!e.isLeaf)&amp;&amp;t.prototype.update.call(this,e,n,r,o)}</span>,e.prototype.selectNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.spec.selectNode?this.spec.selectNode():t.prototype.selectNode.call(this)}</span>,e.prototype.deselectNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.spec.deselectNode?this.spec.deselectNode():t.prototype.deselectNode.call(this)}</span>,e.prototype.setSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r,o){<span class="cstat-no" title="statement not covered" >this.spec.setSelection?this.spec.setSelection(e,n,r):t.prototype.setSelection.call(this,e,n,r,o)}</span>,e.prototype.destroy=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.spec.destroy&amp;&amp;this.spec.destroy(),t.prototype.destroy.call(this)}</span>,e.prototype.stopEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!!this.spec.stopEvent&amp;&amp;this.spec.stopEvent(t)}</span>,e.prototype.ignoreMutation=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return this.spec.ignoreMutation?this.spec.ignoreMutation(e):t.prototype.ignoreMutation.call(this,e)}</span>,e}</span>(xs);</span>function <span class="fstat-no" title="function not covered" >Ts(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >t.firstChild,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length;i++){var s=<span class="cstat-no" title="statement not covered" >e[i],</span>a=<span class="cstat-no" title="statement not covered" >s.dom;<span class="cstat-no" title="statement not covered" ></span>if(a.parentNode==t){<span class="cstat-no" title="statement not covered" >while(a!=r)<span class="cstat-no" title="statement not covered" >r=Ps(r),o=!0;<span class="cstat-no" title="statement not covered" >r</span></span>=r.nextSibling}</span>else <span class="cstat-no" title="statement not covered" >o=!0,t.insertBefore(a,r);<span class="cstat-no" title="statement not covered" >i</span></span>f(s instanceof ks){var c=<span class="cstat-no" title="statement not covered" >r?r.previousSibling:t.lastChild;<span class="cstat-no" title="statement not covered" ></span>Ts(s.contentDOM,s.children,n),r=c?c.nextSibling:t.firstChild}</span>}<span class="cstat-no" title="statement not covered" ></span>w</span>hile(r)<span class="cstat-no" title="statement not covered" >r=Ps(r),o=!0;<span class="cstat-no" title="statement not covered" >o</span></span>&amp;&amp;n.trackWrites==t&amp;&amp;(n.trackWrites=null)}</span>function <span class="fstat-no" title="function not covered" >Ns(</span>t){<span class="cstat-no" title="statement not covered" >t&amp;&amp;(this.nodeName=t)}<span class="cstat-no" title="statement not covered" ></span>Ns.prototype=Object.create(null);v</span>ar js=<span class="cstat-no" title="statement not covered" >[new Ns];</span>function <span class="fstat-no" title="function not covered" >As(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(0==t.length)<span class="cstat-no" title="statement not covered" >return js;<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=<span class="cstat-no" title="statement not covered" >n?js[0]:new Ns,</span>o=<span class="cstat-no" title="statement not covered" >[r],</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.length;i++){var s=<span class="cstat-no" title="statement not covered" >t[i].type.attrs;<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >for(var a in s.nodeName&amp;&amp;o.push(r=new Ns(s.nodeName)),s){var c=<span class="cstat-no" title="statement not covered" >s[a];<span class="cstat-no" title="statement not covered" ></span>null!=c&amp;&amp;(n&amp;&amp;1==o.length&amp;&amp;o.push(r=new Ns(e.isInline?"span":"div")),"class"==a?r.class=(r.class?r.class+" ":"")+c:"style"==a?r.style=(r.style?r.style+";":"")+c:"nodeName"!=a&amp;&amp;(r[a]=c))}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn o}</span>function <span class="fstat-no" title="function not covered" >Is(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >if(n==js&amp;&amp;r==js)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >e,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;r.length;i++){var s=<span class="cstat-no" title="statement not covered" >r[i],</span>a=<span class="cstat-no" title="statement not covered" >n[i];<span class="cstat-no" title="statement not covered" ></span>if(i){var c=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;a.nodeName==s.nodeName&amp;&amp;o!=t&amp;&amp;(c=o.parentNode)&amp;&amp;c.tagName.toLowerCase()==s.nodeName||(c=document.createElement(s.nodeName),c.pmIsDeco=!0,c.appendChild(o),a=js[0]),o=c}<span class="cstat-no" title="statement not covered" ></span>D</span>s(o,a||js[0],s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>function <span class="fstat-no" title="function not covered" >Ds(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >"class"==r||"style"==r||"nodeName"==r||r in n||t.removeAttribute(r);<span class="cstat-no" title="statement not covered" >f</span></span>or(var o in n)<span class="cstat-no" title="statement not covered" >"class"!=o&amp;&amp;"style"!=o&amp;&amp;"nodeName"!=o&amp;&amp;n[o]!=e[o]&amp;&amp;t.setAttribute(o,n[o]);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.class!=n.class){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >e.class?e.class.split(" ").filter(Boolean):bs,</span>s=<span class="cstat-no" title="statement not covered" >n.class?n.class.split(" ").filter(Boolean):bs,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length;a++)<span class="cstat-no" title="statement not covered" >-1==s.indexOf(i[a])&amp;&amp;t.classList.remove(i[a]);<span class="cstat-no" title="statement not covered" >f</span></span>or(var c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;s.length;c++)<span class="cstat-no" title="statement not covered" >-1==i.indexOf(s[c])&amp;&amp;t.classList.add(s[c])}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(e.style!=n.style){<span class="cstat-no" title="statement not covered" >if(e.style){var l,p=<span class="cstat-no" title="statement not covered" >/\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g;<span class="cstat-no" title="statement not covered" ></span>while(l=p.exec(e.style))<span class="cstat-no" title="statement not covered" >t.style.removeProperty(l[1])}<span class="cstat-no" title="statement not covered" ></span></span>n</span>.style&amp;&amp;(t.style.cssText+=n.style)}</span>}</span>function <span class="fstat-no" title="function not covered" >Rs(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return Is(t,t,js,As(e,n,1!=t.nodeType))}</span>function <span class="fstat-no" title="function not covered" >_s(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.length!=e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >if(!t[n].type.eq(e[n].type))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >Ps(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.nextSibling;<span class="cstat-no" title="statement not covered" ></span>return t.parentNode.removeChild(t),e}</span>var zs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.top=t,this.lock=e,this.index=0,this.stack=[],this.changed=!1,this.preMatch=Bs(t.node.content,t.children)}</span>;</span>function <span class="fstat-no" title="function not covered" >Bs(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t.childCount,</span>r=<span class="cstat-no" title="statement not covered" >e.length,</span>o=<span class="cstat-no" title="statement not covered" >new Map;</span>n&gt;0&amp;&amp;r&gt;0;r--){var i=<span class="cstat-no" title="statement not covered" >e[r-1],</span>s=<span class="cstat-no" title="statement not covered" >i.node;<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >if(s!=t.child(n-1))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >-</span></span>-n,o.set(i,n)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{index:n,matched:o}}</span>function <span class="fstat-no" title="function not covered" >Ls(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.type.side-e.type.side}</span>function <span class="fstat-no" title="function not covered" >Vs(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >e.locals(t),</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(0!=o.length)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >null,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>;){<span class="cstat-no" title="statement not covered" >if(s&lt;o.length&amp;&amp;o[s].to==i){var p=<span class="cstat-no" title="statement not covered" >o[s++],</span>u=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>while(s&lt;o.length&amp;&amp;o[s].to==i)<span class="cstat-no" title="statement not covered" >(u||(u=[p])).push(o[s++]);<span class="cstat-no" title="statement not covered" >i</span></span>f(u){<span class="cstat-no" title="statement not covered" >u.sort(Ls);<span class="cstat-no" title="statement not covered" >f</span>or(var h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;u.length;h++)<span class="cstat-no" title="statement not covered" >n(u[h],l,!!c)}</span></span>else <span class="cstat-no" title="statement not covered" >n(p,l,!!c)}</span></span>v</span>ar d=<span class="cstat-no" title="statement not covered" >void 0,</span>f=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>if(c)<span class="cstat-no" title="statement not covered" >f=-1,d=c,c=null;e</span>lse{<span class="cstat-no" title="statement not covered" >if(!(l&lt;t.childCount))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >f</span></span>=l,d=t.child(l++)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var m=<span class="cstat-no" title="statement not covered" >0;</span>m&lt;a.length;m++)<span class="cstat-no" title="statement not covered" >a[m].to&lt;=i&amp;&amp;a.splice(m--,1);<span class="cstat-no" title="statement not covered" >w</span></span>hile(s&lt;o.length&amp;&amp;o[s].from&lt;=i&amp;&amp;o[s].to&gt;i)<span class="cstat-no" title="statement not covered" >a.push(o[s++]);v</span></span>ar v=<span class="cstat-no" title="statement not covered" >i+d.nodeSize;<span class="cstat-no" title="statement not covered" ></span>if(d.isText){var g=<span class="cstat-no" title="statement not covered" >v;<span class="cstat-no" title="statement not covered" ></span>s&lt;o.length&amp;&amp;o[s].from&lt;g&amp;&amp;(g=o[s].from);<span class="cstat-no" title="statement not covered" >f</span>or(var y=<span class="cstat-no" title="statement not covered" >0;</span>y&lt;a.length;y++)<span class="cstat-no" title="statement not covered" >a[y].to&lt;g&amp;&amp;(g=a[y].to);<span class="cstat-no" title="statement not covered" >g</span></span>&lt;v&amp;&amp;(c=d.cut(g-i),d=d.cut(0,g-i),v=g,f=-1)}</span>v</span>ar b=<span class="cstat-no" title="statement not covered" >a.length?d.isInline&amp;&amp;!d.isLeaf?a.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!t.inline}</span>)):a.slice():bs;<span class="cstat-no" title="statement not covered" ></span>r(d,b,e.forChild(i,d),f),i=v}</span>e</span>lse <span class="cstat-no" title="statement not covered" >for(var w=<span class="cstat-no" title="statement not covered" >0;</span>w&lt;t.childCount;w++){var O=<span class="cstat-no" title="statement not covered" >t.child(w);<span class="cstat-no" title="statement not covered" ></span>r(O,o,e.forChild(i,O),w),i+=O.nodeSize}</span>}</span></span>function <span class="fstat-no" title="function not covered" >$s(</span>t){<span class="cstat-no" title="statement not covered" >if("UL"==t.nodeName||"OL"==t.nodeName){var e=<span class="cstat-no" title="statement not covered" >t.style.cssText;<span class="cstat-no" title="statement not covered" ></span>t.style.cssText=e+"; list-style: square !important",window.getComputedStyle(t).listStyle,t.style.cssText=e}</span>}</span>function <span class="fstat-no" title="function not covered" >Fs(</span>t,e){<span class="cstat-no" title="statement not covered" >for(;;){<span class="cstat-no" title="statement not covered" >if(3==t.nodeType)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(1==t.nodeType&amp;&amp;e&gt;0){<span class="cstat-no" title="statement not covered" >if(t.childNodes.length&gt;e&amp;&amp;3==t.childNodes[e].nodeType)<span class="cstat-no" title="statement not covered" >return t.childNodes[e];<span class="cstat-no" title="statement not covered" >t</span></span>=t.childNodes[e-1],e=ji(t)}</span>else{<span class="cstat-no" title="statement not covered" >if(!(1==t.nodeType&amp;&amp;e&lt;t.childNodes.length))<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span></span>=t.childNodes[e],e=0}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >Hs(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t.childCount&amp;&amp;i&lt;=r;){var s=<span class="cstat-no" title="statement not covered" >t.child(o++),</span>a=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(i+=s.nodeSize,s.isText){var c=<span class="cstat-no" title="statement not covered" >s.text;<span class="cstat-no" title="statement not covered" ></span>while(o&lt;t.childCount){var l=<span class="cstat-no" title="statement not covered" >t.child(o++);<span class="cstat-no" title="statement not covered" ></span>if(i+=l.nodeSize,!l.isText)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >c</span></span>+=l.text}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i&gt;=n){var p=<span class="cstat-no" title="statement not covered" >c.lastIndexOf(e,r-a);<span class="cstat-no" title="statement not covered" ></span>if(p&gt;=0&amp;&amp;p+e.length+a&gt;=n)<span class="cstat-no" title="statement not covered" >return a+p}</span></span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn-1}</span>function <span class="fstat-no" title="function not covered" >qs(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t.length;s++){var c=<span class="cstat-no" title="statement not covered" >t[s],</span>l=<span class="cstat-no" title="statement not covered" >a,</span>p=<span class="cstat-no" title="statement not covered" >a+=c.size;<span class="cstat-no" title="statement not covered" ></span>l&gt;=n||p&lt;=e?i.push(c):(l&lt;e&amp;&amp;i.push(c.slice(0,e-l,r)),o&amp;&amp;(i.push(o),o=null),p&gt;n&amp;&amp;i.push(c.slice(n-l,c.size,r)))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Js(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.root.getSelection(),</span>r=<span class="cstat-no" title="statement not covered" >t.state.doc;<span class="cstat-no" title="statement not covered" ></span>if(!n.focusNode)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t.docView.nearestDesc(n.focusNode),</span>i=<span class="cstat-no" title="statement not covered" >o&amp;&amp;0==o.size,</span>s=<span class="cstat-no" title="statement not covered" >t.docView.posFromDOM(n.focusNode,n.focusOffset);<span class="cstat-no" title="statement not covered" ></span>if(s&lt;0)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar a,c,l=<span class="cstat-no" title="statement not covered" >r.resolve(s);<span class="cstat-no" title="statement not covered" ></span>if(Di(n)){<span class="cstat-no" title="statement not covered" >a=l;<span class="cstat-no" title="statement not covered" >w</span>hile(o&amp;&amp;!o.node)<span class="cstat-no" title="statement not covered" >o=o.parent;<span class="cstat-no" title="statement not covered" >i</span></span>f(o&amp;&amp;o.node.isAtom&amp;&amp;Go.isSelectable(o.node)&amp;&amp;o.parent&amp;&amp;(!o.node.isInline||!Ai(n.focusNode,n.focusOffset,o.dom))){var p=<span class="cstat-no" title="statement not covered" >o.posBefore;<span class="cstat-no" title="statement not covered" ></span>c=new Go(s==p?l:r.resolve(p))}</span>}</span>else{var u=<span class="cstat-no" title="statement not covered" >t.docView.posFromDOM(n.anchorNode,n.anchorOffset);<span class="cstat-no" title="statement not covered" ></span>if(u&lt;0)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >a</span></span>=r.resolve(u)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!c){var h=<span class="cstat-no" title="statement not covered" >"pointer"==e||t.state.selection.head&lt;l.pos&amp;&amp;!i?1:-1;<span class="cstat-no" title="statement not covered" ></span>c=na(t,a,l,h)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn c}</span>function <span class="fstat-no" title="function not covered" >Ws(</span>t){<span class="cstat-no" title="statement not covered" >return t.editable?t.hasFocus():oa(t)&amp;&amp;document.activeElement&amp;&amp;document.activeElement.contains(t.dom)}</span>function <span class="fstat-no" title="function not covered" >Ks(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.state.selection;<span class="cstat-no" title="statement not covered" ></span>if(ta(t,n),Ws(t)){<span class="cstat-no" title="statement not covered" >if(!e&amp;&amp;t.mouseDown&amp;&amp;t.mouseDown.allowDefault)<span class="cstat-no" title="statement not covered" >return t.mouseDown.delayedSelectionSync=!0,void t.domObserver.setCurSelection();<span class="cstat-no" title="statement not covered" >i</span></span>f(t.domObserver.disconnectSelection(),t.cursorWrapper)<span class="cstat-no" title="statement not covered" >Zs(t);e</span>lse{var r,o,i=<span class="cstat-no" title="statement not covered" >n.anchor,</span>s=<span class="cstat-no" title="statement not covered" >n.head;<span class="cstat-no" title="statement not covered" ></span>!Us||n instanceof Ko||(n.$from.parent.inlineContent||(r=Gs(t,n.from)),n.empty||n.$from.parent.inlineContent||(o=Gs(t,n.to))),t.docView.setSelection(i,s,t.root,e),Us&amp;&amp;(r&amp;&amp;Xs(r),o&amp;&amp;Xs(o)),n.visible?t.dom.classList.remove("ProseMirror-hideselection"):(t.dom.classList.add("ProseMirror-hideselection"),"onselectionchange"in document&amp;&amp;Qs(t))}<span class="cstat-no" title="statement not covered" ></span>t</span>.domObserver.setCurSelection(),t.domObserver.connectSelection()}</span>}<span class="cstat-no" title="statement not covered" ></span>zs.prototype.destroyBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t!=e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t;</span>n&lt;e;n++)<span class="cstat-no" title="statement not covered" >this.top.children[n].destroy();<span class="cstat-no" title="statement not covered" >t</span></span>his.top.children.splice(t,e-t),this.changed=!0}</span>}</span>,zs.prototype.destroyRest=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.destroyBetween(this.index,this.top.children.length)}</span>,zs.prototype.syncToMarks=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >this.stack.length&gt;&gt;1,</span>i=<span class="cstat-no" title="statement not covered" >Math.min(o,t.length);<span class="cstat-no" title="statement not covered" ></span>while(r&lt;i&amp;&amp;(r==o-1?this.top:this.stack[r+1&lt;&lt;1]).matchesMark(t[r])&amp;&amp;!1!==t[r].type.spec.spanning)<span class="cstat-no" title="statement not covered" >r++;<span class="cstat-no" title="statement not covered" >w</span></span>hile(r&lt;o)<span class="cstat-no" title="statement not covered" >this.destroyRest(),this.top.dirty=ds,this.index=this.stack.pop(),this.top=this.stack.pop(),o--;<span class="cstat-no" title="statement not covered" >w</span></span>hile(o&lt;t.length){<span class="cstat-no" title="statement not covered" >this.stack.push(this.top,this.index+1);<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >-1,</span>a=<span class="cstat-no" title="statement not covered" >this.index;</span>a&lt;Math.min(this.index+3,this.top.children.length);a++)<span class="cstat-no" title="statement not covered" >if(this.top.children[a].matchesMark(t[o])){<span class="cstat-no" title="statement not covered" >s=a;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(s&gt;-1)<span class="cstat-no" title="statement not covered" >s&gt;this.index&amp;&amp;(this.changed=!0,this.destroyBetween(this.index,s)),this.top=this.top.children[this.index];e</span>lse{var c=<span class="cstat-no" title="statement not covered" >ks.create(this.top,t[o],e,n);<span class="cstat-no" title="statement not covered" ></span>this.top.children.splice(this.index,0,c),this.top=c,this.changed=!0}<span class="cstat-no" title="statement not covered" ></span>t</span>his.index=0,o++}</span>}</span>,zs.prototype.findNodeMatch=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >this.top.children,</span>i=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>if(r&gt;=this.preMatch.index){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >this.index;</span>s&lt;o.length;s++)<span class="cstat-no" title="statement not covered" >if(o[s].matchesNode(t,e,n)){<span class="cstat-no" title="statement not covered" >i=s;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >this.index,</span>c=<span class="cstat-no" title="statement not covered" >Math.min(o.length,a+1);</span>a&lt;c;a++){var l=<span class="cstat-no" title="statement not covered" >o[a];<span class="cstat-no" title="statement not covered" ></span>if(l.matchesNode(t,e,n)&amp;&amp;!this.preMatch.matched.has(l)){<span class="cstat-no" title="statement not covered" >i=a;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn!(i&lt;0)&amp;&amp;(this.destroyBetween(this.index,i),this.index++,!0)}</span>,zs.prototype.updateNodeAt=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o){var i=<span class="cstat-no" title="statement not covered" >this.top.children[r];<span class="cstat-no" title="statement not covered" ></span>return!!i.update(t,e,n,o)&amp;&amp;(this.destroyBetween(this.index,r),this.index=r+1,!0)}</span>,zs.prototype.findIndexWithChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(;;){var e=<span class="cstat-no" title="statement not covered" >t.parentNode;<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span></span>f(e==this.top.contentDOM){var n=<span class="cstat-no" title="statement not covered" >t.pmViewDesc;<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >this.index;</span>r&lt;this.top.children.length;r++)<span class="cstat-no" title="statement not covered" >if(this.top.children[r]==n)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn-1}<span class="cstat-no" title="statement not covered" ></span>t</span>=e}</span>}</span>,zs.prototype.updateNextNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >this.index;</span>i&lt;this.top.children.length;i++){var s=<span class="cstat-no" title="statement not covered" >this.top.children[i];<span class="cstat-no" title="statement not covered" ></span>if(s instanceof xs){var a=<span class="cstat-no" title="statement not covered" >this.preMatch.matched.get(s);<span class="cstat-no" title="statement not covered" ></span>if(null!=a&amp;&amp;a!=o)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >s.dom,</span>l=<span class="cstat-no" title="statement not covered" >this.lock&amp;&amp;(c==this.lock||1==c.nodeType&amp;&amp;c.contains(this.lock.parentNode))&amp;&amp;!(t.isText&amp;&amp;s.node&amp;&amp;s.node.isText&amp;&amp;s.nodeDOM.nodeValue==t.text&amp;&amp;s.dirty!=vs&amp;&amp;_s(e,s.outerDeco));<span class="cstat-no" title="statement not covered" ></span>if(!l&amp;&amp;s.update(t,e,n,r))<span class="cstat-no" title="statement not covered" >return this.destroyBetween(this.index,i),s.dom!=c&amp;&amp;(this.changed=!0),this.index++,!0;<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>,zs.prototype.addNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o){<span class="cstat-no" title="statement not covered" >this.top.children.splice(this.index++,0,xs.create(this.top,t,e,n,r,o)),this.changed=!0}</span>,zs.prototype.placeWidget=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this.index&lt;this.top.children.length?this.top.children[this.index]:null;<span class="cstat-no" title="statement not covered" ></span>if(!r||!r.matchesWidget(t)||t!=r.widget&amp;&amp;r.widget.type.toDOM.parentNode){var o=<span class="cstat-no" title="statement not covered" >new ws(this.top,t,e,n);<span class="cstat-no" title="statement not covered" ></span>this.top.children.splice(this.index++,0,o),this.changed=!0}</span>else <span class="cstat-no" title="statement not covered" >this.index++}</span></span>,zs.prototype.addTextblockHacks=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.top.children[this.index-1];<span class="cstat-no" title="statement not covered" ></span>while(t instanceof ks)<span class="cstat-no" title="statement not covered" >t=t.children[t.children.length-1];<span class="cstat-no" title="statement not covered" >t</span></span>&amp;&amp;t instanceof Ms&amp;&amp;!/\n$/.test(t.node.text)||((gi.safari||gi.chrome)&amp;&amp;t&amp;&amp;"false"==t.dom.contentEditable&amp;&amp;this.addHackNode("IMG"),this.addHackNode("BR"))}</span>,zs.prototype.addHackNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.index&lt;this.top.children.length&amp;&amp;this.top.children[this.index].matchesHack(t))<span class="cstat-no" title="statement not covered" >this.index++;e</span>lse{var e=<span class="cstat-no" title="statement not covered" >document.createElement(t);<span class="cstat-no" title="statement not covered" ></span>"IMG"==t&amp;&amp;(e.className="ProseMirror-separator"),this.top.children.splice(this.index++,0,new Cs(this.top,bs,e,null)),this.changed=!0}</span>}</span>;v</span>ar Us=<span class="cstat-no" title="statement not covered" >gi.safari||gi.chrome&amp;&amp;gi.chrome_version&lt;63;</span>function <span class="fstat-no" title="function not covered" >Gs(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.docView.domFromPos(e,0),</span>r=<span class="cstat-no" title="statement not covered" >n.node,</span>o=<span class="cstat-no" title="statement not covered" >n.offset,</span>i=<span class="cstat-no" title="statement not covered" >o&lt;r.childNodes.length?r.childNodes[o]:null,</span>s=<span class="cstat-no" title="statement not covered" >o?r.childNodes[o-1]:null;<span class="cstat-no" title="statement not covered" ></span>if(gi.safari&amp;&amp;i&amp;&amp;"false"==i.contentEditable)<span class="cstat-no" title="statement not covered" >return Ys(i);<span class="cstat-no" title="statement not covered" >i</span></span>f((!i||"false"==i.contentEditable)&amp;&amp;(!s||"false"==s.contentEditable)){<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >return Ys(i);<span class="cstat-no" title="statement not covered" >i</span></span>f(s)<span class="cstat-no" title="statement not covered" >return Ys(s)}</span></span>}</span>function <span class="fstat-no" title="function not covered" >Ys(</span>t){<span class="cstat-no" title="statement not covered" >return t.contentEditable="true",gi.safari&amp;&amp;t.draggable&amp;&amp;(t.draggable=!1,t.wasDraggable=!0),t}</span>function <span class="fstat-no" title="function not covered" >Xs(</span>t){<span class="cstat-no" title="statement not covered" >t.contentEditable="false",t.wasDraggable&amp;&amp;(t.draggable=!0,t.wasDraggable=null)}</span>function <span class="fstat-no" title="function not covered" >Qs(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.dom.ownerDocument;<span class="cstat-no" title="statement not covered" ></span>e.removeEventListener("selectionchange",t.hideSelectionGuard);v</span>ar n=<span class="cstat-no" title="statement not covered" >t.root.getSelection(),</span>r=<span class="cstat-no" title="statement not covered" >n.anchorNode,</span>o=<span class="cstat-no" title="statement not covered" >n.anchorOffset;<span class="cstat-no" title="statement not covered" ></span>e.addEventListener("selectionchange",t.hideSelectionGuard=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.anchorNode==r&amp;&amp;n.anchorOffset==o||(e.removeEventListener("selectionchange",t.hideSelectionGuard),setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >Ws(t)&amp;&amp;!t.state.selection.visible||t.dom.classList.remove("ProseMirror-hideselection")}</span>),20))}</span>)}</span>function <span class="fstat-no" title="function not covered" >Zs(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.root.getSelection(),</span>n=<span class="cstat-no" title="statement not covered" >document.createRange(),</span>r=<span class="cstat-no" title="statement not covered" >t.cursorWrapper.dom,</span>o=<span class="cstat-no" title="statement not covered" >"IMG"==r.nodeName;<span class="cstat-no" title="statement not covered" ></span>o?n.setEnd(r.parentNode,xi(r)+1):n.setEnd(r,0),n.collapse(!1),e.removeAllRanges(),e.addRange(n),!o&amp;&amp;!t.state.selection.visible&amp;&amp;gi.ie&amp;&amp;gi.ie_version&lt;=11&amp;&amp;(r.disabled=!0,r.disabled=!1)}</span>function <span class="fstat-no" title="function not covered" >ta(</span>t,e){<span class="cstat-no" title="statement not covered" >if(e instanceof Go){var n=<span class="cstat-no" title="statement not covered" >t.docView.descAt(e.from);<span class="cstat-no" title="statement not covered" ></span>n!=t.lastSelectedViewDesc&amp;&amp;(ea(t),n&amp;&amp;n.selectNode(),t.lastSelectedViewDesc=n)}</span>else <span class="cstat-no" title="statement not covered" >ea(t)}</span></span>function <span class="fstat-no" title="function not covered" >ea(</span>t){<span class="cstat-no" title="statement not covered" >t.lastSelectedViewDesc&amp;&amp;(t.lastSelectedViewDesc.parent&amp;&amp;t.lastSelectedViewDesc.deselectNode(),t.lastSelectedViewDesc=null)}</span>function <span class="fstat-no" title="function not covered" >na(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >return t.someProp("createSelectionBetween",(<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return r(t,e,n)}</span>))||Ko.between(e,n,r)}</span>function <span class="fstat-no" title="function not covered" >ra(</span>t){<span class="cstat-no" title="statement not covered" >return(!t.editable||t.root.activeElement==t.dom)&amp;&amp;oa(t)}</span>function <span class="fstat-no" title="function not covered" >oa(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.root.getSelection();<span class="cstat-no" title="statement not covered" ></span>if(!e.anchorNode)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return t.dom.contains(3==e.anchorNode.nodeType?e.anchorNode.parentNode:e.anchorNode)&amp;&amp;(t.editable||t.dom.contains(3==e.focusNode.nodeType?e.focusNode.parentNode:e.focusNode))}</span>catch(n){<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>function <span class="fstat-no" title="function not covered" >ia(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.docView.domFromPos(t.state.selection.anchor,0),</span>n=<span class="cstat-no" title="statement not covered" >t.root.getSelection();<span class="cstat-no" title="statement not covered" ></span>return Ei(e.node,e.offset,n.anchorNode,n.anchorOffset)}</span>function <span class="fstat-no" title="function not covered" >sa(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.selection,</span>r=<span class="cstat-no" title="statement not covered" >n.$anchor,</span>o=<span class="cstat-no" title="statement not covered" >n.$head,</span>i=<span class="cstat-no" title="statement not covered" >e&gt;0?r.max(o):r.min(o),</span>s=<span class="cstat-no" title="statement not covered" >i.parent.inlineContent?i.depth?t.doc.resolve(e&gt;0?i.after():i.before()):null:i;<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;qo.findFrom(s,e)}</span>function <span class="fstat-no" title="function not covered" >aa(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()),!0}</span>function <span class="fstat-no" title="function not covered" >ca(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.state.selection;<span class="cstat-no" title="statement not covered" ></span>if(!(r instanceof Ko)){<span class="cstat-no" title="statement not covered" >if(r instanceof Go&amp;&amp;r.node.isInline)<span class="cstat-no" title="statement not covered" >return aa(t,new Ko(e&gt;0?r.$to:r.$from));v</span></span>ar o=<span class="cstat-no" title="statement not covered" >sa(t.state,e);<span class="cstat-no" title="statement not covered" ></span>return!!o&amp;&amp;aa(t,o)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!r.empty||n.indexOf("s")&gt;-1)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.endOfTextblock(e&gt;0?"right":"left")){var i=<span class="cstat-no" title="statement not covered" >sa(t.state,e);<span class="cstat-no" title="statement not covered" ></span>return!!(i&amp;&amp;i instanceof Go)&amp;&amp;aa(t,i)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!(gi.mac&amp;&amp;n.indexOf("m")&gt;-1)){var s,a=<span class="cstat-no" title="statement not covered" >r.$head,</span>c=<span class="cstat-no" title="statement not covered" >a.textOffset?null:e&lt;0?a.nodeBefore:a.nodeAfter;<span class="cstat-no" title="statement not covered" ></span>if(!c||c.isText)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar l=<span class="cstat-no" title="statement not covered" >e&lt;0?a.pos-c.nodeSize:a.pos;<span class="cstat-no" title="statement not covered" ></span>return!!(c.isAtom||(s=t.docView.descAt(l))&amp;&amp;!s.contentDOM)&amp;&amp;(Go.isSelectable(c)?aa(t,new Go(e&lt;0?t.state.doc.resolve(a.pos-c.nodeSize):a)):!!gi.webkit&amp;&amp;aa(t,new Ko(t.state.doc.resolve(e&lt;0?l:l+c.nodeSize))))}</span>}</span>function <span class="fstat-no" title="function not covered" >la(</span>t){<span class="cstat-no" title="statement not covered" >return 3==t.nodeType?t.nodeValue.length:t.childNodes.length}</span>function <span class="fstat-no" title="function not covered" >pa(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.pmViewDesc;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;0==e.size&amp;&amp;(t.nextSibling||"BR"!=t.nodeName)}</span>function <span class="fstat-no" title="function not covered" >ua(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.root.getSelection(),</span>n=<span class="cstat-no" title="statement not covered" >e.focusNode,</span>r=<span class="cstat-no" title="statement not covered" >e.focusOffset;<span class="cstat-no" title="statement not covered" ></span>if(n){var o,i,s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(gi.gecko&amp;&amp;1==n.nodeType&amp;&amp;r&lt;la(n)&amp;&amp;pa(n.childNodes[r])&amp;&amp;(s=!0);;)<span class="cstat-no" title="statement not covered" >if(r&gt;0){<span class="cstat-no" title="statement not covered" >if(1!=n.nodeType)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >n.childNodes[r-1];<span class="cstat-no" title="statement not covered" ></span>if(pa(a))<span class="cstat-no" title="statement not covered" >o=n,i=--r;e</span>lse{<span class="cstat-no" title="statement not covered" >if(3!=a.nodeType)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>=a,r=n.nodeValue.length}</span>}</span>else{<span class="cstat-no" title="statement not covered" >if(da(n))<span class="cstat-no" title="statement not covered" >break;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >n.previousSibling;<span class="cstat-no" title="statement not covered" ></span>while(c&amp;&amp;pa(c))<span class="cstat-no" title="statement not covered" >o=n.parentNode,i=xi(c),c=c.previousSibling;<span class="cstat-no" title="statement not covered" >i</span></span>f(c)<span class="cstat-no" title="statement not covered" >n=c,r=la(n);e</span>lse{<span class="cstat-no" title="statement not covered" >if(n=n.parentNode,n==t.dom)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span>=0}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span></span>?fa(t,e,n,r):o&amp;&amp;fa(t,e,o,i)}</span>}</span>function <span class="fstat-no" title="function not covered" >ha(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.root.getSelection(),</span>n=<span class="cstat-no" title="statement not covered" >e.focusNode,</span>r=<span class="cstat-no" title="statement not covered" >e.focusOffset;<span class="cstat-no" title="statement not covered" ></span>if(n){<span class="cstat-no" title="statement not covered" >for(var o,i,s=<span class="cstat-no" title="statement not covered" >la(n);</span>;)<span class="cstat-no" title="statement not covered" >if(r&lt;s){<span class="cstat-no" title="statement not covered" >if(1!=n.nodeType)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >n.childNodes[r];<span class="cstat-no" title="statement not covered" ></span>if(!pa(a))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>=n,i=++r}</span>else{<span class="cstat-no" title="statement not covered" >if(da(n))<span class="cstat-no" title="statement not covered" >break;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >n.nextSibling;<span class="cstat-no" title="statement not covered" ></span>while(c&amp;&amp;pa(c))<span class="cstat-no" title="statement not covered" >o=c.parentNode,i=xi(c)+1,c=c.nextSibling;<span class="cstat-no" title="statement not covered" >i</span></span>f(c)<span class="cstat-no" title="statement not covered" >n=c,r=0,s=la(n);e</span>lse{<span class="cstat-no" title="statement not covered" >if(n=n.parentNode,n==t.dom)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span>=s=0}</span>}<span class="cstat-no" title="statement not covered" ></span>o</span></span>&amp;&amp;fa(t,e,o,i)}</span>}</span>function <span class="fstat-no" title="function not covered" >da(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.pmViewDesc;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;e.node&amp;&amp;e.node.isBlock}</span>function <span class="fstat-no" title="function not covered" >fa(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >if(Di(e)){var o=<span class="cstat-no" title="statement not covered" >document.createRange();<span class="cstat-no" title="statement not covered" ></span>o.setEnd(n,r),o.setStart(n,r),e.removeAllRanges(),e.addRange(o)}</span>else <span class="cstat-no" title="statement not covered" >e.extend&amp;&amp;e.extend(n,r);<span class="cstat-no" title="statement not covered" >t</span></span>.domObserver.setCurSelection();v</span>ar i=<span class="cstat-no" title="statement not covered" >t.state;<span class="cstat-no" title="statement not covered" ></span>setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.state==i&amp;&amp;Ks(t)}</span>),50)}</span>function <span class="fstat-no" title="function not covered" >ma(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.state.selection;<span class="cstat-no" title="statement not covered" ></span>if(r instanceof Ko&amp;&amp;!r.empty||n.indexOf("s")&gt;-1)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(gi.mac&amp;&amp;n.indexOf("m")&gt;-1)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >r.$from,</span>i=<span class="cstat-no" title="statement not covered" >r.$to;<span class="cstat-no" title="statement not covered" ></span>if(!o.parent.inlineContent||t.endOfTextblock(e&lt;0?"up":"down")){var s=<span class="cstat-no" title="statement not covered" >sa(t.state,e);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;s instanceof Go)<span class="cstat-no" title="statement not covered" >return aa(t,s)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(!o.parent.inlineContent){var a=<span class="cstat-no" title="statement not covered" >e&lt;0?o:i,</span>c=<span class="cstat-no" title="statement not covered" >r instanceof Xo?qo.near(a,e):qo.findFrom(a,e);<span class="cstat-no" title="statement not covered" ></span>return!!c&amp;&amp;aa(t,c)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >va(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!(t.state.selection instanceof Ko))<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.state.selection,</span>r=<span class="cstat-no" title="statement not covered" >n.$head,</span>o=<span class="cstat-no" title="statement not covered" >n.$anchor,</span>i=<span class="cstat-no" title="statement not covered" >n.empty;<span class="cstat-no" title="statement not covered" ></span>if(!r.sameParent(o))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!i)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.endOfTextblock(e&gt;0?"forward":"backward"))<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >!r.textOffset&amp;&amp;(e&lt;0?r.nodeBefore:r.nodeAfter);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;!s.isText){var a=<span class="cstat-no" title="statement not covered" >t.state.tr;<span class="cstat-no" title="statement not covered" ></span>return e&lt;0?a.delete(r.pos-s.nodeSize,r.pos):a.delete(r.pos,r.pos+s.nodeSize),t.dispatch(a),!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >ga(</span>t,e,n){<span class="cstat-no" title="statement not covered" >t.domObserver.stop(),e.contentEditable=n,t.domObserver.start()}</span>function <span class="fstat-no" title="function not covered" >ya(</span>t){<span class="cstat-no" title="statement not covered" >if(gi.safari&amp;&amp;!(t.state.selection.$head.parentOffset&gt;0)){var e=<span class="cstat-no" title="statement not covered" >t.root.getSelection(),</span>n=<span class="cstat-no" title="statement not covered" >e.focusNode,</span>r=<span class="cstat-no" title="statement not covered" >e.focusOffset;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;1==n.nodeType&amp;&amp;0==r&amp;&amp;n.firstChild&amp;&amp;"false"==n.firstChild.contentEditable){var o=<span class="cstat-no" title="statement not covered" >n.firstChild;<span class="cstat-no" title="statement not covered" ></span>ga(t,o,!0),setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return ga(t,o,!1)}</span>),20)}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >ba(</span>t){var e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return t.ctrlKey&amp;&amp;(e+="c"),t.metaKey&amp;&amp;(e+="m"),t.altKey&amp;&amp;(e+="a"),t.shiftKey&amp;&amp;(e+="s"),e}</span>function <span class="fstat-no" title="function not covered" >wa(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >e.keyCode,</span>r=<span class="cstat-no" title="statement not covered" >ba(e);<span class="cstat-no" title="statement not covered" ></span>return 8==n||gi.mac&amp;&amp;72==n&amp;&amp;"c"==r?va(t,-1)||ua(t):46==n||gi.mac&amp;&amp;68==n&amp;&amp;"c"==r?va(t,1)||ha(t):13==n||27==n||(37==n?ca(t,-1,r)||ua(t):39==n?ca(t,1,r)||ha(t):38==n?ma(t,-1,r)||ua(t):40==n?ya(t)||ma(t,1,r)||ha(t):r==(gi.mac?"m":"c")&amp;&amp;(66==n||73==n||89==n||90==n))}</span>function <span class="fstat-no" title="function not covered" >Oa(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.docView.parseRange(e,n),</span>o=<span class="cstat-no" title="statement not covered" >r.node,</span>i=<span class="cstat-no" title="statement not covered" >r.fromOffset,</span>s=<span class="cstat-no" title="statement not covered" >r.toOffset,</span>a=<span class="cstat-no" title="statement not covered" >r.from,</span>c=<span class="cstat-no" title="statement not covered" >r.to,</span>l=<span class="cstat-no" title="statement not covered" >t.root.getSelection(),</span>p=<span class="cstat-no" title="statement not covered" >null,</span>u=<span class="cstat-no" title="statement not covered" >l.anchorNode;<span class="cstat-no" title="statement not covered" ></span>if(u&amp;&amp;t.dom.contains(1==u.nodeType?u:u.parentNode)&amp;&amp;(p=[{node:u,offset:l.anchorOffset}],Di(l)||p.push({node:l.focusNode,offset:l.focusOffset})),gi.chrome&amp;&amp;8===t.lastKeyCode)<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >s;</span>h&gt;i;h--){var d=<span class="cstat-no" title="statement not covered" >o.childNodes[h-1],</span>f=<span class="cstat-no" title="statement not covered" >d.pmViewDesc;<span class="cstat-no" title="statement not covered" ></span>if("BR"==d.nodeName&amp;&amp;!f){<span class="cstat-no" title="statement not covered" >s=h;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!f||f.size)<span class="cstat-no" title="statement not covered" >break}</span></span>v</span></span>ar m=<span class="cstat-no" title="statement not covered" >t.state.doc,</span>v=<span class="cstat-no" title="statement not covered" >t.someProp("domParser")||Ar.fromSchema(t.state.schema),</span>g=<span class="cstat-no" title="statement not covered" >m.resolve(a),</span>y=<span class="cstat-no" title="statement not covered" >null,</span>b=<span class="cstat-no" title="statement not covered" >v.parse(o,{topNode:g.parent,topMatch:g.parent.contentMatchAt(g.index()),topOpen:!0,from:i,to:s,preserveWhitespace:!g.parent.type.spec.code||"full",editableContent:!0,findPositions:p,ruleFromNode:ka,context:g});<span class="cstat-no" title="statement not covered" ></span>if(p&amp;&amp;null!=p[0].pos){var w=<span class="cstat-no" title="statement not covered" >p[0].pos,</span>O=<span class="cstat-no" title="statement not covered" >p[1]&amp;&amp;p[1].pos;<span class="cstat-no" title="statement not covered" ></span>null==O&amp;&amp;(O=w),y={anchor:w+a,head:O+a}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{doc:b,sel:y,from:a,to:c}}</span>function <span class="fstat-no" title="function not covered" >ka(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.pmViewDesc;<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return e.parseRule();<span class="cstat-no" title="statement not covered" >i</span></span>f("BR"==t.nodeName&amp;&amp;t.parentNode){<span class="cstat-no" title="statement not covered" >if(gi.safari&amp;&amp;/^(ul|ol)$/i.test(t.parentNode.nodeName)){var n=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>return n.appendChild(document.createElement("li")),{skip:n}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.parentNode.lastChild==t||gi.safari&amp;&amp;/^(tr|table)$/i.test(t.parentNode.nodeName))<span class="cstat-no" title="statement not covered" >return{ignore:!0}}</span></span>else <span class="cstat-no" title="statement not covered" >if("IMG"==t.nodeName&amp;&amp;t.getAttribute("mark-placeholder"))<span class="cstat-no" title="statement not covered" >return{ignore:!0}}</span></span></span>function <span class="fstat-no" title="function not covered" >xa(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >if(e&lt;0){var i=<span class="cstat-no" title="statement not covered" >t.lastSelectionTime&gt;Date.now()-50?t.lastSelectionOrigin:null,</span>s=<span class="cstat-no" title="statement not covered" >Js(t,i);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;!t.state.selection.eq(s)){var a=<span class="cstat-no" title="statement not covered" >t.state.tr.setSelection(s);<span class="cstat-no" title="statement not covered" ></span>"pointer"==i?a.setMeta("pointer",!0):"key"==i&amp;&amp;a.scrollIntoView(),t.dispatch(a)}</span>}</span>else{var c=<span class="cstat-no" title="statement not covered" >t.state.doc.resolve(e),</span>l=<span class="cstat-no" title="statement not covered" >c.sharedDepth(n);<span class="cstat-no" title="statement not covered" ></span>e=c.before(l+1),n=t.state.doc.resolve(n).after(l+1);v</span>ar p=<span class="cstat-no" title="statement not covered" >t.state.selection,</span>u=<span class="cstat-no" title="statement not covered" >Oa(t,e,n);<span class="cstat-no" title="statement not covered" ></span>if(gi.chrome&amp;&amp;t.cursorWrapper&amp;&amp;u.sel&amp;&amp;u.sel.anchor==t.cursorWrapper.deco.from){var h=<span class="cstat-no" title="statement not covered" >t.cursorWrapper.deco.type.toDOM.nextSibling,</span>d=<span class="cstat-no" title="statement not covered" >h&amp;&amp;h.nodeValue?h.nodeValue.length:1;<span class="cstat-no" title="statement not covered" ></span>u.sel={anchor:u.sel.anchor+d,head:u.sel.anchor+d}}</span>v</span>ar f,m,v=<span class="cstat-no" title="statement not covered" >t.state.doc,</span>g=<span class="cstat-no" title="statement not covered" >v.slice(u.from,u.to);<span class="cstat-no" title="statement not covered" ></span>8===t.lastKeyCode&amp;&amp;Date.now()-100&lt;t.lastKeyCodeTime?(f=t.state.selection.to,m="end"):(f=t.state.selection.from,m="start"),t.lastKeyCode=null;v</span>ar y=<span class="cstat-no" title="statement not covered" >Ta(g.content,u.doc.content,u.from,f,m);<span class="cstat-no" title="statement not covered" ></span>if(!y){<span class="cstat-no" title="statement not covered" >if(!(r&amp;&amp;p instanceof Ko&amp;&amp;!p.empty&amp;&amp;p.$head.sameParent(p.$anchor))||t.composing||u.sel&amp;&amp;u.sel.anchor!=u.sel.head){<span class="cstat-no" title="statement not covered" >if((gi.ios&amp;&amp;t.lastIOSEnter&gt;Date.now()-225||gi.android)&amp;&amp;o.some((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"DIV"==t.nodeName||"P"==t.nodeName}</span>))&amp;&amp;t.someProp("handleKeyDown",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t,Ri(13,"Enter"))}</span>)))<span class="cstat-no" title="statement not covered" >return void(t.lastIOSEnter=0);<span class="cstat-no" title="statement not covered" >i</span></span>f(u.sel){var b=<span class="cstat-no" title="statement not covered" >Sa(t,t.state.doc,u.sel);<span class="cstat-no" title="statement not covered" ></span>b&amp;&amp;!b.eq(t.state.selection)&amp;&amp;t.dispatch(t.state.tr.setSelection(b))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>y</span>={start:p.from,endA:p.to,endB:p.to}}<span class="cstat-no" title="statement not covered" ></span>t</span>.domChangeCount++,t.state.selection.from&lt;t.state.selection.to&amp;&amp;y.start==y.endB&amp;&amp;t.state.selection instanceof Ko&amp;&amp;(y.start&gt;t.state.selection.from&amp;&amp;y.start&lt;=t.state.selection.from+2?y.start=t.state.selection.from:y.endA&lt;t.state.selection.to&amp;&amp;y.endA&gt;=t.state.selection.to-2&amp;&amp;(y.endB+=t.state.selection.to-y.endA,y.endA=t.state.selection.to)),gi.ie&amp;&amp;gi.ie_version&lt;=11&amp;&amp;y.endB==y.start+1&amp;&amp;y.endA==y.start&amp;&amp;y.start&gt;u.from&amp;&amp;"  "==u.doc.textBetween(y.start-u.from-1,y.start-u.from+1)&amp;&amp;(y.start--,y.endA--,y.endB--);v</span>ar w,O=<span class="cstat-no" title="statement not covered" >u.doc.resolveNoCache(y.start-u.from),</span>k=<span class="cstat-no" title="statement not covered" >u.doc.resolveNoCache(y.endB-u.from),</span>x=<span class="cstat-no" title="statement not covered" >O.sameParent(k)&amp;&amp;O.parent.inlineContent;<span class="cstat-no" title="statement not covered" ></span>if((gi.ios&amp;&amp;t.lastIOSEnter&gt;Date.now()-225&amp;&amp;(!x||o.some((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"DIV"==t.nodeName||"P"==t.nodeName}</span>)))||!x&amp;&amp;O.pos&lt;u.doc.content.size&amp;&amp;(w=qo.findFrom(u.doc.resolve(O.pos+1),1,!0))&amp;&amp;w.head==k.pos)&amp;&amp;t.someProp("handleKeyDown",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t,Ri(13,"Enter"))}</span>)))<span class="cstat-no" title="statement not covered" >t.lastIOSEnter=0;e</span>lse <span class="cstat-no" title="statement not covered" >if(t.state.selection.anchor&gt;y.start&amp;&amp;Ca(v,y.start,y.endA,O,k)&amp;&amp;t.someProp("handleKeyDown",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t,Ri(8,"Backspace"))}</span>)))<span class="cstat-no" title="statement not covered" >gi.android&amp;&amp;gi.chrome&amp;&amp;t.domObserver.suppressSelectionUpdates();e</span>lse{<span class="cstat-no" title="statement not covered" >gi.chrome&amp;&amp;gi.android&amp;&amp;y.toB==y.from&amp;&amp;(t.lastAndroidDelete=Date.now()),gi.android&amp;&amp;!x&amp;&amp;O.start()!=k.start()&amp;&amp;0==k.parentOffset&amp;&amp;O.depth==k.depth&amp;&amp;u.sel&amp;&amp;u.sel.anchor==u.sel.head&amp;&amp;u.sel.head==y.endA&amp;&amp;(y.endB-=2,k=u.doc.resolveNoCache(y.endB-u.from),setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.someProp("handleKeyDown",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t,Ri(13,"Enter"))}</span>))}</span>),20));v</span>ar S,M,C,E,T=<span class="cstat-no" title="statement not covered" >y.start,</span>N=<span class="cstat-no" title="statement not covered" >y.endA;<span class="cstat-no" title="statement not covered" ></span>if(x)<span class="cstat-no" title="statement not covered" >if(O.pos==k.pos)<span class="cstat-no" title="statement not covered" >gi.ie&amp;&amp;gi.ie_version&lt;=11&amp;&amp;0==O.parentOffset&amp;&amp;(t.domObserver.suppressSelectionUpdates(),setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Ks(t)}</span>),20)),S=t.state.tr.delete(T,N),M=v.resolve(y.start).marksAcross(v.resolve(y.endA));e</span>lse <span class="cstat-no" title="statement not covered" >if(y.endA==y.endB&amp;&amp;(E=v.resolve(y.start))&amp;&amp;(C=Ma(O.parent.content.cut(O.parentOffset,k.parentOffset),E.parent.content.cut(E.parentOffset,y.endA-E.start()))))<span class="cstat-no" title="statement not covered" >S=t.state.tr,"add"==C.type?S.addMark(T,N,C.mark):S.removeMark(T,N,C.mark);e</span>lse <span class="cstat-no" title="statement not covered" >if(O.parent.child(O.index()).isText&amp;&amp;O.index()==k.index()-(k.textOffset?0:1)){var j=<span class="cstat-no" title="statement not covered" >O.parent.textBetween(O.parentOffset,k.parentOffset);<span class="cstat-no" title="statement not covered" ></span>if(t.someProp("handleTextInput",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t,T,N,j)}</span>)))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >S</span></span>=t.state.tr.insertText(j,T,N)}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span></span>f(S||(S=t.state.tr.replace(T,N,u.doc.slice(y.start-u.from,y.endB-u.from))),u.sel){var A=<span class="cstat-no" title="statement not covered" >Sa(t,S.doc,u.sel);<span class="cstat-no" title="statement not covered" ></span>A&amp;&amp;!(gi.chrome&amp;&amp;gi.android&amp;&amp;t.composing&amp;&amp;A.empty&amp;&amp;(y.start!=y.endB||t.lastAndroidDelete&lt;Date.now()-100)&amp;&amp;(A.head==T||A.head==S.mapping.map(N)-1)||gi.ie&amp;&amp;A.empty&amp;&amp;A.head==T)&amp;&amp;S.setSelection(A)}<span class="cstat-no" title="statement not covered" ></span>M</span>&amp;&amp;S.ensureMarks(M),t.dispatch(S.scrollIntoView())}</span>}</span></span>}</span>function <span class="fstat-no" title="function not covered" >Sa(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return Math.max(n.anchor,n.head)&gt;e.content.size?null:na(t,e.resolve(n.anchor),e.resolve(n.head))}</span>function <span class="fstat-no" title="function not covered" >Ma(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n,r,o,i=<span class="cstat-no" title="statement not covered" >t.firstChild.marks,</span>s=<span class="cstat-no" title="statement not covered" >e.firstChild.marks,</span>a=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >s,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;s.length;l++)<span class="cstat-no" title="statement not covered" >a=s[l].removeFromSet(a);<span class="cstat-no" title="statement not covered" >f</span></span>or(var p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;i.length;p++)<span class="cstat-no" title="statement not covered" >c=i[p].removeFromSet(c);<span class="cstat-no" title="statement not covered" >i</span></span>f(1==a.length&amp;&amp;0==c.length)<span class="cstat-no" title="statement not covered" >r=a[0],n="add",o=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.mark(r.addToSet(t.marks))}</span>;e</span>lse{<span class="cstat-no" title="statement not covered" >if(0!=a.length||1!=c.length)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >r</span></span>=c[0],n="remove",o=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.mark(r.removeFromSet(t.marks))}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var u=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;e.childCount;h++)<span class="cstat-no" title="statement not covered" >u.push(o(e.child(h)));<span class="cstat-no" title="statement not covered" >i</span></span>f(Cn.from(u).eq(t))<span class="cstat-no" title="statement not covered" >return{mark:r,type:n}}</span></span>function <span class="fstat-no" title="function not covered" >Ca(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >if(!r.parent.isTextblock||n-e&lt;=o.pos-r.pos||Ea(r,!0,!1)&lt;o.pos)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >t.resolve(e);<span class="cstat-no" title="statement not covered" ></span>if(i.parentOffset&lt;i.parent.content.size||!i.parent.isTextblock)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >t.resolve(Ea(i,!0,!0));<span class="cstat-no" title="statement not covered" ></span>return!(!s.parent.isTextblock||s.pos&gt;n||Ea(s,!0,!1)&lt;n)&amp;&amp;r.parent.content.cut(r.parentOffset).eq(s.parent.content)}</span>function <span class="fstat-no" title="function not covered" >Ea(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.depth,</span>o=<span class="cstat-no" title="statement not covered" >e?t.end():t.pos;<span class="cstat-no" title="statement not covered" ></span>while(r&gt;0&amp;&amp;(e||t.indexAfter(r)==t.node(r).childCount))<span class="cstat-no" title="statement not covered" >r--,o++,e=!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(n){var i=<span class="cstat-no" title="statement not covered" >t.node(r).maybeChild(t.indexAfter(r));<span class="cstat-no" title="statement not covered" ></span>while(i&amp;&amp;!i.isLeaf)<span class="cstat-no" title="statement not covered" >i=i.firstChild,o++}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn o}</span>function <span class="fstat-no" title="function not covered" >Ta(</span>t,e,n,r,o){var i=<span class="cstat-no" title="statement not covered" >t.findDiffStart(e,n);<span class="cstat-no" title="statement not covered" ></span>if(null==i)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >t.findDiffEnd(e,n+t.size,n+e.size),</span>a=<span class="cstat-no" title="statement not covered" >s.a,</span>c=<span class="cstat-no" title="statement not covered" >s.b;<span class="cstat-no" title="statement not covered" ></span>if("end"==o){var l=<span class="cstat-no" title="statement not covered" >Math.max(0,i-Math.min(a,c));<span class="cstat-no" title="statement not covered" ></span>r-=a+l-i}<span class="cstat-no" title="statement not covered" ></span>i</span>f(a&lt;i&amp;&amp;t.size&lt;e.size){var p=<span class="cstat-no" title="statement not covered" >r&lt;=i&amp;&amp;r&gt;=a?i-r:0;<span class="cstat-no" title="statement not covered" ></span>i-=p,c=i+(c-a),a=i}</span>else <span class="cstat-no" title="statement not covered" >if(c&lt;i){var u=<span class="cstat-no" title="statement not covered" >r&lt;=i&amp;&amp;r&gt;=c?i-r:0;<span class="cstat-no" title="statement not covered" ></span>i-=u,a=i+(a-c),c=i}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{start:i,endA:a,endB:c}}</span>function <span class="fstat-no" title="function not covered" >Na(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >e.content,</span>o=<span class="cstat-no" title="statement not covered" >e.openStart,</span>i=<span class="cstat-no" title="statement not covered" >e.openEnd;<span class="cstat-no" title="statement not covered" ></span>while(o&gt;1&amp;&amp;i&gt;1&amp;&amp;1==r.childCount&amp;&amp;1==r.firstChild.childCount){<span class="cstat-no" title="statement not covered" >o--,i--;v</span>ar s=<span class="cstat-no" title="statement not covered" >r.firstChild;<span class="cstat-no" title="statement not covered" ></span>n.push(s.type.name,s.attrs!=s.type.defaultAttrs?s.attrs:null),r=s.content}</span>v</span>ar a=<span class="cstat-no" title="statement not covered" >t.someProp("clipboardSerializer")||Ur.fromSchema(t.state.schema),</span>c=<span class="cstat-no" title="statement not covered" >La(),</span>l=<span class="cstat-no" title="statement not covered" >c.createElement("div");<span class="cstat-no" title="statement not covered" ></span>l.appendChild(a.serializeFragment(r,{document:c}));v</span>ar p,u=<span class="cstat-no" title="statement not covered" >l.firstChild;<span class="cstat-no" title="statement not covered" ></span>while(u&amp;&amp;1==u.nodeType&amp;&amp;(p=za[u.nodeName.toLowerCase()])){<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >p.length-1;</span>h&gt;=0;h--){var d=<span class="cstat-no" title="statement not covered" >c.createElement(p[h]);<span class="cstat-no" title="statement not covered" ></span>while(l.firstChild)<span class="cstat-no" title="statement not covered" >d.appendChild(l.firstChild);<span class="cstat-no" title="statement not covered" >l</span></span>.appendChild(d),"tbody"!=p[h]&amp;&amp;(o++,i++)}<span class="cstat-no" title="statement not covered" ></span>u</span>=l.firstChild}<span class="cstat-no" title="statement not covered" ></span>u</span>&amp;&amp;1==u.nodeType&amp;&amp;u.setAttribute("data-pm-slice",o+" "+i+" "+JSON.stringify(n));v</span>ar f=<span class="cstat-no" title="statement not covered" >t.someProp("clipboardTextSerializer",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t(e)}</span>))||e.content.textBetween(0,e.content.size,"\n\n");<span class="cstat-no" title="statement not covered" ></span>return{dom:l,text:f}}</span>function <span class="fstat-no" title="function not covered" >ja(</span>t,e,n,r,o){var i,s,a=<span class="cstat-no" title="statement not covered" >o.parent.type.spec.code;<span class="cstat-no" title="statement not covered" ></span>if(!n&amp;&amp;!e)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >e&amp;&amp;(r||a||!n);<span class="cstat-no" title="statement not covered" ></span>if(c){<span class="cstat-no" title="statement not covered" >if(t.someProp("transformPastedText",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e=t(e,a||r)}</span>)),a)<span class="cstat-no" title="statement not covered" >return new Dn(Cn.from(t.state.schema.text(e.replace(/\r\n?/g,"\n"))),0,0);v</span></span>ar l=<span class="cstat-no" title="statement not covered" >t.someProp("clipboardTextParser",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t(e,o,r)}</span>));<span class="cstat-no" title="statement not covered" ></span>if(l)<span class="cstat-no" title="statement not covered" >s=l;e</span>lse{var p=<span class="cstat-no" title="statement not covered" >o.marks(),</span>u=<span class="cstat-no" title="statement not covered" >t.state,</span>h=<span class="cstat-no" title="statement not covered" >u.schema,</span>d=<span class="cstat-no" title="statement not covered" >Ur.fromSchema(h);<span class="cstat-no" title="statement not covered" ></span>i=document.createElement("div"),e.trim().split(/(?:\r\n?|\n)+/).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.appendChild(document.createElement("p")).appendChild(d.serializeNode(h.text(t,p)))}</span>))}</span>}</span>else <span class="cstat-no" title="statement not covered" >t.someProp("transformPastedHTML",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n=t(n)}</span>)),i=Va(n),gi.webkit&amp;&amp;$a(i);v</span></span>ar f=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.querySelector("[data-pm-slice]"),</span>m=<span class="cstat-no" title="statement not covered" >f&amp;&amp;/^(\d+) (\d+) (.*)/.exec(f.getAttribute("data-pm-slice"));<span class="cstat-no" title="statement not covered" ></span>if(!s){var v=<span class="cstat-no" title="statement not covered" >t.someProp("clipboardParser")||t.someProp("domParser")||Ar.fromSchema(t.state.schema);<span class="cstat-no" title="statement not covered" ></span>s=v.parseSlice(i,{preserveWhitespace:!(!c&amp;&amp;!m),context:o})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s=m?Fa(Pa(s,+m[1],+m[2]),m[3]):Dn.maxOpen(Aa(s.content,o),!1),t.someProp("transformPasted",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >s=t(s)}</span>)),s}</span>function <span class="fstat-no" title="function not covered" >Aa(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.childCount&lt;2)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(n){var r=<span class="cstat-no" title="statement not covered" >e.node(n),</span>o=<span class="cstat-no" title="statement not covered" >r.contentMatchAt(e.index(n)),</span>i=<span class="cstat-no" title="statement not covered" >void 0,</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(s){var e,n=<span class="cstat-no" title="statement not covered" >o.findWrapping(t.type);<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return s=null;<span class="cstat-no" title="statement not covered" >i</span></span>f(e=s.length&amp;&amp;i.length&amp;&amp;Da(n,i,t,s[s.length-1],0))<span class="cstat-no" title="statement not covered" >s[s.length-1]=e;e</span>lse{<span class="cstat-no" title="statement not covered" >s.length&amp;&amp;(s[s.length-1]=Ra(s[s.length-1],i.length));v</span>ar r=<span class="cstat-no" title="statement not covered" >Ia(t,n);<span class="cstat-no" title="statement not covered" ></span>s.push(r),o=o.matchType(r.type,r.attrs),i=n}</span>}</span>}</span>)),s)<span class="cstat-no" title="statement not covered" >return{v:Cn.from(s)}}</span></span>,</span>r=<span class="cstat-no" title="statement not covered" >e.depth;</span>r&gt;=0;r--){var o=<span class="cstat-no" title="statement not covered" >n(r);<span class="cstat-no" title="statement not covered" ></span>if(o)<span class="cstat-no" title="statement not covered" >return o.v}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Ia(</span>t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=0);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >e.length-1;</span>r&gt;=n;r--)<span class="cstat-no" title="statement not covered" >t=e[r].create(null,Cn.from(t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Da(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >if(o&lt;t.length&amp;&amp;o&lt;e.length&amp;&amp;t[o]==e[o]){var i=<span class="cstat-no" title="statement not covered" >Da(t,e,n,r.lastChild,o+1);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return r.copy(r.content.replaceChild(r.childCount-1,i));v</span></span>ar s=<span class="cstat-no" title="statement not covered" >r.contentMatchAt(r.childCount);<span class="cstat-no" title="statement not covered" ></span>if(s.matchType(o==t.length-1?n.type:t[o+1]))<span class="cstat-no" title="statement not covered" >return r.copy(r.content.append(Cn.from(Ia(n,t,o+1))))}</span></span>}</span>function <span class="fstat-no" title="function not covered" >Ra(</span>t,e){<span class="cstat-no" title="statement not covered" >if(0==e)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.content.replaceChild(t.childCount-1,Ra(t.lastChild,e-1)),</span>r=<span class="cstat-no" title="statement not covered" >t.contentMatchAt(t.childCount).fillBefore(Cn.empty,!0);<span class="cstat-no" title="statement not covered" ></span>return t.copy(n.append(r))}</span>function <span class="fstat-no" title="function not covered" >_a(</span>t,e,n,r,o,i){var s=<span class="cstat-no" title="statement not covered" >e&lt;0?t.firstChild:t.lastChild,</span>a=<span class="cstat-no" title="statement not covered" >s.content;<span class="cstat-no" title="statement not covered" ></span>return o&lt;r-1&amp;&amp;(a=_a(a,e,n,r,o+1,i)),o&gt;=n&amp;&amp;(a=e&lt;0?s.contentMatchAt(0).fillBefore(a,t.childCount&gt;1||i&lt;=o).append(a):a.append(s.contentMatchAt(s.childCount).fillBefore(Cn.empty,!0))),t.replaceChild(e&lt;0?0:t.childCount-1,s.copy(a))}</span>function <span class="fstat-no" title="function not covered" >Pa(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return e&lt;t.openStart&amp;&amp;(t=new Dn(_a(t.content,-1,e,t.openStart,0,t.openEnd),e,t.openEnd)),n&lt;t.openEnd&amp;&amp;(t=new Dn(_a(t.content,1,n,t.openEnd,0,0),t.openStart,n)),t}</span>var za=<span class="cstat-no" title="statement not covered" >{thead:["table"],tbody:["table"],tfoot:["table"],caption:["table"],colgroup:["table"],col:["table","colgroup"],tr:["table","tbody"],td:["table","tbody","tr"],th:["table","tbody","tr"]},</span>Ba=<span class="cstat-no" title="statement not covered" >null;</span>function <span class="fstat-no" title="function not covered" >La(</span>){<span class="cstat-no" title="statement not covered" >return Ba||(Ba=document.implementation.createHTMLDocument("title"))}</span>function <span class="fstat-no" title="function not covered" >Va(</span>t){var e=<span class="cstat-no" title="statement not covered" >/^(\s*&lt;meta [^&gt;]*&gt;)*/.exec(t);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(t=t.slice(e[0].length));v</span>ar n,r=<span class="cstat-no" title="statement not covered" >La().createElement("div"),</span>o=<span class="cstat-no" title="statement not covered" >/&lt;([a-z][^&gt;\s]+)/i.exec(t);<span class="cstat-no" title="statement not covered" ></span>if((n=o&amp;&amp;za[o[1].toLowerCase()])&amp;&amp;(t=n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"&lt;"+t+"&gt;"}</span>)).join("")+t+n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"&lt;/"+t+"&gt;"}</span>)).reverse().join("")),r.innerHTML=t,n)<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;n.length;i++)<span class="cstat-no" title="statement not covered" >r=r.querySelector(n[i])||r;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >$a(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.querySelectorAll(gi.chrome?"span:not([class]):not([style])":"span.Apple-converted-space"),</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++){var r=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>1==r.childNodes.length&amp;&amp;" "==r.textContent&amp;&amp;r.parentNode&amp;&amp;r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "),r)}</span>}</span>function <span class="fstat-no" title="function not covered" >Fa(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!t.size)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar n,r=<span class="cstat-no" title="statement not covered" >t.content.firstChild.type.schema;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >n=JSON.parse(e)}</span>catch(l){<span class="cstat-no" title="statement not covered" >return t}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var o=<span class="cstat-no" title="statement not covered" >t.content,</span>i=<span class="cstat-no" title="statement not covered" >t.openStart,</span>s=<span class="cstat-no" title="statement not covered" >t.openEnd,</span>a=<span class="cstat-no" title="statement not covered" >n.length-2;</span>a&gt;=0;a-=2){var c=<span class="cstat-no" title="statement not covered" >r.nodes[n[a]];<span class="cstat-no" title="statement not covered" ></span>if(!c||c.hasRequiredAttrs())<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>=Cn.from(c.create(n[a+1],o)),i++,s++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Dn(o,i,s)}</span>var Ha=<span class="cstat-no" title="statement not covered" >{childList:!0,characterData:!0,characterDataOldValue:!0,attributes:!0,attributeOldValue:!0,subtree:!0},</span>qa=<span class="cstat-no" title="statement not covered" >gi.ie&amp;&amp;gi.ie_version&lt;=11,</span>Ja=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.anchorNode=this.anchorOffset=this.focusNode=this.focusOffset=null}</span>;<span class="cstat-no" title="statement not covered" ></span>Ja.prototype.set=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.anchorNode=t.anchorNode,this.anchorOffset=t.anchorOffset,this.focusNode=t.focusNode,this.focusOffset=t.focusOffset}</span>,Ja.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.anchorNode==this.anchorNode&amp;&amp;t.anchorOffset==this.anchorOffset&amp;&amp;t.focusNode==this.focusNode&amp;&amp;t.focusOffset==this.focusOffset}</span>;v</span>ar Wa=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.view=t,this.handleDOMChange=e,this.queue=[],this.flushingSoon=-1,this.observer=window.MutationObserver&amp;&amp;new window.MutationObserver((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >n.queue.push(t[e]);<span class="cstat-no" title="statement not covered" >g</span></span>i.ie&amp;&amp;gi.ie_version&lt;=11&amp;&amp;t.some((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"childList"==t.type&amp;&amp;t.removedNodes.length||"characterData"==t.type&amp;&amp;t.oldValue.length&gt;t.target.nodeValue.length}</span>))?n.flushSoon():n.flush()}</span>)),this.currentSelection=new Ja,qa&amp;&amp;(this.onCharData=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >n.queue.push({target:t.target,type:"characterData",oldValue:t.prevValue}),n.flushSoon()}</span>),this.onSelectionChange=this.onSelectionChange.bind(this),this.suppressingSelectionUpdates=!1}</span>;<span class="cstat-no" title="statement not covered" ></span>Wa.prototype.flushSoon=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.flushingSoon&lt;0&amp;&amp;(this.flushingSoon=window.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.flushingSoon=-1,t.flush()}</span>),20))}</span>,Wa.prototype.forceFlush=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.flushingSoon&gt;-1&amp;&amp;(window.clearTimeout(this.flushingSoon),this.flushingSoon=-1,this.flush())}</span>,Wa.prototype.start=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.observer&amp;&amp;this.observer.observe(this.view.dom,Ha),qa&amp;&amp;this.view.dom.addEventListener("DOMCharacterDataModified",this.onCharData),this.connectSelection()}</span>,Wa.prototype.stop=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.observer){var e=<span class="cstat-no" title="statement not covered" >this.observer.takeRecords();<span class="cstat-no" title="statement not covered" ></span>if(e.length){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >this.queue.push(e[n]);<span class="cstat-no" title="statement not covered" >w</span></span>indow.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.flush()}</span>),20)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.observer.disconnect()}<span class="cstat-no" title="statement not covered" ></span>q</span>a&amp;&amp;this.view.dom.removeEventListener("DOMCharacterDataModified",this.onCharData),this.disconnectSelection()}</span>,Wa.prototype.connectSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.view.dom.ownerDocument.addEventListener("selectionchange",this.onSelectionChange)}</span>,Wa.prototype.disconnectSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.view.dom.ownerDocument.removeEventListener("selectionchange",this.onSelectionChange)}</span>,Wa.prototype.suppressSelectionUpdates=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.suppressingSelectionUpdates=!0,setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.suppressingSelectionUpdates=!1}</span>),50)}</span>,Wa.prototype.onSelectionChange=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(ra(this.view)){<span class="cstat-no" title="statement not covered" >if(this.suppressingSelectionUpdates)<span class="cstat-no" title="statement not covered" >return Ks(this.view);<span class="cstat-no" title="statement not covered" >i</span></span>f(gi.ie&amp;&amp;gi.ie_version&lt;=11&amp;&amp;!this.view.state.selection.empty){var t=<span class="cstat-no" title="statement not covered" >this.view.root.getSelection();<span class="cstat-no" title="statement not covered" ></span>if(t.focusNode&amp;&amp;Ei(t.focusNode,t.focusOffset,t.anchorNode,t.anchorOffset))<span class="cstat-no" title="statement not covered" >return this.flushSoon()}<span class="cstat-no" title="statement not covered" ></span></span>t</span>his.flush()}</span>}</span>,Wa.prototype.setCurSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.currentSelection.set(this.view.root.getSelection())}</span>,Wa.prototype.ignoreSelectionChange=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(0==t.rangeCount)<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >t.getRangeAt(0).commonAncestorContainer,</span>n=<span class="cstat-no" title="statement not covered" >this.view.docView.nearestDesc(e);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;n.ignoreMutation({type:"selection",target:3==e.nodeType?e.parentNode:e})?(this.setCurSelection(),!0):void 0}</span>,Wa.prototype.flush=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.view.docView&amp;&amp;!(this.flushingSoon&gt;-1)){var t=<span class="cstat-no" title="statement not covered" >this.observer?this.observer.takeRecords():[];<span class="cstat-no" title="statement not covered" ></span>this.queue.length&amp;&amp;(t=this.queue.concat(t),this.queue.length=0);v</span>ar e=<span class="cstat-no" title="statement not covered" >this.view.root.getSelection(),</span>n=<span class="cstat-no" title="statement not covered" >!this.suppressingSelectionUpdates&amp;&amp;!this.currentSelection.eq(e)&amp;&amp;oa(this.view)&amp;&amp;!this.ignoreSelectionChange(e),</span>r=<span class="cstat-no" title="statement not covered" >-1,</span>o=<span class="cstat-no" title="statement not covered" >-1,</span>i=<span class="cstat-no" title="statement not covered" >!1,</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(this.view.editable)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;t.length;a++){var c=<span class="cstat-no" title="statement not covered" >this.registerMutation(t[a],s);<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;(r=r&lt;0?c.from:Math.min(c.from,r),o=o&lt;0?c.to:Math.max(c.to,o),c.typeOver&amp;&amp;(i=!0))}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(gi.gecko&amp;&amp;s.length&gt;1){var l=<span class="cstat-no" title="statement not covered" >s.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"BR"==t.nodeName}</span>));<span class="cstat-no" title="statement not covered" ></span>if(2==l.length){var p=<span class="cstat-no" title="statement not covered" >l[0],</span>u=<span class="cstat-no" title="statement not covered" >l[1];<span class="cstat-no" title="statement not covered" ></span>p.parentNode&amp;&amp;p.parentNode.parentNode==u.parentNode?u.remove():p.remove()}</span>}<span class="cstat-no" title="statement not covered" ></span>(</span>r&gt;-1||n)&amp;&amp;(r&gt;-1&amp;&amp;(this.view.docView.markDirty(r,o),Ua(this.view)),this.handleDOMChange(r,o,i,s),this.view.docView.dirty?this.view.updateState(this.view.state):this.currentSelection.eq(e)||Ks(this.view),this.currentSelection.set(e))}</span>}</span>,Wa.prototype.registerMutation=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(e.indexOf(t.target)&gt;-1)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.view.docView.nearestDesc(t.target);<span class="cstat-no" title="statement not covered" ></span>if("attributes"==t.type&amp;&amp;(n==this.view.docView||"contenteditable"==t.attributeName||"style"==t.attributeName&amp;&amp;!t.oldValue&amp;&amp;!t.target.getAttribute("style")))<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(!n||n.ignoreMutation(t))<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f("childList"==t.type){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.addedNodes.length;r++)<span class="cstat-no" title="statement not covered" >e.push(t.addedNodes[r]);<span class="cstat-no" title="statement not covered" >i</span></span>f(n.contentDOM&amp;&amp;n.contentDOM!=n.dom&amp;&amp;!n.contentDOM.contains(t.target))<span class="cstat-no" title="statement not covered" >return{from:n.posBefore,to:n.posAfter};v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t.previousSibling,</span>i=<span class="cstat-no" title="statement not covered" >t.nextSibling;<span class="cstat-no" title="statement not covered" ></span>if(gi.ie&amp;&amp;gi.ie_version&lt;=11&amp;&amp;t.addedNodes.length)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t.addedNodes.length;s++){var a=<span class="cstat-no" title="statement not covered" >t.addedNodes[s],</span>c=<span class="cstat-no" title="statement not covered" >a.previousSibling,</span>l=<span class="cstat-no" title="statement not covered" >a.nextSibling;<span class="cstat-no" title="statement not covered" ></span>(!c||Array.prototype.indexOf.call(t.addedNodes,c)&lt;0)&amp;&amp;(o=c),(!l||Array.prototype.indexOf.call(t.addedNodes,l)&lt;0)&amp;&amp;(i=l)}</span>v</span></span>ar p=<span class="cstat-no" title="statement not covered" >o&amp;&amp;o.parentNode==t.target?xi(o)+1:0,</span>u=<span class="cstat-no" title="statement not covered" >n.localPosFromDOM(t.target,p,-1),</span>h=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.parentNode==t.target?xi(i):t.target.childNodes.length,</span>d=<span class="cstat-no" title="statement not covered" >n.localPosFromDOM(t.target,h,1);<span class="cstat-no" title="statement not covered" ></span>return{from:u,to:d}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn"attributes"==t.type?{from:n.posAtStart-n.border,to:n.posAtEnd+n.border}:{from:n.posAtStart,to:n.posAtEnd,typeOver:t.target.nodeValue==t.oldValue}}</span>;v</span>ar Ka=<span class="cstat-no" title="statement not covered" >!1;</span>function <span class="fstat-no" title="function not covered" >Ua(</span>t){<span class="cstat-no" title="statement not covered" >Ka||(Ka=!0,"normal"==getComputedStyle(t.dom).whiteSpace&amp;&amp;console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."))}</span>var Ga=<span class="cstat-no" title="statement not covered" >{},</span>Ya=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >Xa(</span>t){<span class="cstat-no" title="statement not covered" >t.shiftKey=!1,t.mouseDown=null,t.lastKeyCode=null,t.lastKeyCodeTime=0,t.lastClick={time:0,x:0,y:0,type:""},t.lastSelectionOrigin=null,t.lastSelectionTime=0,t.lastIOSEnter=0,t.lastIOSEnterFallbackTimeout=null,t.lastAndroidDelete=0,t.composing=!1,t.composingTimeout=null,t.compositionNodes=[],t.compositionEndedAt=-2e8,t.domObserver=new Wa(t,(<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r,o){<span class="cstat-no" title="statement not covered" >return xa(t,e,n,r,o)}</span>)),t.domObserver.start(),t.domChangeCount=0,t.eventHandlers=Object.create(null);v</span>ar e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >Ga[e];<span class="cstat-no" title="statement not covered" ></span>t.dom.addEventListener(e,t.eventHandlers[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >!nc(t,e)||ec(t,e)||!t.editable&amp;&amp;e.type in Ya||n(t,e)}</span>)}</span>;<span class="cstat-no" title="statement not covered" ></span>for(var n in Ga)<span class="cstat-no" title="statement not covered" >e(n);<span class="cstat-no" title="statement not covered" >g</span></span>i.safari&amp;&amp;t.dom.addEventListener("input",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return null}</span>)),tc(t)}</span>function <span class="fstat-no" title="function not covered" >Qa(</span>t,e){<span class="cstat-no" title="statement not covered" >t.lastSelectionOrigin=e,t.lastSelectionTime=Date.now()}</span>function <span class="fstat-no" title="function not covered" >Za(</span>t){<span class="cstat-no" title="statement not covered" >for(var e in t.domObserver.stop(),t.eventHandlers)<span class="cstat-no" title="statement not covered" >t.dom.removeEventListener(e,t.eventHandlers[e]);<span class="cstat-no" title="statement not covered" >c</span></span>learTimeout(t.composingTimeout),clearTimeout(t.lastIOSEnterFallbackTimeout)}</span>function <span class="fstat-no" title="function not covered" >tc(</span>t){<span class="cstat-no" title="statement not covered" >t.someProp("handleDOMEvents",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var n in e)<span class="cstat-no" title="statement not covered" >t.eventHandlers[n]||t.dom.addEventListener(n,t.eventHandlers[n]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return ec(t,e)}</span>)}</span></span>))}</span>function <span class="fstat-no" title="function not covered" >ec(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.someProp("handleDOMEvents",(<span class="fstat-no" title="function not covered" >fu</span>nction(n){var r=<span class="cstat-no" title="statement not covered" >n[e.type];<span class="cstat-no" title="statement not covered" ></span>return!!r&amp;&amp;(r(t,e)||e.defaultPrevented)}</span>))}</span>function <span class="fstat-no" title="function not covered" >nc(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e.bubbles)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.defaultPrevented)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >e.target;</span>n!=t.dom;n=n.parentNode)<span class="cstat-no" title="statement not covered" >if(!n||11==n.nodeType||n.pmViewDesc&amp;&amp;n.pmViewDesc.stopEvent(e))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >rc(</span>t,e){<span class="cstat-no" title="statement not covered" >ec(t,e)||!Ga[e.type]||!t.editable&amp;&amp;e.type in Ya||Ga[e.type](t,e)}</span>function <span class="fstat-no" title="function not covered" >oc(</span>t){<span class="cstat-no" title="statement not covered" >return{left:t.clientX,top:t.clientY}}</span>function <span class="fstat-no" title="function not covered" >ic(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >e.x-t.clientX,</span>r=<span class="cstat-no" title="statement not covered" >e.y-t.clientY;<span class="cstat-no" title="statement not covered" ></span>return n*n+r*r&lt;100}</span>function <span class="fstat-no" title="function not covered" >sc(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >if(-1==r)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >t.state.doc.resolve(r),</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >if(t.someProp(e,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r&gt;i.depth?e(t,n,i.nodeAfter,i.before(r),o,!0):e(t,n,i.node(r),i.before(r),o,!1)}</span>)))<span class="cstat-no" title="statement not covered" >return{v:!0}}</span></span>,</span>a=<span class="cstat-no" title="statement not covered" >i.depth+1;</span>a&gt;0;a--){var c=<span class="cstat-no" title="statement not covered" >s(a);<span class="cstat-no" title="statement not covered" ></span>if(c)<span class="cstat-no" title="statement not covered" >return c.v}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >ac(</span>t,e,n){<span class="cstat-no" title="statement not covered" >t.focused||t.focus();v</span>ar r=<span class="cstat-no" title="statement not covered" >t.state.tr.setSelection(e);<span class="cstat-no" title="statement not covered" ></span>"pointer"==n&amp;&amp;r.setMeta("pointer",!0),t.dispatch(r)}</span>function <span class="fstat-no" title="function not covered" >cc(</span>t,e){<span class="cstat-no" title="statement not covered" >if(-1==e)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.state.doc.resolve(e),</span>r=<span class="cstat-no" title="statement not covered" >n.nodeAfter;<span class="cstat-no" title="statement not covered" ></span>return!!(r&amp;&amp;r.isAtom&amp;&amp;Go.isSelectable(r))&amp;&amp;(ac(t,new Go(n),"pointer"),!0)}</span>function <span class="fstat-no" title="function not covered" >lc(</span>t,e){<span class="cstat-no" title="statement not covered" >if(-1==e)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar n,r,o=<span class="cstat-no" title="statement not covered" >t.state.selection;<span class="cstat-no" title="statement not covered" ></span>o instanceof Go&amp;&amp;(n=o.node);<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >t.state.doc.resolve(e),</span>s=<span class="cstat-no" title="statement not covered" >i.depth+1;</span>s&gt;0;s--){var a=<span class="cstat-no" title="statement not covered" >s&gt;i.depth?i.nodeAfter:i.node(s);<span class="cstat-no" title="statement not covered" ></span>if(Go.isSelectable(a)){<span class="cstat-no" title="statement not covered" >r=n&amp;&amp;o.$from.depth&gt;0&amp;&amp;s&gt;=o.$from.depth&amp;&amp;i.before(o.$from.depth+1)==o.$from.pos?i.before(o.$from.depth):i.before(s);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null!=r&amp;&amp;(ac(t,Go.create(t.state.doc,r),"pointer"),!0)}</span>function <span class="fstat-no" title="function not covered" >pc(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >return sc(t,"handleClickOn",e,n,r)||t.someProp("handleClick",(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n(t,e,r)}</span>))||(o?lc(t,n):cc(t,n))}</span>function <span class="fstat-no" title="function not covered" >uc(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >return sc(t,"handleDoubleClickOn",e,n,r)||t.someProp("handleDoubleClick",(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n(t,e,r)}</span>))}</span>function <span class="fstat-no" title="function not covered" >hc(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >return sc(t,"handleTripleClickOn",e,n,r)||t.someProp("handleTripleClick",(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n(t,e,r)}</span>))||dc(t,n,r)}</span>function <span class="fstat-no" title="function not covered" >dc(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(0!=n.button)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t.state.doc;<span class="cstat-no" title="statement not covered" ></span>if(-1==e)<span class="cstat-no" title="statement not covered" >return!!r.inlineContent&amp;&amp;(ac(t,Ko.create(r,0,r.content.size),"pointer"),!0);<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >r.resolve(e),</span>i=<span class="cstat-no" title="statement not covered" >o.depth+1;</span>i&gt;0;i--){var s=<span class="cstat-no" title="statement not covered" >i&gt;o.depth?o.nodeAfter:o.node(i),</span>a=<span class="cstat-no" title="statement not covered" >o.before(i);<span class="cstat-no" title="statement not covered" ></span>if(s.inlineContent)<span class="cstat-no" title="statement not covered" >ac(t,Ko.create(r,a+1,a+1+s.content.size),"pointer");e</span>lse{<span class="cstat-no" title="statement not covered" >if(!Go.isSelectable(s))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >a</span></span>c(t,Go.create(r,a),"pointer")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>}</span>function <span class="fstat-no" title="function not covered" >fc(</span>t){<span class="cstat-no" title="statement not covered" >return kc(t)}<span class="cstat-no" title="statement not covered" ></span>Ya.keydown=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t.shiftKey=16==e.keyCode||e.shiftKey,!gc(t,e))<span class="cstat-no" title="statement not covered" >if(229!=e.keyCode&amp;&amp;t.domObserver.forceFlush(),t.lastKeyCode=e.keyCode,t.lastKeyCodeTime=Date.now(),!gi.ios||13!=e.keyCode||e.ctrlKey||e.altKey||e.metaKey)<span class="cstat-no" title="statement not covered" >t.someProp("handleKeyDown",(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n(t,e)}</span>))||wa(t,e)?e.preventDefault():Qa(t,"key");e</span>lse{var n=<span class="cstat-no" title="statement not covered" >Date.now();<span class="cstat-no" title="statement not covered" ></span>t.lastIOSEnter=n,t.lastIOSEnterFallbackTimeout=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.lastIOSEnter==n&amp;&amp;(t.someProp("handleKeyDown",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t,Ri(13,"Enter"))}</span>)),t.lastIOSEnter=0)}</span>),200)}</span>}</span></span>,Ya.keyup=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >16==e.keyCode&amp;&amp;(t.shiftKey=!1)}</span>,Ya.keypress=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!(gc(t,e)||!e.charCode||e.ctrlKey&amp;&amp;!e.altKey||gi.mac&amp;&amp;e.metaKey))<span class="cstat-no" title="statement not covered" >if(t.someProp("handleKeyPress",(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n(t,e)}</span>)))<span class="cstat-no" title="statement not covered" >e.preventDefault();e</span>lse{var n=<span class="cstat-no" title="statement not covered" >t.state.selection;<span class="cstat-no" title="statement not covered" ></span>if(!(n instanceof Ko)||!n.$from.sameParent(n.$to)){var r=<span class="cstat-no" title="statement not covered" >String.fromCharCode(e.charCode);<span class="cstat-no" title="statement not covered" ></span>t.someProp("handleTextInput",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t,n.$from.pos,n.$to.pos,r)}</span>))||t.dispatch(t.state.tr.insertText(r).scrollIntoView()),e.preventDefault()}</span>}</span>}</span></span>;v</span>ar mc=<span class="cstat-no" title="statement not covered" >gi.mac?"metaKey":"ctrlKey";<span class="cstat-no" title="statement not covered" ></span>Ga.mousedown=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.shiftKey=e.shiftKey;v</span>ar n=<span class="cstat-no" title="statement not covered" >fc(t),</span>r=<span class="cstat-no" title="statement not covered" >Date.now(),</span>o=<span class="cstat-no" title="statement not covered" >"singleClick";<span class="cstat-no" title="statement not covered" ></span>r-t.lastClick.time&lt;500&amp;&amp;ic(e,t.lastClick)&amp;&amp;!e[mc]&amp;&amp;("singleClick"==t.lastClick.type?o="doubleClick":"doubleClick"==t.lastClick.type&amp;&amp;(o="tripleClick")),t.lastClick={time:r,x:e.clientX,y:e.clientY,type:o};v</span>ar i=<span class="cstat-no" title="statement not covered" >t.posAtCoords(oc(e));<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;("singleClick"==o?(t.mouseDown&amp;&amp;t.mouseDown.done(),t.mouseDown=new vc(t,i,e,n)):("doubleClick"==o?uc:hc)(t,i.pos,i.inside,e)?e.preventDefault():Qa(t,"pointer"))}</span>;v</span>ar vc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o,i,s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(this.view=t,this.startDoc=t.state.doc,this.pos=e,this.event=n,this.flushed=r,this.selectNode=n[mc],this.allowDefault=n.shiftKey,this.delayedSelectionSync=!1,e.inside&gt;-1)<span class="cstat-no" title="statement not covered" >o=t.state.doc.nodeAt(e.inside),i=e.inside;e</span>lse{var a=<span class="cstat-no" title="statement not covered" >t.state.doc.resolve(e.pos);<span class="cstat-no" title="statement not covered" ></span>o=a.parent,i=a.depth?a.before():0}<span class="cstat-no" title="statement not covered" ></span>t</span>his.mightDrag=null;v</span>ar c=<span class="cstat-no" title="statement not covered" >r?null:n.target,</span>l=<span class="cstat-no" title="statement not covered" >c?t.docView.nearestDesc(c,!0):null;<span class="cstat-no" title="statement not covered" ></span>this.target=l?l.dom:null;v</span>ar p=<span class="cstat-no" title="statement not covered" >t.state,</span>u=<span class="cstat-no" title="statement not covered" >p.selection;<span class="cstat-no" title="statement not covered" ></span>(0==n.button&amp;&amp;o.type.spec.draggable&amp;&amp;!1!==o.type.spec.selectable||u instanceof Go&amp;&amp;u.from&lt;=i&amp;&amp;u.to&gt;i)&amp;&amp;(this.mightDrag={node:o,pos:i,addAttr:this.target&amp;&amp;!this.target.draggable,setUneditable:this.target&amp;&amp;gi.gecko&amp;&amp;!this.target.hasAttribute("contentEditable")}),this.target&amp;&amp;this.mightDrag&amp;&amp;(this.mightDrag.addAttr||this.mightDrag.setUneditable)&amp;&amp;(this.view.domObserver.stop(),this.mightDrag.addAttr&amp;&amp;(this.target.draggable=!0),this.mightDrag.setUneditable&amp;&amp;setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >s.view.mouseDown==s&amp;&amp;s.target.setAttribute("contentEditable","false")}</span>),20),this.view.domObserver.start()),t.root.addEventListener("mouseup",this.up=this.up.bind(this)),t.root.addEventListener("mousemove",this.move=this.move.bind(this)),Qa(t,"pointer")}</span>;</span>function <span class="fstat-no" title="function not covered" >gc(</span>t,e){<span class="cstat-no" title="statement not covered" >return!!t.composing||!!(gi.safari&amp;&amp;Math.abs(e.timeStamp-t.compositionEndedAt)&lt;500)&amp;&amp;(t.compositionEndedAt=-2e8,!0)}<span class="cstat-no" title="statement not covered" ></span>vc.prototype.done=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.view.root.removeEventListener("mouseup",this.up),this.view.root.removeEventListener("mousemove",this.move),this.mightDrag&amp;&amp;this.target&amp;&amp;(this.view.domObserver.stop(),this.mightDrag.addAttr&amp;&amp;this.target.removeAttribute("draggable"),this.mightDrag.setUneditable&amp;&amp;this.target.removeAttribute("contentEditable"),this.view.domObserver.start()),this.delayedSelectionSync&amp;&amp;setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Ks(t.view)}</span>)),this.view.mouseDown=null}</span>,vc.prototype.up=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.done(),this.view.dom.contains(3==t.target.nodeType?t.target.parentNode:t.target)){var e=<span class="cstat-no" title="statement not covered" >this.pos;<span class="cstat-no" title="statement not covered" ></span>this.view.state.doc!=this.startDoc&amp;&amp;(e=this.view.posAtCoords(oc(t))),this.allowDefault||!e?Qa(this.view,"pointer"):pc(this.view,e.pos,e.inside,t,this.selectNode)?t.preventDefault():0==t.button&amp;&amp;(this.flushed||gi.safari&amp;&amp;this.mightDrag&amp;&amp;!this.mightDrag.node.isAtom||gi.chrome&amp;&amp;!(this.view.state.selection instanceof Ko)&amp;&amp;Math.min(Math.abs(e.pos-this.view.state.selection.from),Math.abs(e.pos-this.view.state.selection.to))&lt;=2)?(ac(this.view,qo.near(this.view.state.doc.resolve(e.pos)),"pointer"),t.preventDefault()):Qa(this.view,"pointer")}</span>}</span>,vc.prototype.move=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >!this.allowDefault&amp;&amp;(Math.abs(this.event.x-t.clientX)&gt;4||Math.abs(this.event.y-t.clientY)&gt;4)&amp;&amp;(this.allowDefault=!0),Qa(this.view,"pointer"),0==t.buttons&amp;&amp;this.done()}</span>,Ga.touchdown=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >fc(t),Qa(t,"pointer")}</span>,Ga.contextmenu=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return fc(t)}</span>;v</span>ar yc=<span class="cstat-no" title="statement not covered" >gi.android?5e3:-1;</span>function <span class="fstat-no" title="function not covered" >bc(</span>t,e){<span class="cstat-no" title="statement not covered" >clearTimeout(t.composingTimeout),e&gt;-1&amp;&amp;(t.composingTimeout=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return kc(t)}</span>),e))}</span>function <span class="fstat-no" title="function not covered" >wc(</span>t){<span class="cstat-no" title="statement not covered" >t.composing&amp;&amp;(t.composing=!1,t.compositionEndedAt=Oc());<span class="cstat-no" title="statement not covered" >w</span>hile(t.compositionNodes.length&gt;0)<span class="cstat-no" title="statement not covered" >t.compositionNodes.pop().markParentsDirty()}</span></span>function <span class="fstat-no" title="function not covered" >Oc(</span>){var t=<span class="cstat-no" title="statement not covered" >document.createEvent("Event");<span class="cstat-no" title="statement not covered" ></span>return t.initEvent("event",!0,!0),t.timeStamp}</span>function <span class="fstat-no" title="function not covered" >kc(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.domObserver.forceFlush(),wc(t),e||t.docView.dirty){var n=<span class="cstat-no" title="statement not covered" >Js(t);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;!n.eq(t.state.selection)?t.dispatch(t.state.tr.setSelection(n)):t.updateState(t.state),!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >xc(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.dom.parentNode){var n=<span class="cstat-no" title="statement not covered" >t.dom.parentNode.appendChild(document.createElement("div"));<span class="cstat-no" title="statement not covered" ></span>n.appendChild(e),n.style.cssText="position: fixed; left: -10000px; top: 10px";v</span>ar r=<span class="cstat-no" title="statement not covered" >getSelection(),</span>o=<span class="cstat-no" title="statement not covered" >document.createRange();<span class="cstat-no" title="statement not covered" ></span>o.selectNodeContents(e),t.dom.blur(),r.removeAllRanges(),r.addRange(o),setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.parentNode&amp;&amp;n.parentNode.removeChild(n),t.focus()}</span>),50)}</span>}<span class="cstat-no" title="statement not covered" ></span>Ya.compositionstart=Ya.compositionupdate=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t.composing){<span class="cstat-no" title="statement not covered" >t.domObserver.flush();v</span>ar e=<span class="cstat-no" title="statement not covered" >t.state,</span>n=<span class="cstat-no" title="statement not covered" >e.selection.$from;<span class="cstat-no" title="statement not covered" ></span>if(e.selection.empty&amp;&amp;(e.storedMarks||!n.textOffset&amp;&amp;n.parentOffset&amp;&amp;n.nodeBefore.marks.some((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!1===t.type.spec.inclusive}</span>))))<span class="cstat-no" title="statement not covered" >t.markCursor=t.state.storedMarks||n.marks(),kc(t,!0),t.markCursor=null;e</span>lse <span class="cstat-no" title="statement not covered" >if(kc(t),gi.gecko&amp;&amp;e.selection.empty&amp;&amp;n.parentOffset&amp;&amp;!n.textOffset&amp;&amp;n.nodeBefore.marks.length)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >t.root.getSelection(),</span>o=<span class="cstat-no" title="statement not covered" >r.focusNode,</span>i=<span class="cstat-no" title="statement not covered" >r.focusOffset;</span>o&amp;&amp;1==o.nodeType&amp;&amp;0!=i;){var s=<span class="cstat-no" title="statement not covered" >i&lt;0?o.lastChild:o.childNodes[i-1];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(3==s.nodeType){<span class="cstat-no" title="statement not covered" >r.collapse(s,s.nodeValue.length);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>o</span>=s,i=-1}<span class="cstat-no" title="statement not covered" ></span>t</span></span></span>.composing=!0}<span class="cstat-no" title="statement not covered" ></span>b</span>c(t,yc)}</span>,Ya.compositionend=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.composing&amp;&amp;(t.composing=!1,t.compositionEndedAt=e.timeStamp,bc(t,20))}</span>;v</span>ar Sc=<span class="cstat-no" title="statement not covered" >gi.ie&amp;&amp;gi.ie_version&lt;15||gi.ios&amp;&amp;gi.webkit_version&lt;604;</span>function <span class="fstat-no" title="function not covered" >Mc(</span>t){<span class="cstat-no" title="statement not covered" >return 0==t.openStart&amp;&amp;0==t.openEnd&amp;&amp;1==t.content.childCount?t.content.firstChild:null}</span>function <span class="fstat-no" title="function not covered" >Cc(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.dom.parentNode){var n=<span class="cstat-no" title="statement not covered" >t.shiftKey||t.state.selection.$from.parent.type.spec.code,</span>r=<span class="cstat-no" title="statement not covered" >t.dom.parentNode.appendChild(document.createElement(n?"textarea":"div"));<span class="cstat-no" title="statement not covered" ></span>n||(r.contentEditable="true"),r.style.cssText="position: fixed; left: -10000px; top: 10px",r.focus(),setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.focus(),r.parentNode&amp;&amp;r.parentNode.removeChild(r),n?Ec(t,r.value,null,e):Ec(t,r.textContent,r.innerHTML,e)}</span>),50)}</span>}</span>function <span class="fstat-no" title="function not covered" >Ec(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >ja(t,e,n,t.shiftKey,t.state.selection.$from);<span class="cstat-no" title="statement not covered" ></span>if(t.someProp("handlePaste",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t,r,o||Dn.empty)}</span>)))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!o)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Mc(o),</span>s=<span class="cstat-no" title="statement not covered" >i?t.state.tr.replaceSelectionWith(i,t.shiftKey):t.state.tr.replaceSelection(o);<span class="cstat-no" title="statement not covered" ></span>return t.dispatch(s.scrollIntoView().setMeta("paste",!0).setMeta("uiEvent","paste")),!0}<span class="cstat-no" title="statement not covered" ></span>Ga.copy=Ya.cut=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >t.state.selection,</span>r=<span class="cstat-no" title="statement not covered" >"cut"==e.type;<span class="cstat-no" title="statement not covered" ></span>if(!n.empty){var o=<span class="cstat-no" title="statement not covered" >Sc?null:e.clipboardData,</span>i=<span class="cstat-no" title="statement not covered" >n.content(),</span>s=<span class="cstat-no" title="statement not covered" >Na(t,i),</span>a=<span class="cstat-no" title="statement not covered" >s.dom,</span>c=<span class="cstat-no" title="statement not covered" >s.text;<span class="cstat-no" title="statement not covered" ></span>o?(e.preventDefault(),o.clearData(),o.setData("text/html",a.innerHTML),o.setData("text/plain",c)):xc(t,a),r&amp;&amp;t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent","cut"))}</span>}</span>,Ya.paste=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Sc?null:e.clipboardData;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;Ec(t,n.getData("text/plain"),n.getData("text/html"),e)?e.preventDefault():Cc(t,e)}</span>;v</span>ar Tc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.slice=t,this.move=e}</span>,</span>Nc=<span class="cstat-no" title="statement not covered" >gi.mac?"altKey":"ctrlKey";<span class="cstat-no" title="statement not covered" ></span>for(var jc in Ga.dragstart=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >t.mouseDown;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;n.done(),e.dataTransfer){var r=<span class="cstat-no" title="statement not covered" >t.state.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.empty?null:t.posAtCoords(oc(e));<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;o.pos&gt;=r.from&amp;&amp;o.pos&lt;=(r instanceof Go?r.to-1:r.to));else <span class="cstat-no" title="statement not covered" >if(n&amp;&amp;n.mightDrag)<span class="cstat-no" title="statement not covered" >t.dispatch(t.state.tr.setSelection(Go.create(t.state.doc,n.mightDrag.pos)));e</span>lse <span class="cstat-no" title="statement not covered" >if(e.target&amp;&amp;1==e.target.nodeType){var i=<span class="cstat-no" title="statement not covered" >t.docView.nearestDesc(e.target,!0);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i.node.type.spec.draggable&amp;&amp;i!=t.docView&amp;&amp;t.dispatch(t.state.tr.setSelection(Go.create(t.state.doc,i.posBefore)))}</span>v</span></span></span>ar s=<span class="cstat-no" title="statement not covered" >t.state.selection.content(),</span>a=<span class="cstat-no" title="statement not covered" >Na(t,s),</span>c=<span class="cstat-no" title="statement not covered" >a.dom,</span>l=<span class="cstat-no" title="statement not covered" >a.text;<span class="cstat-no" title="statement not covered" ></span>e.dataTransfer.clearData(),e.dataTransfer.setData(Sc?"Text":"text/html",c.innerHTML),e.dataTransfer.effectAllowed="copyMove",Sc||e.dataTransfer.setData("text/plain",l),t.dragging=new Tc(s,!e[Nc])}</span>}</span>,Ga.dragend=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.dragging;<span class="cstat-no" title="statement not covered" ></span>window.setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.dragging==e&amp;&amp;(t.dragging=null)}</span>),50)}</span>,Ya.dragover=Ya.dragenter=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.preventDefault()}</span>,Ya.drop=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >t.dragging;<span class="cstat-no" title="statement not covered" ></span>if(t.dragging=null,e.dataTransfer){var r=<span class="cstat-no" title="statement not covered" >t.posAtCoords(oc(e));<span class="cstat-no" title="statement not covered" ></span>if(r){var o=<span class="cstat-no" title="statement not covered" >t.state.doc.resolve(r.pos);<span class="cstat-no" title="statement not covered" ></span>if(o){var i=<span class="cstat-no" title="statement not covered" >n&amp;&amp;n.slice;<span class="cstat-no" title="statement not covered" ></span>i?t.someProp("transformPasted",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i=t(i)}</span>)):i=ja(t,e.dataTransfer.getData(Sc?"Text":"text/plain"),Sc?null:e.dataTransfer.getData("text/html"),!1,o);v</span>ar s=<span class="cstat-no" title="statement not covered" >n&amp;&amp;!e[Nc];<span class="cstat-no" title="statement not covered" ></span>if(t.someProp("handleDrop",(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n(t,e,i||Dn.empty,s)}</span>)))<span class="cstat-no" title="statement not covered" >e.preventDefault();e</span>lse <span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >e.preventDefault();v</span>ar a=<span class="cstat-no" title="statement not covered" >i?Eo(t.state.doc,o.pos,i):o.pos;<span class="cstat-no" title="statement not covered" ></span>null==a&amp;&amp;(a=o.pos);v</span>ar c=<span class="cstat-no" title="statement not covered" >t.state.tr;<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;c.deleteSelection();v</span>ar l=<span class="cstat-no" title="statement not covered" >c.mapping.map(a),</span>p=<span class="cstat-no" title="statement not covered" >0==i.openStart&amp;&amp;0==i.openEnd&amp;&amp;1==i.content.childCount,</span>u=<span class="cstat-no" title="statement not covered" >c.doc;<span class="cstat-no" title="statement not covered" ></span>if(p?c.replaceRangeWith(l,l,i.content.firstChild):c.replaceRange(l,l,i),!c.doc.eq(u)){var h=<span class="cstat-no" title="statement not covered" >c.doc.resolve(l);<span class="cstat-no" title="statement not covered" ></span>if(p&amp;&amp;Go.isSelectable(i.content.firstChild)&amp;&amp;h.nodeAfter&amp;&amp;h.nodeAfter.sameMarkup(i.content.firstChild))<span class="cstat-no" title="statement not covered" >c.setSelection(new Go(h));e</span>lse{var d=<span class="cstat-no" title="statement not covered" >c.mapping.map(a);<span class="cstat-no" title="statement not covered" ></span>c.mapping.maps[c.mapping.maps.length-1].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return d=r}</span>)),c.setSelection(na(t,h,c.doc.resolve(d)))}<span class="cstat-no" title="statement not covered" ></span>t</span>.focus(),t.dispatch(c.setMeta("uiEvent","drop"))}</span>}</span>}</span></span>}</span>}</span>}</span>,Ga.focus=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.focused||(t.domObserver.stop(),t.dom.classList.add("ProseMirror-focused"),t.domObserver.start(),t.focused=!0,setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >t.docView&amp;&amp;t.hasFocus()&amp;&amp;!t.domObserver.currentSelection.eq(t.root.getSelection())&amp;&amp;Ks(t)}</span>),20))}</span>,Ga.blur=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >t.focused&amp;&amp;(t.domObserver.stop(),t.dom.classList.remove("ProseMirror-focused"),t.domObserver.start(),e.relatedTarget&amp;&amp;t.dom.contains(e.relatedTarget)&amp;&amp;t.domObserver.currentSelection.set({}),t.focused=!1)}</span>,Ga.beforeinput=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(gi.chrome&amp;&amp;gi.android&amp;&amp;"deleteContentBackward"==e.inputType){var n=<span class="cstat-no" title="statement not covered" >t.domChangeCount;<span class="cstat-no" title="statement not covered" ></span>setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(t.domChangeCount==n&amp;&amp;(t.dom.blur(),t.focus(),!t.someProp("handleKeyDown",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e(t,Ri(8,"Backspace"))}</span>)))){var e=<span class="cstat-no" title="statement not covered" >t.state.selection,</span>r=<span class="cstat-no" title="statement not covered" >e.$cursor;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;r.pos&gt;0&amp;&amp;t.dispatch(t.state.tr.delete(r.pos-1,r.pos).scrollIntoView())}</span>}</span>),50)}</span>}</span>,Ya)<span class="cstat-no" title="statement not covered" >Ga[jc]=Ya[jc];f</span></span>unction <span class="fstat-no" title="function not covered" >Ac(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t==e)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n in t)<span class="cstat-no" title="statement not covered" >if(t[n]!==e[n])<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(var r in e)<span class="cstat-no" title="statement not covered" >if(!(r in t))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>var Ic=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.spec=e||Bc,this.side=this.spec.side||0,this.toDOM=t}</span>;<span class="cstat-no" title="statement not covered" ></span>Ic.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >t.mapResult(e.from+r,this.side&lt;0?-1:1),</span>i=<span class="cstat-no" title="statement not covered" >o.pos,</span>s=<span class="cstat-no" title="statement not covered" >o.deleted;<span class="cstat-no" title="statement not covered" ></span>return s?null:new _c(i-n,i-n,this)}</span>,Ic.prototype.valid=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!0}</span>,Ic.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this==t||t instanceof Ic&amp;&amp;(this.spec.key&amp;&amp;this.spec.key==t.spec.key||this.toDOM==t.toDOM&amp;&amp;Ac(this.spec,t.spec))}</span>;v</span>ar Dc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.spec=e||Bc,this.attrs=t}</span>;<span class="cstat-no" title="statement not covered" ></span>Dc.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >t.map(e.from+r,this.spec.inclusiveStart?-1:1)-n,</span>i=<span class="cstat-no" title="statement not covered" >t.map(e.to+r,this.spec.inclusiveEnd?1:-1)-n;<span class="cstat-no" title="statement not covered" ></span>return o&gt;=i?null:new _c(o,i,this)}</span>,Dc.prototype.valid=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.from&lt;e.to}</span>,Dc.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this==t||t instanceof Dc&amp;&amp;Ac(this.attrs,t.attrs)&amp;&amp;Ac(this.spec,t.spec)}</span>,Dc.is=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.type instanceof Dc}</span>;v</span>ar Rc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.spec=e||Bc,this.attrs=t}</span>;<span class="cstat-no" title="statement not covered" ></span>Rc.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >t.mapResult(e.from+r,1);<span class="cstat-no" title="statement not covered" ></span>if(o.deleted)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >t.mapResult(e.to+r,-1);<span class="cstat-no" title="statement not covered" ></span>return i.deleted||i.pos&lt;=o.pos?null:new _c(o.pos-n,i.pos-n,this)}</span>,Rc.prototype.valid=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n,r=<span class="cstat-no" title="statement not covered" >t.content.findIndex(e.from),</span>o=<span class="cstat-no" title="statement not covered" >r.index,</span>i=<span class="cstat-no" title="statement not covered" >r.offset;<span class="cstat-no" title="statement not covered" ></span>return i==e.from&amp;&amp;!(n=t.child(o)).isText&amp;&amp;i+n.nodeSize==e.to}</span>,Rc.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this==t||t instanceof Rc&amp;&amp;Ac(this.attrs,t.attrs)&amp;&amp;Ac(this.spec,t.spec)}</span>;v</span>ar _c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.from=t,this.to=e,this.type=n}</span>,</span>Pc=<span class="cstat-no" title="statement not covered" >{spec:{configurable:!0},inline:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>_c.prototype.copy=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new _c(t,e,this.type)}</span>,_c.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=0),this.type.eq(t.type)&amp;&amp;this.from+e==t.from&amp;&amp;this.to+e==t.to}</span>,_c.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return this.type.map(t,this,e,n)}</span>,_c.widget=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return new _c(t,t,new Ic(e,n))}</span>,_c.inline=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return new _c(t,e,new Dc(n,r))}</span>,_c.node=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return new _c(t,e,new Rc(n,r))}</span>,Pc.spec.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.spec}</span>,Pc.inline.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type instanceof Dc}</span>,Object.defineProperties(_c.prototype,Pc);v</span>ar zc=<span class="cstat-no" title="statement not covered" >[],</span>Bc=<span class="cstat-no" title="statement not covered" >{},</span>Lc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.local=t&amp;&amp;t.length?t:zc,this.children=e&amp;&amp;e.length?e:zc}</span>;<span class="cstat-no" title="statement not covered" ></span>Lc.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.length?Kc(e,t,0,Bc):Vc}</span>,Lc.prototype.find=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.findInner(null==t?0:t,null==e?1e9:e,r,0,n),r}</span>,Lc.prototype.findInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.local.length;i++){var s=<span class="cstat-no" title="statement not covered" >this.local[i];<span class="cstat-no" title="statement not covered" ></span>s.from&lt;=e&amp;&amp;s.to&gt;=t&amp;&amp;(!o||o(s.spec))&amp;&amp;n.push(s.copy(s.from+r,s.to+r))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;this.children.length;a+=3)<span class="cstat-no" title="statement not covered" >if(this.children[a]&lt;e&amp;&amp;this.children[a+1]&gt;t){var c=<span class="cstat-no" title="statement not covered" >this.children[a]+1;<span class="cstat-no" title="statement not covered" ></span>this.children[a+2].findInner(t-c,e-c,n,r+c,o)}</span>}</span></span>,Lc.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return this==Vc||0==t.maps.length?this:this.mapInner(t,e,0,0,n||Bc)}</span>,Lc.prototype.mapInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o){<span class="cstat-no" title="statement not covered" >for(var i,s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;this.local.length;s++){var a=<span class="cstat-no" title="statement not covered" >this.local[s].map(t,n,r);<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;a.type.valid(e,a)?(i||(i=[])).push(a):o.onRemove&amp;&amp;o.onRemove(this.local[s].spec)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.children.length?Fc(this.children,i,t,e,n,r,o):i?new Lc(i.sort(Uc)):Vc}</span>,Lc.prototype.add=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e.length?this==Vc?Lc.create(t,e):this.addInner(t,e,0):this}</span>,Lc.prototype.addInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r,o=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,s){var a,c=<span class="cstat-no" title="statement not covered" >s+n;<span class="cstat-no" title="statement not covered" ></span>if(a=Jc(e,t,c)){<span class="cstat-no" title="statement not covered" >r||(r=o.children.slice());<span class="cstat-no" title="statement not covered" >w</span>hile(i&lt;r.length&amp;&amp;r[i]&lt;s)<span class="cstat-no" title="statement not covered" >i+=3;<span class="cstat-no" title="statement not covered" >r</span></span>[i]==s?r[i+2]=r[i+2].addInner(t,a,c+1):r.splice(i,0,s,s+t.nodeSize,Kc(a,t,c+1,Bc)),i+=3}</span>}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >Hc(i?Wc(e):e,-n),</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;s.length;a++)<span class="cstat-no" title="statement not covered" >s[a].type.valid(t,s[a])||s.splice(a--,1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Lc(s.length?this.local.concat(s).sort(Uc):this.local,r||this.children)}</span>,Lc.prototype.remove=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0==t.length||this==Vc?this:this.removeInner(t,0)}</span>,Lc.prototype.removeInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >this.children,</span>r=<span class="cstat-no" title="statement not covered" >this.local,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n.length;o+=3){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >void 0,</span>s=<span class="cstat-no" title="statement not covered" >n[o]+e,</span>a=<span class="cstat-no" title="statement not covered" >n[o+1]+e,</span>c=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >void 0;</span>c&lt;t.length;c++)<span class="cstat-no" title="statement not covered" >(l=t[c])&amp;&amp;l.from&gt;s&amp;&amp;l.to&lt;a&amp;&amp;(t[c]=null,(i||(i=[])).push(l));<span class="cstat-no" title="statement not covered" >i</span></span>f(i){<span class="cstat-no" title="statement not covered" >n==this.children&amp;&amp;(n=this.children.slice());v</span>ar p=<span class="cstat-no" title="statement not covered" >n[o+2].removeInner(i,s+1);<span class="cstat-no" title="statement not covered" ></span>p!=Vc?n[o+2]=p:(n.splice(o,3),o-=3)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.length)<span class="cstat-no" title="statement not covered" >for(var u=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >void 0;</span>u&lt;t.length;u++)<span class="cstat-no" title="statement not covered" >if(h=t[u])<span class="cstat-no" title="statement not covered" >for(var d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;r.length;d++)<span class="cstat-no" title="statement not covered" >r[d].eq(h,e)&amp;&amp;(r==this.local&amp;&amp;(r=this.local.slice()),r.splice(d--,1));<span class="cstat-no" title="statement not covered" >r</span></span></span></span></span>eturn n==this.children&amp;&amp;r==this.local?this:r.length||n.length?new Lc(r,n):Vc}</span>,Lc.prototype.forChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(this==Vc)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.isLeaf)<span class="cstat-no" title="statement not covered" >return Lc.empty;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n,r,o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;this.children.length;o+=3)<span class="cstat-no" title="statement not covered" >if(this.children[o]&gt;=t){<span class="cstat-no" title="statement not covered" >this.children[o]==t&amp;&amp;(n=this.children[o+2]);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >t+1,</span>s=<span class="cstat-no" title="statement not covered" >i+e.content.size,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;this.local.length;a++){var c=<span class="cstat-no" title="statement not covered" >this.local[a];<span class="cstat-no" title="statement not covered" ></span>if(c.from&lt;s&amp;&amp;c.to&gt;i&amp;&amp;c.type instanceof Dc){var l=<span class="cstat-no" title="statement not covered" >Math.max(i,c.from)-i,</span>p=<span class="cstat-no" title="statement not covered" >Math.min(s,c.to)-i;<span class="cstat-no" title="statement not covered" ></span>l&lt;p&amp;&amp;(r||(r=[])).push(c.copy(l,p))}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r){var u=<span class="cstat-no" title="statement not covered" >new Lc(r.sort(Uc));<span class="cstat-no" title="statement not covered" ></span>return n?new $c([u,n]):u}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n||Vc}</span>,Lc.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this==t)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!(t instanceof Lc)||this.local.length!=t.local.length||this.children.length!=t.children.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.local.length;e++)<span class="cstat-no" title="statement not covered" >if(!this.local[e].eq(t.local[e]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.children.length;n+=3)<span class="cstat-no" title="statement not covered" >if(this.children[n]!=t.children[n]||this.children[n+1]!=t.children[n+1]||!this.children[n+2].eq(t.children[n+2]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,Lc.prototype.locals=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Gc(this.localsInner(t))}</span>,Lc.prototype.localsInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this==Vc)<span class="cstat-no" title="statement not covered" >return zc;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.inlineContent||!this.local.some(Dc.is))<span class="cstat-no" title="statement not covered" >return this.local;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.local.length;n++)<span class="cstat-no" title="statement not covered" >this.local[n].type instanceof Dc||e.push(this.local[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>;v</span>ar Vc=<span class="cstat-no" title="statement not covered" >new Lc;<span class="cstat-no" title="statement not covered" ></span>Lc.empty=Vc,Lc.removeOverlap=Gc;v</span>ar $c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.members=t}</span>;</span>function <span class="fstat-no" title="function not covered" >Fc(</span>t,e,n,r,o,i,s){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >t.slice(),</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a.length;s+=3){var c=<span class="cstat-no" title="statement not covered" >a[s+1],</span>l=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>-1==c||t&gt;c+i||(e&gt;=a[s]+i?a[s+1]=-1:n&gt;=o&amp;&amp;(l=r-n-(e-t))&amp;&amp;(a[s]+=l,a[s+1]+=l))}</span>}</span>,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;n.maps.length;l++)<span class="cstat-no" title="statement not covered" >n.maps[l].forEach(c);<span class="cstat-no" title="statement not covered" >f</span></span>or(var p=<span class="cstat-no" title="statement not covered" >!1,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;a.length;u+=3)<span class="cstat-no" title="statement not covered" >if(-1==a[u+1]){var h=<span class="cstat-no" title="statement not covered" >n.map(t[u]+i),</span>d=<span class="cstat-no" title="statement not covered" >h-o;<span class="cstat-no" title="statement not covered" ></span>if(d&lt;0||d&gt;=r.content.size){<span class="cstat-no" title="statement not covered" >p=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>v</span>ar f=<span class="cstat-no" title="statement not covered" >n.map(t[u+1]+i,-1),</span>m=<span class="cstat-no" title="statement not covered" >f-o,</span>v=<span class="cstat-no" title="statement not covered" >r.content.findIndex(d),</span>g=<span class="cstat-no" title="statement not covered" >v.index,</span>y=<span class="cstat-no" title="statement not covered" >v.offset,</span>b=<span class="cstat-no" title="statement not covered" >r.maybeChild(g);<span class="cstat-no" title="statement not covered" ></span>if(b&amp;&amp;y==d&amp;&amp;y+b.nodeSize==m){var w=<span class="cstat-no" title="statement not covered" >a[u+2].mapInner(n,b,h+1,t[u]+i+1,s);<span class="cstat-no" title="statement not covered" ></span>w!=Vc?(a[u]=d,a[u+1]=m,a[u+2]=w):(a[u+1]=-2,p=!0)}</span>else <span class="cstat-no" title="statement not covered" >p=!0}<span class="cstat-no" title="statement not covered" ></span></span>i</span></span>f(p){var O=<span class="cstat-no" title="statement not covered" >qc(a,t,e||[],n,o,i,s),</span>k=<span class="cstat-no" title="statement not covered" >Kc(O,r,0,s);<span class="cstat-no" title="statement not covered" ></span>e=k.local;<span class="cstat-no" title="statement not covered" >f</span>or(var x=<span class="cstat-no" title="statement not covered" >0;</span>x&lt;a.length;x+=3)<span class="cstat-no" title="statement not covered" >a[x+1]&lt;0&amp;&amp;(a.splice(x,3),x-=3);<span class="cstat-no" title="statement not covered" >f</span></span>or(var S=<span class="cstat-no" title="statement not covered" >0,</span>M=<span class="cstat-no" title="statement not covered" >0;</span>S&lt;k.children.length;S+=3){var C=<span class="cstat-no" title="statement not covered" >k.children[S];<span class="cstat-no" title="statement not covered" ></span>while(M&lt;a.length&amp;&amp;a[M]&lt;C)<span class="cstat-no" title="statement not covered" >M+=3;<span class="cstat-no" title="statement not covered" >a</span></span>.splice(M,0,k.children[S],k.children[S+1],k.children[S+2])}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Lc(e&amp;&amp;e.sort(Uc),a)}</span>function <span class="fstat-no" title="function not covered" >Hc(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e||!t.length)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++){var o=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>n.push(new _c(o.from+e,o.to+e,o.type))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >qc(</span>t,e,n,r,o,i,s){function <span class="fstat-no" title="function not covered" >a(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.local.length;i++){var c=<span class="cstat-no" title="statement not covered" >t.local[i].map(r,o,e);<span class="cstat-no" title="statement not covered" ></span>c?n.push(c):s.onRemove&amp;&amp;s.onRemove(t.local[i].spec)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;t.children.length;l+=3)<span class="cstat-no" title="statement not covered" >a(t.children[l+2],t.children[l]+e+1)}<span class="cstat-no" title="statement not covered" ></span></span>for(var c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;t.length;c+=3)<span class="cstat-no" title="statement not covered" >-1==t[c+1]&amp;&amp;a(t[c+2],e[c]+i+1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >Jc(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(e.isLeaf)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=<span class="cstat-no" title="statement not covered" >n+e.nodeSize,</span>o=<span class="cstat-no" title="statement not covered" >null,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >void 0;</span>i&lt;t.length;i++)<span class="cstat-no" title="statement not covered" >(s=t[i])&amp;&amp;s.from&gt;n&amp;&amp;s.to&lt;r&amp;&amp;((o||(o=[])).push(s),t[i]=null);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>function <span class="fstat-no" title="function not covered" >Wc(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >null!=t[n]&amp;&amp;e.push(t[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Kc(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,s){var a=<span class="cstat-no" title="statement not covered" >Jc(t,e,s+n);<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >i=!0;v</span>ar c=<span class="cstat-no" title="statement not covered" >Kc(a,e,n+s+1,r);<span class="cstat-no" title="statement not covered" ></span>c!=Vc&amp;&amp;o.push(s,s+e.nodeSize,c)}</span>}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >Hc(i?Wc(t):t,-n).sort(Uc),</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;s.length;a++)<span class="cstat-no" title="statement not covered" >s[a].type.valid(e,s[a])||(r.onRemove&amp;&amp;r.onRemove(s[a].spec),s.splice(a--,1));<span class="cstat-no" title="statement not covered" >r</span></span>eturn s.length||o.length?new Lc(s,o):Vc}</span>function <span class="fstat-no" title="function not covered" >Uc(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.from-e.from||t.to-e.to}</span>function <span class="fstat-no" title="function not covered" >Gc(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length-1;n++){var r=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>if(r.from!=r.to)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >n+1;</span>o&lt;e.length;o++){var i=<span class="cstat-no" title="statement not covered" >e[o];<span class="cstat-no" title="statement not covered" ></span>if(i.from!=r.from){<span class="cstat-no" title="statement not covered" >i.from&lt;r.to&amp;&amp;(e==t&amp;&amp;(e=t.slice()),e[n]=r.copy(r.from,i.from),Yc(e,o,r.copy(i.from,r.to)));<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>.to!=r.to&amp;&amp;(e==t&amp;&amp;(e=t.slice()),e[o]=i.copy(i.from,r.to),Yc(e,o+1,i.copy(r.to,i.to)))}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Yc(</span>t,e,n){<span class="cstat-no" title="statement not covered" >while(e&lt;t.length&amp;&amp;Uc(n,t[e])&gt;0)<span class="cstat-no" title="statement not covered" >e++;<span class="cstat-no" title="statement not covered" >t</span></span>.splice(e,0,n)}</span>function <span class="fstat-no" title="function not covered" >Xc(</span>t){var e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t.someProp("decorations",(<span class="fstat-no" title="function not covered" >fu</span>nction(n){var r=<span class="cstat-no" title="statement not covered" >n(t.state);<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;r!=Vc&amp;&amp;e.push(r)}</span>)),t.cursorWrapper&amp;&amp;e.push(Lc.create(t.state.doc,[t.cursorWrapper.deco])),$c.from(e)}<span class="cstat-no" title="statement not covered" ></span>$c.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this.members.map((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n.map(t,e,Bc)}</span>));<span class="cstat-no" title="statement not covered" ></span>return $c.from(n)}</span>,$c.prototype.forChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(e.isLeaf)<span class="cstat-no" title="statement not covered" >return Lc.empty;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.members.length;r++){var o=<span class="cstat-no" title="statement not covered" >this.members[r].forChild(t,e);<span class="cstat-no" title="statement not covered" ></span>o!=Vc&amp;&amp;(o instanceof $c?n=n.concat(o.members):n.push(o))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn $c.from(n)}</span>,$c.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!(t instanceof $c)||t.members.length!=this.members.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.members.length;e++)<span class="cstat-no" title="statement not covered" >if(!this.members[e].eq(t.members[e]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,$c.prototype.locals=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e,n=<span class="cstat-no" title="statement not covered" >!0,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.members.length;r++){var o=<span class="cstat-no" title="statement not covered" >this.members[r].localsInner(t);<span class="cstat-no" title="statement not covered" ></span>if(o.length)<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >n&amp;&amp;(e=e.slice(),n=!1);<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;o.length;i++)<span class="cstat-no" title="statement not covered" >e.push(o[i])}</span></span>else <span class="cstat-no" title="statement not covered" >e=o}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn e?Gc(n?e:e.sort(Uc)):zc}</span>,$c.from=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >switch(t.length){case 0:<span class="cstat-no" title="statement not covered" >return Vc;c</span>ase 1:<span class="cstat-no" title="statement not covered" >return t[0];d</span>efault:<span class="cstat-no" title="statement not covered" >return new $c(t)}</span>}</span>;v</span>ar Qc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this._props=e,this.state=e.state,this.directPlugins=e.plugins||[],this.directPlugins.forEach(sl),this.dispatch=this.dispatch.bind(this),this._root=null,this.focused=!1,this.trackWrites=null,this.dom=t&amp;&amp;t.mount||document.createElement("div"),t&amp;&amp;(t.appendChild?t.appendChild(this.dom):t.apply?t(this.dom):t.mount&amp;&amp;(this.mounted=!0)),this.editable=nl(this),this.markCursor=null,this.cursorWrapper=null,el(this),this.nodeViews=ol(this),this.docView=Ss(this.state.doc,tl(this),Xc(this),this.dom,this),this.lastSelectedViewDesc=null,this.dragging=null,Xa(this),this.prevDirectPlugins=[],this.pluginViews=[],this.updatePluginViews()}</span>,</span>Zc=<span class="cstat-no" title="statement not covered" >{props:{configurable:!0},root:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >tl(</span>t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>return e.class="ProseMirror",e.contenteditable=String(t.editable),e.translate="no",t.someProp("attributes",(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >if("function"==typeof n&amp;&amp;(n=n(t.state)),n)<span class="cstat-no" title="statement not covered" >for(var r in n)<span class="cstat-no" title="statement not covered" >"class"==r?e.class+=" "+n[r]:e[r]||"contenteditable"==r||"nodeName"==r||(e[r]=String(n[r]))}</span></span></span>)),[_c.node(0,t.state.doc.content.size,e)]}</span>function <span class="fstat-no" title="function not covered" >el(</span>t){<span class="cstat-no" title="statement not covered" >if(t.markCursor){var e=<span class="cstat-no" title="statement not covered" >document.createElement("img");<span class="cstat-no" title="statement not covered" ></span>e.className="ProseMirror-separator",e.setAttribute("mark-placeholder","true"),t.cursorWrapper={dom:e,deco:_c.widget(t.state.selection.head,e,{raw:!0,marks:t.markCursor})}}</span>else <span class="cstat-no" title="statement not covered" >t.cursorWrapper=null}</span></span>function <span class="fstat-no" title="function not covered" >nl(</span>t){<span class="cstat-no" title="statement not covered" >return!t.someProp("editable",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!1===e(t.state)}</span>))}</span>function <span class="fstat-no" title="function not covered" >rl(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >Math.min(t.$anchor.sharedDepth(t.head),e.$anchor.sharedDepth(e.head));<span class="cstat-no" title="statement not covered" ></span>return t.$anchor.start(n)!=e.$anchor.start(n)}</span>function <span class="fstat-no" title="function not covered" >ol(</span>t){var e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return t.someProp("nodeViews",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n])}</span></span>)),e}</span>function <span class="fstat-no" title="function not covered" >il(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(var o in t){<span class="cstat-no" title="statement not covered" >if(t[o]!=e[o])<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >n</span></span>++}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i in e)<span class="cstat-no" title="statement not covered" >r++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n!=r}</span>function <span class="fstat-no" title="function not covered" >sl(</span>t){<span class="cstat-no" title="statement not covered" >if(t.spec.state||t.spec.filterTransaction||t.spec.appendTransaction)<span class="cstat-no" title="statement not covered" >throw new RangeError("Plugins passed directly to the view must not have a state component")}<span class="cstat-no" title="statement not covered" ></span></span>Zc.props.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this._props.state!=this.state){var t=<span class="cstat-no" title="statement not covered" >this._props;<span class="cstat-no" title="statement not covered" ></span>for(var e in this._props={},t)<span class="cstat-no" title="statement not covered" >this._props[e]=t[e];<span class="cstat-no" title="statement not covered" >t</span></span>his._props.state=this.state}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._props}</span>,Qc.prototype.update=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.handleDOMEvents!=this._props.handleDOMEvents&amp;&amp;tc(this),this._props=t,t.plugins&amp;&amp;(t.plugins.forEach(sl),this.directPlugins=t.plugins),this.updateStateInner(t.state,!0)}</span>,Qc.prototype.setProps=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var n in this._props)<span class="cstat-no" title="statement not covered" >e[n]=this._props[n];<span class="cstat-no" title="statement not covered" >f</span></span>or(var r in e.state=this.state,t)<span class="cstat-no" title="statement not covered" >e[r]=t[r];<span class="cstat-no" title="statement not covered" >t</span></span>his.update(e)}</span>,Qc.prototype.updateState=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.updateStateInner(t,this.state.plugins!=t.plugins)}</span>,Qc.prototype.updateStateInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >this.state,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(t.storedMarks&amp;&amp;this.composing&amp;&amp;(wc(this),i=!0),this.state=t,e){var s=<span class="cstat-no" title="statement not covered" >ol(this);<span class="cstat-no" title="statement not covered" ></span>il(s,this.nodeViews)&amp;&amp;(this.nodeViews=s,o=!0),tc(this)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.editable=nl(this),el(this);v</span>ar a=<span class="cstat-no" title="statement not covered" >Xc(this),</span>c=<span class="cstat-no" title="statement not covered" >tl(this),</span>l=<span class="cstat-no" title="statement not covered" >e?"reset":t.scrollToSelection&gt;r.scrollToSelection?"to selection":"preserve",</span>p=<span class="cstat-no" title="statement not covered" >o||!this.docView.matchesNode(t.doc,c,a);<span class="cstat-no" title="statement not covered" ></span>!p&amp;&amp;t.selection.eq(r.selection)||(i=!0);v</span>ar u=<span class="cstat-no" title="statement not covered" >"preserve"==l&amp;&amp;i&amp;&amp;null==this.dom.style.overflowAnchor&amp;&amp;Li(this);<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >this.domObserver.stop();v</span>ar h=<span class="cstat-no" title="statement not covered" >p&amp;&amp;(gi.ie||gi.chrome)&amp;&amp;!this.composing&amp;&amp;!r.selection.empty&amp;&amp;!t.selection.empty&amp;&amp;rl(r.selection,t.selection);<span class="cstat-no" title="statement not covered" ></span>if(p){var d=<span class="cstat-no" title="statement not covered" >gi.chrome?this.trackWrites=this.root.getSelection().focusNode:null;<span class="cstat-no" title="statement not covered" ></span>!o&amp;&amp;this.docView.update(t.doc,c,a,this)||(this.docView.updateOuterDeco([]),this.docView.destroy(),this.docView=Ss(t.doc,c,a,this.dom,this)),d&amp;&amp;!this.trackWrites&amp;&amp;(h=!0)}<span class="cstat-no" title="statement not covered" ></span>h</span>||!(this.mouseDown&amp;&amp;this.domObserver.currentSelection.eq(this.root.getSelection())&amp;&amp;ia(this))?Ks(this,h):(ta(this,t.selection),this.domObserver.setCurSelection()),this.domObserver.start()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.updatePluginViews(r),"reset"==l)<span class="cstat-no" title="statement not covered" >this.dom.scrollTop=0;e</span>lse <span class="cstat-no" title="statement not covered" >if("to selection"==l){var f=<span class="cstat-no" title="statement not covered" >this.root.getSelection().focusNode;<span class="cstat-no" title="statement not covered" ></span>this.someProp("handleScrollToSelection",(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t(n)}</span>))||(t.selection instanceof Go?Bi(this,this.docView.domAfterPos(t.selection.from).getBoundingClientRect(),f):Bi(this,this.coordsAtPos(t.selection.head,1),f))}</span>else <span class="cstat-no" title="statement not covered" >u&amp;&amp;$i(u)}</span></span></span>,Qc.prototype.destroyPluginViews=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t;<span class="cstat-no" title="statement not covered" >while(t=this.pluginViews.pop())<span class="cstat-no" title="statement not covered" >t.destroy&amp;&amp;t.destroy()}</span></span>,Qc.prototype.updatePluginViews=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;t.plugins==this.state.plugins&amp;&amp;this.directPlugins==this.prevDirectPlugins)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.pluginViews.length;e++){var n=<span class="cstat-no" title="statement not covered" >this.pluginViews[e];<span class="cstat-no" title="statement not covered" ></span>n.update&amp;&amp;n.update(this,t)}</span>e</span>lse{<span class="cstat-no" title="statement not covered" >this.prevDirectPlugins=this.directPlugins,this.destroyPluginViews();<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.directPlugins.length;r++){var o=<span class="cstat-no" title="statement not covered" >this.directPlugins[r];<span class="cstat-no" title="statement not covered" ></span>o.spec.view&amp;&amp;this.pluginViews.push(o.spec.view(this))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.state.plugins.length;i++){var s=<span class="cstat-no" title="statement not covered" >this.state.plugins[i];<span class="cstat-no" title="statement not covered" ></span>s.spec.view&amp;&amp;this.pluginViews.push(s.spec.view(this))}</span>}</span>}</span>,Qc.prototype.someProp=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n,r=<span class="cstat-no" title="statement not covered" >this._props&amp;&amp;this._props[t];<span class="cstat-no" title="statement not covered" ></span>if(null!=r&amp;&amp;(n=e?e(r):r))<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;this.directPlugins.length;o++){var i=<span class="cstat-no" title="statement not covered" >this.directPlugins[o].props[t];<span class="cstat-no" title="statement not covered" ></span>if(null!=i&amp;&amp;(n=e?e(i):i))<span class="cstat-no" title="statement not covered" >return n}</span></span>v</span>ar s=<span class="cstat-no" title="statement not covered" >this.state.plugins;<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;s.length;a++){var c=<span class="cstat-no" title="statement not covered" >s[a].props[t];<span class="cstat-no" title="statement not covered" ></span>if(null!=c&amp;&amp;(n=e?e(c):c))<span class="cstat-no" title="statement not covered" >return n}</span></span>}</span></span>,Qc.prototype.hasFocus=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.root.activeElement==this.dom}</span>,Qc.prototype.focus=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.domObserver.stop(),this.editable&amp;&amp;qi(this.dom),Ks(this),this.domObserver.start()}</span>,Zc.root.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this._root;<span class="cstat-no" title="statement not covered" ></span>if(null==t)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.dom.parentNode;</span>e;e=e.parentNode)<span class="cstat-no" title="statement not covered" >if(9==e.nodeType||11==e.nodeType&amp;&amp;e.host)<span class="cstat-no" title="statement not covered" >return e.getSelection||(Object.getPrototypeOf(e).getSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return document.getSelection()}</span>),this._root=e;<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn t||document}</span>,Qc.prototype.posAtCoords=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Qi(this,t)}</span>,Qc.prototype.coordsAtPos=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=1),es(this,t,e)}</span>,Qc.prototype.domAtPos=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=0),this.docView.domFromPos(t,e)}</span>,Qc.prototype.nodeDOM=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.docView.descAt(t);<span class="cstat-no" title="statement not covered" ></span>return e?e.nodeDOM:null}</span>,Qc.prototype.posAtDOM=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=-1);v</span>ar r=<span class="cstat-no" title="statement not covered" >this.docView.posFromDOM(t,e,n);<span class="cstat-no" title="statement not covered" ></span>if(null==r)<span class="cstat-no" title="statement not covered" >throw new RangeError("DOM position not inside the editor");<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,Qc.prototype.endOfTextblock=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return hs(this,e||this.state,t)}</span>,Qc.prototype.destroy=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.docView&amp;&amp;(Za(this),this.destroyPluginViews(),this.mounted?(this.docView.update(this.state.doc,[],Xc(this),this),this.dom.textContent=""):this.dom.parentNode&amp;&amp;this.dom.parentNode.removeChild(this.dom),this.docView.destroy(),this.docView=null)}</span>,Qc.prototype.dispatchEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return rc(this,t)}</span>,Qc.prototype.dispatch=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this._props.dispatchTransaction;<span class="cstat-no" title="statement not covered" ></span>e?e.call(this,t):this.updateState(this.state.apply(t))}</span>,Object.defineProperties(Qc.prototype,Zc);<span class="cstat-no" title="statement not covered" >f</span>or(var al=<span class="cstat-no" title="statement not covered" >{8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",229:"q"},</span>cl=<span class="cstat-no" title="statement not covered" >{48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&amp;",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"&lt;",189:"_",190:"&gt;",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"',229:"Q"},</span>ll=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof navigator&amp;&amp;/Chrome\/(\d+)/.exec(navigator.userAgent),</span>pl=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof navigator&amp;&amp;/Apple Computer/.test(navigator.vendor),</span>ul=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof navigator&amp;&amp;/Gecko\/\d+/.test(navigator.userAgent),</span>hl=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof navigator&amp;&amp;/Mac/.test(navigator.platform),</span>dl=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof navigator&amp;&amp;/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),</span>fl=<span class="cstat-no" title="statement not covered" >ll&amp;&amp;(hl||+ll[1]&lt;57)||ul&amp;&amp;hl,</span>ml=<span class="cstat-no" title="statement not covered" >0;</span>ml&lt;10;ml++)<span class="cstat-no" title="statement not covered" >al[48+ml]=al[96+ml]=String(ml);<span class="cstat-no" title="statement not covered" >f</span></span>or(ml=1;ml&lt;=24;ml++)<span class="cstat-no" title="statement not covered" >al[ml+111]="F"+ml;<span class="cstat-no" title="statement not covered" >f</span></span>or(ml=65;ml&lt;=90;ml++)<span class="cstat-no" title="statement not covered" >al[ml]=String.fromCharCode(ml+32),cl[ml]=String.fromCharCode(ml);<span class="cstat-no" title="statement not covered" >f</span></span>or(var vl in al)<span class="cstat-no" title="statement not covered" >cl.hasOwnProperty(vl)||(cl[vl]=al[vl]);f</span></span>unction <span class="fstat-no" title="function not covered" >gl(</span>t){var e=<span class="cstat-no" title="statement not covered" >fl&amp;&amp;(t.ctrlKey||t.altKey||t.metaKey)||(pl||dl)&amp;&amp;t.shiftKey&amp;&amp;t.key&amp;&amp;1==t.key.length,</span>n=<span class="cstat-no" title="statement not covered" >!e&amp;&amp;t.key||(t.shiftKey?cl:al)[t.keyCode]||t.key||"Unidentified";<span class="cstat-no" title="statement not covered" ></span>return"Esc"==n&amp;&amp;(n="Escape"),"Del"==n&amp;&amp;(n="Delete"),"Left"==n&amp;&amp;(n="ArrowLeft"),"Up"==n&amp;&amp;(n="ArrowUp"),"Right"==n&amp;&amp;(n="ArrowRight"),"Down"==n&amp;&amp;(n="ArrowDown"),n}</span>var yl=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof navigator&amp;&amp;/Mac/.test(navigator.platform);</span>function <span class="fstat-no" title="function not covered" >bl(</span>t){var e,n,r,o,i=<span class="cstat-no" title="statement not covered" >t.split(/-(?!$)/),</span>s=<span class="cstat-no" title="statement not covered" >i[i.length-1];<span class="cstat-no" title="statement not covered" ></span>"Space"==s&amp;&amp;(s=" ");<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;i.length-1;a++){var c=<span class="cstat-no" title="statement not covered" >i[a];<span class="cstat-no" title="statement not covered" ></span>if(/^(cmd|meta|m)$/i.test(c))<span class="cstat-no" title="statement not covered" >o=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(/^a(lt)?$/i.test(c))<span class="cstat-no" title="statement not covered" >e=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(/^(c|ctrl|control)$/i.test(c))<span class="cstat-no" title="statement not covered" >n=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(/^s(hift)?$/i.test(c))<span class="cstat-no" title="statement not covered" >r=!0;e</span>lse{<span class="cstat-no" title="statement not covered" >if(!/^mod$/i.test(c))<span class="cstat-no" title="statement not covered" >throw new Error("Unrecognized modifier name: "+c);<span class="cstat-no" title="statement not covered" >y</span></span>l?o=!0:n=!0}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span></span>r</span>eturn e&amp;&amp;(s="Alt-"+s),n&amp;&amp;(s="Ctrl-"+s),o&amp;&amp;(s="Meta-"+s),r&amp;&amp;(s="Shift-"+s),s}</span>function <span class="fstat-no" title="function not covered" >wl(</span>t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>for(var n in t)<span class="cstat-no" title="statement not covered" >e[bl(n)]=t[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Ol(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return e.altKey&amp;&amp;(t="Alt-"+t),e.ctrlKey&amp;&amp;(t="Ctrl-"+t),e.metaKey&amp;&amp;(t="Meta-"+t),!1!==n&amp;&amp;e.shiftKey&amp;&amp;(t="Shift-"+t),t}</span>function <span class="fstat-no" title="function not covered" >kl(</span>t){<span class="cstat-no" title="statement not covered" >return new di({props:{handleKeyDown:xl(t)}})}</span>function <span class="fstat-no" title="function not covered" >xl(</span>t){var e=<span class="cstat-no" title="statement not covered" >wl(t);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,n){var r,o=<span class="cstat-no" title="statement not covered" >gl(n),</span>i=<span class="cstat-no" title="statement not covered" >1==o.length&amp;&amp;" "!=o,</span>s=<span class="cstat-no" title="statement not covered" >e[Ol(o,n,!i)];<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;s(t.state,t.dispatch,t))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(i&amp;&amp;(n.shiftKey||n.altKey||n.metaKey||o.charCodeAt(0)&gt;127)&amp;&amp;(r=al[n.keyCode])&amp;&amp;r!=o){var a=<span class="cstat-no" title="statement not covered" >e[Ol(r,n,!0)];<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;a(t.state,t.dispatch,t))<span class="cstat-no" title="statement not covered" >return!0}</span></span>else <span class="cstat-no" title="statement not covered" >if(i&amp;&amp;n.shiftKey){var c=<span class="cstat-no" title="statement not covered" >e[Ol(o,n,!0)];<span class="cstat-no" title="statement not covered" ></span>if(c&amp;&amp;c(t.state,t.dispatch,t))<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn!1}</span>}</span>var Sl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.match=t,this.handler="string"==typeof e?Ml(e):e}</span>;</span>function <span class="fstat-no" title="function not covered" >Ml(</span>t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r,o){var i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(n[1]){var s=<span class="cstat-no" title="statement not covered" >n[0].lastIndexOf(n[1]);<span class="cstat-no" title="statement not covered" ></span>i+=n[0].slice(s+n[1].length),r+=s;v</span>ar a=<span class="cstat-no" title="statement not covered" >r-o;<span class="cstat-no" title="statement not covered" ></span>a&gt;0&amp;&amp;(i=n[0].slice(s-a,s)+i,r=o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.tr.insertText(i,r,o)}</span>}</span>var Cl=<span class="cstat-no" title="statement not covered" >500;</span>function <span class="fstat-no" title="function not covered" >El(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.rules,</span>n=<span class="cstat-no" title="statement not covered" >new di({state:{init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return null}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >t.getMeta(this);<span class="cstat-no" title="statement not covered" ></span>return n||(t.selectionSet||t.docChanged?null:e)}</span>},props:{handleTextInput:<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,o,i){<span class="cstat-no" title="statement not covered" >return Tl(t,r,o,i,e,n)}</span>,handleDOMEvents:{compositionend:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){var r=<span class="cstat-no" title="statement not covered" >t.state.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.$cursor;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;Tl(t,o.pos,o.pos,"",e,n)}</span>))}</span>}},isInputRules:!0});<span class="cstat-no" title="statement not covered" ></span>return n}</span>function <span class="fstat-no" title="function not covered" >Tl(</span>t,e,n,r,o,i){<span class="cstat-no" title="statement not covered" >if(t.composing)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >t.state,</span>a=<span class="cstat-no" title="statement not covered" >s.doc.resolve(e);<span class="cstat-no" title="statement not covered" ></span>if(a.parent.type.spec.code)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var c=<span class="cstat-no" title="statement not covered" >a.parent.textBetween(Math.max(0,a.parentOffset-Cl),a.parentOffset,null,"￼")+r,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;o.length;l++){var p=<span class="cstat-no" title="statement not covered" >o[l].match.exec(c),</span>u=<span class="cstat-no" title="statement not covered" >p&amp;&amp;o[l].handler(s,p,e-(p[0].length-r.length),n);<span class="cstat-no" title="statement not covered" ></span>if(u)<span class="cstat-no" title="statement not covered" >return t.dispatch(u.setMeta(i,{transform:u,from:e,to:n,text:r})),!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Nl(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t.plugins,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;n.length;r++){var o=<span class="cstat-no" title="statement not covered" >n[r],</span>i=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>if(o.spec.isInputRules&amp;&amp;(i=o.getState(t))){<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >t.tr,</span>a=<span class="cstat-no" title="statement not covered" >i.transform,</span>c=<span class="cstat-no" title="statement not covered" >a.steps.length-1;</span>c&gt;=0;c--)<span class="cstat-no" title="statement not covered" >s.step(a.steps[c].invert(a.docs[c]));<span class="cstat-no" title="statement not covered" >i</span></span>f(i.text){var l=<span class="cstat-no" title="statement not covered" >s.doc.resolve(i.from).marks();<span class="cstat-no" title="statement not covered" ></span>s.replaceWith(i.from,i.to,t.schema.text(i.text,l))}</span>else <span class="cstat-no" title="statement not covered" >s.delete(i.from,i.to);<span class="cstat-no" title="statement not covered" >e</span></span>(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}<span class="cstat-no" title="statement not covered" ></span>new Sl(/--$/,"—"),new Sl(/\.\.\.$/,"…"),new Sl(/(?:^|[\s\{\[\(\&lt;'"\u2018\u201C])(")$/,"“"),new Sl(/"$/,"”"),new Sl(/(?:^|[\s\{\[\(\&lt;'"\u2018\u201C])(')$/,"‘"),new Sl(/'$/,"’");f</span>unction <span class="fstat-no" title="function not covered" >jl(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >return new Sl(t,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,o,i,s){var a=<span class="cstat-no" title="statement not covered" >n instanceof Function?n(o):n,</span>c=<span class="cstat-no" title="statement not covered" >t.tr.delete(i,s),</span>l=<span class="cstat-no" title="statement not covered" >c.doc.resolve(i),</span>p=<span class="cstat-no" title="statement not covered" >l.blockRange(),</span>u=<span class="cstat-no" title="statement not covered" >p&amp;&amp;yo(p,e,a);<span class="cstat-no" title="statement not covered" ></span>if(!u)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >c</span></span>.wrap(p,u);v</span>ar h=<span class="cstat-no" title="statement not covered" >c.doc.resolve(i-1).nodeBefore;<span class="cstat-no" title="statement not covered" ></span>return h&amp;&amp;h.type==e&amp;&amp;So(c.doc,i-1)&amp;&amp;(!r||r(o,h))&amp;&amp;c.join(i-1),c}</span>))}</span>function <span class="fstat-no" title="function not covered" >Al(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return new Sl(t,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,r,o,i){var s=<span class="cstat-no" title="statement not covered" >t.doc.resolve(o),</span>a=<span class="cstat-no" title="statement not covered" >n instanceof Function?n(r):n;<span class="cstat-no" title="statement not covered" ></span>return s.node(-1).canReplaceWith(s.index(-1),s.indexAfter(-1),e)?t.tr.delete(o,i).setBlockType(o,o,e,a):null}</span>))}</span>function <span class="fstat-no" title="function not covered" >Il(</span>t,e){<span class="cstat-no" title="statement not covered" >return!t.selection.empty&amp;&amp;(e&amp;&amp;e(t.tr.deleteSelection().scrollIntoView()),!0)}</span>function <span class="fstat-no" title="function not covered" >Dl(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.$cursor;<span class="cstat-no" title="statement not covered" ></span>if(!o||(n?!n.endOfTextblock("backward",t):o.parentOffset&gt;0))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Pl(o);<span class="cstat-no" title="statement not covered" ></span>if(!i){var s=<span class="cstat-no" title="statement not covered" >o.blockRange(),</span>a=<span class="cstat-no" title="statement not covered" >s&amp;&amp;go(s);<span class="cstat-no" title="statement not covered" ></span>return null!=a&amp;&amp;(e&amp;&amp;e(t.tr.lift(s,a).scrollIntoView()),!0)}</span>v</span>ar c=<span class="cstat-no" title="statement not covered" >i.nodeBefore;<span class="cstat-no" title="statement not covered" ></span>if(!c.type.spec.isolating&amp;&amp;Yl(t,i,e))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(0==o.parent.content.size&amp;&amp;(Rl(c,"end")||Go.isSelectable(c))){<span class="cstat-no" title="statement not covered" >if(e){var l=<span class="cstat-no" title="statement not covered" >t.tr.deleteRange(o.before(),o.after());<span class="cstat-no" title="statement not covered" ></span>l.setSelection(Rl(c,"end")?qo.findFrom(l.doc.resolve(l.mapping.map(i.pos,-1)),-1):Go.create(l.doc,i.pos-c.nodeSize)),e(l.scrollIntoView())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!(!c.isAtom||i.depth!=o.depth-1)&amp;&amp;(e&amp;&amp;e(t.tr.delete(i.pos-c.nodeSize,i.pos).scrollIntoView()),!0)}</span>function <span class="fstat-no" title="function not covered" >Rl(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(;t;t="start"==e?t.firstChild:t.lastChild){<span class="cstat-no" title="statement not covered" >if(t.isTextblock)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(n&amp;&amp;1!=t.childCount)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >_l(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.$head,</span>i=<span class="cstat-no" title="statement not covered" >r.empty,</span>s=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.parent.isTextblock){<span class="cstat-no" title="statement not covered" >if(n?!n.endOfTextblock("backward",t):o.parentOffset&gt;0)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >s</span></span>=Pl(o)}</span>v</span>ar a=<span class="cstat-no" title="statement not covered" >s&amp;&amp;s.nodeBefore;<span class="cstat-no" title="statement not covered" ></span>return!(!a||!Go.isSelectable(a))&amp;&amp;(e&amp;&amp;e(t.tr.setSelection(Go.create(t.doc,s.pos-a.nodeSize)).scrollIntoView()),!0)}</span>function <span class="fstat-no" title="function not covered" >Pl(</span>t){<span class="cstat-no" title="statement not covered" >if(!t.parent.type.spec.isolating)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.depth-1;</span>e&gt;=0;e--){<span class="cstat-no" title="statement not covered" >if(t.index(e)&gt;0)<span class="cstat-no" title="statement not covered" >return t.doc.resolve(t.before(e+1));<span class="cstat-no" title="statement not covered" >i</span></span>f(t.node(e).type.spec.isolating)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn null}</span>function <span class="fstat-no" title="function not covered" >zl(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.$cursor;<span class="cstat-no" title="statement not covered" ></span>if(!o||(n?!n.endOfTextblock("forward",t):o.parentOffset&lt;o.parent.content.size))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Ll(o);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >i.nodeAfter;<span class="cstat-no" title="statement not covered" ></span>if(Yl(t,i,e))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(0==o.parent.content.size&amp;&amp;(Rl(s,"start")||Go.isSelectable(s))){<span class="cstat-no" title="statement not covered" >if(e){var a=<span class="cstat-no" title="statement not covered" >t.tr.deleteRange(o.before(),o.after());<span class="cstat-no" title="statement not covered" ></span>a.setSelection(Rl(s,"start")?qo.findFrom(a.doc.resolve(a.mapping.map(i.pos)),1):Go.create(a.doc,a.mapping.map(i.pos))),e(a.scrollIntoView())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!(!s.isAtom||i.depth!=o.depth-1)&amp;&amp;(e&amp;&amp;e(t.tr.delete(i.pos,i.pos+s.nodeSize).scrollIntoView()),!0)}</span>function <span class="fstat-no" title="function not covered" >Bl(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.$head,</span>i=<span class="cstat-no" title="statement not covered" >r.empty,</span>s=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.parent.isTextblock){<span class="cstat-no" title="statement not covered" >if(n?!n.endOfTextblock("forward",t):o.parentOffset&lt;o.parent.content.size)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >s</span></span>=Ll(o)}</span>v</span>ar a=<span class="cstat-no" title="statement not covered" >s&amp;&amp;s.nodeAfter;<span class="cstat-no" title="statement not covered" ></span>return!(!a||!Go.isSelectable(a))&amp;&amp;(e&amp;&amp;e(t.tr.setSelection(Go.create(t.doc,s.pos)).scrollIntoView()),!0)}</span>function <span class="fstat-no" title="function not covered" >Ll(</span>t){<span class="cstat-no" title="statement not covered" >if(!t.parent.type.spec.isolating)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.depth-1;</span>e&gt;=0;e--){var n=<span class="cstat-no" title="statement not covered" >t.node(e);<span class="cstat-no" title="statement not covered" ></span>if(t.index(e)+1&lt;n.childCount)<span class="cstat-no" title="statement not covered" >return t.doc.resolve(t.after(e+1));<span class="cstat-no" title="statement not covered" >i</span></span>f(n.type.spec.isolating)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn null}</span>function <span class="fstat-no" title="function not covered" >Vl(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.selection,</span>r=<span class="cstat-no" title="statement not covered" >n.$from,</span>o=<span class="cstat-no" title="statement not covered" >n.$to,</span>i=<span class="cstat-no" title="statement not covered" >r.blockRange(o),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;go(i);<span class="cstat-no" title="statement not covered" ></span>return null!=s&amp;&amp;(e&amp;&amp;e(t.tr.lift(i,s).scrollIntoView()),!0)}</span>function <span class="fstat-no" title="function not covered" >$l(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.selection,</span>r=<span class="cstat-no" title="statement not covered" >n.$head,</span>o=<span class="cstat-no" title="statement not covered" >n.$anchor;<span class="cstat-no" title="statement not covered" ></span>return!(!r.parent.type.spec.code||!r.sameParent(o))&amp;&amp;(e&amp;&amp;e(t.tr.insertText("\n").scrollIntoView()),!0)}</span>function <span class="fstat-no" title="function not covered" >Fl(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.edgeCount;e++){var n=<span class="cstat-no" title="statement not covered" >t.edge(e),</span>r=<span class="cstat-no" title="statement not covered" >n.type;<span class="cstat-no" title="statement not covered" ></span>if(r.isTextblock&amp;&amp;!r.hasRequiredAttrs())<span class="cstat-no" title="statement not covered" >return r}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>function <span class="fstat-no" title="function not covered" >Hl(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.selection,</span>r=<span class="cstat-no" title="statement not covered" >n.$head,</span>o=<span class="cstat-no" title="statement not covered" >n.$anchor;<span class="cstat-no" title="statement not covered" ></span>if(!r.parent.type.spec.code||!r.sameParent(o))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >r.node(-1),</span>s=<span class="cstat-no" title="statement not covered" >r.indexAfter(-1),</span>a=<span class="cstat-no" title="statement not covered" >Fl(i.contentMatchAt(s));<span class="cstat-no" title="statement not covered" ></span>if(!i.canReplaceWith(s,s,a))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(e){var c=<span class="cstat-no" title="statement not covered" >r.after(),</span>l=<span class="cstat-no" title="statement not covered" >t.tr.replaceWith(c,c,a.createAndFill());<span class="cstat-no" title="statement not covered" ></span>l.setSelection(qo.near(l.doc.resolve(c),1)),e(l.scrollIntoView())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >ql(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.selection,</span>r=<span class="cstat-no" title="statement not covered" >n.$from,</span>o=<span class="cstat-no" title="statement not covered" >n.$to;<span class="cstat-no" title="statement not covered" ></span>if(n instanceof Xo||r.parent.inlineContent||o.parent.inlineContent)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Fl(o.parent.contentMatchAt(o.indexAfter()));<span class="cstat-no" title="statement not covered" ></span>if(!i||!i.isTextblock)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(e){var s=<span class="cstat-no" title="statement not covered" >(!r.parentOffset&amp;&amp;o.index()&lt;o.parent.childCount?r:o).pos,</span>a=<span class="cstat-no" title="statement not covered" >t.tr.insert(s,i.createAndFill());<span class="cstat-no" title="statement not covered" ></span>a.setSelection(Ko.create(a.doc,s+1)),e(a.scrollIntoView())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >Jl(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.selection,</span>r=<span class="cstat-no" title="statement not covered" >n.$cursor;<span class="cstat-no" title="statement not covered" ></span>if(!r||r.parent.content.size)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.depth&gt;1&amp;&amp;r.after()!=r.end(-1)){var o=<span class="cstat-no" title="statement not covered" >r.before();<span class="cstat-no" title="statement not covered" ></span>if(xo(t.doc,o))<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e(t.tr.split(o).scrollIntoView()),!0}</span></span>v</span>ar i=<span class="cstat-no" title="statement not covered" >r.blockRange(),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;go(i);<span class="cstat-no" title="statement not covered" ></span>return null!=s&amp;&amp;(e&amp;&amp;e(t.tr.lift(i,s).scrollIntoView()),!0)}</span>function <span class="fstat-no" title="function not covered" >Wl(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.selection,</span>r=<span class="cstat-no" title="statement not covered" >n.$from,</span>o=<span class="cstat-no" title="statement not covered" >n.$to;<span class="cstat-no" title="statement not covered" ></span>if(t.selection instanceof Go&amp;&amp;t.selection.node.isBlock)<span class="cstat-no" title="statement not covered" >return!(!r.parentOffset||!xo(t.doc,r.pos))&amp;&amp;(e&amp;&amp;e(t.tr.split(r.pos).scrollIntoView()),!0);<span class="cstat-no" title="statement not covered" >i</span></span>f(!r.parent.isBlock)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(e){var i=<span class="cstat-no" title="statement not covered" >o.parentOffset==o.parent.content.size,</span>s=<span class="cstat-no" title="statement not covered" >t.tr;<span class="cstat-no" title="statement not covered" ></span>(t.selection instanceof Ko||t.selection instanceof Xo)&amp;&amp;s.deleteSelection();v</span>ar a=<span class="cstat-no" title="statement not covered" >0==r.depth?null:Fl(r.node(-1).contentMatchAt(r.indexAfter(-1))),</span>c=<span class="cstat-no" title="statement not covered" >i&amp;&amp;a?[{type:a}]:null,</span>l=<span class="cstat-no" title="statement not covered" >xo(s.doc,s.mapping.map(r.pos),1,c);<span class="cstat-no" title="statement not covered" ></span>if(c||l||!xo(s.doc,s.mapping.map(r.pos),1,a&amp;&amp;[{type:a}])||(c=[{type:a}],l=!0),l&amp;&amp;(s.split(s.mapping.map(r.pos),1,c),!i&amp;&amp;!r.parentOffset&amp;&amp;r.parent.type!=a)){var p=<span class="cstat-no" title="statement not covered" >s.mapping.map(r.before()),</span>u=<span class="cstat-no" title="statement not covered" >s.doc.resolve(p);<span class="cstat-no" title="statement not covered" ></span>r.node(-1).canReplaceWith(u.index(),u.index()+1,a)&amp;&amp;s.setNodeMarkup(s.mapping.map(r.before()),a)}<span class="cstat-no" title="statement not covered" ></span>e</span>(s.scrollIntoView())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >Kl(</span>t,e){var n,r=<span class="cstat-no" title="statement not covered" >t.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.$from,</span>i=<span class="cstat-no" title="statement not covered" >r.to,</span>s=<span class="cstat-no" title="statement not covered" >o.sharedDepth(i);<span class="cstat-no" title="statement not covered" ></span>return 0!=s&amp;&amp;(n=o.before(s),e&amp;&amp;e(t.tr.setSelection(Go.create(t.doc,n))),!0)}</span>function <span class="fstat-no" title="function not covered" >Ul(</span>t,e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;e(t.tr.setSelection(new Xo(t.doc))),!0}</span>function <span class="fstat-no" title="function not covered" >Gl(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >e.nodeBefore,</span>o=<span class="cstat-no" title="statement not covered" >e.nodeAfter,</span>i=<span class="cstat-no" title="statement not covered" >e.index();<span class="cstat-no" title="statement not covered" ></span>return!!(r&amp;&amp;o&amp;&amp;r.type.compatibleContent(o.type))&amp;&amp;(!r.content.size&amp;&amp;e.parent.canReplace(i-1,i)?(n&amp;&amp;n(t.tr.delete(e.pos-r.nodeSize,e.pos).scrollIntoView()),!0):!(!e.parent.canReplace(i,i+1)||!o.isTextblock&amp;&amp;!So(t.doc,e.pos))&amp;&amp;(n&amp;&amp;n(t.tr.clearIncompatible(e.pos,r.type,r.contentMatchAt(r.childCount)).join(e.pos).scrollIntoView()),!0))}</span>function <span class="fstat-no" title="function not covered" >Yl(</span>t,e,n){var r,o,i=<span class="cstat-no" title="statement not covered" >e.nodeBefore,</span>s=<span class="cstat-no" title="statement not covered" >e.nodeAfter;<span class="cstat-no" title="statement not covered" ></span>if(i.type.spec.isolating||s.type.spec.isolating)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(Gl(t,e,n))<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >e.parent.canReplace(e.index(),e.index()+1);<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;(r=(o=i.contentMatchAt(i.childCount)).findWrapping(s.type))&amp;&amp;o.matchType(r[0]||s.type).validEnd){<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >for(var c=<span class="cstat-no" title="statement not covered" >e.pos+s.nodeSize,</span>l=<span class="cstat-no" title="statement not covered" >Cn.empty,</span>p=<span class="cstat-no" title="statement not covered" >r.length-1;</span>p&gt;=0;p--)<span class="cstat-no" title="statement not covered" >l=Cn.from(r[p].create(null,l));<span class="cstat-no" title="statement not covered" >l</span></span>=Cn.from(i.copy(l));v</span>ar u=<span class="cstat-no" title="statement not covered" >t.tr.step(new fo(e.pos-1,c,e.pos,c,new Dn(l,1,0),r.length,!0)),</span>h=<span class="cstat-no" title="statement not covered" >c+2*r.length;<span class="cstat-no" title="statement not covered" ></span>So(u.doc,h)&amp;&amp;u.join(h),n(u.scrollIntoView())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>v</span>ar d=<span class="cstat-no" title="statement not covered" >qo.findFrom(e,1),</span>f=<span class="cstat-no" title="statement not covered" >d&amp;&amp;d.$from.blockRange(d.$to),</span>m=<span class="cstat-no" title="statement not covered" >f&amp;&amp;go(f);<span class="cstat-no" title="statement not covered" ></span>if(null!=m&amp;&amp;m&gt;=e.depth)<span class="cstat-no" title="statement not covered" >return n&amp;&amp;n(t.tr.lift(f,m).scrollIntoView()),!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(a&amp;&amp;Rl(s,"start",!0)&amp;&amp;Rl(i,"end")){<span class="cstat-no" title="statement not covered" >for(var v=<span class="cstat-no" title="statement not covered" >i,</span>g=<span class="cstat-no" title="statement not covered" >[];</span>;){<span class="cstat-no" title="statement not covered" >if(g.push(v),v.isTextblock)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >v</span></span>=v.lastChild}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var y=<span class="cstat-no" title="statement not covered" >s,</span>b=<span class="cstat-no" title="statement not covered" >1;</span>!y.isTextblock;y=y.firstChild)<span class="cstat-no" title="statement not covered" >b++;<span class="cstat-no" title="statement not covered" >i</span></span>f(v.canReplace(v.childCount,v.childCount,y.content)){<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >for(var w=<span class="cstat-no" title="statement not covered" >Cn.empty,</span>O=<span class="cstat-no" title="statement not covered" >g.length-1;</span>O&gt;=0;O--)<span class="cstat-no" title="statement not covered" >w=Cn.from(g[O].copy(w));v</span></span>ar k=<span class="cstat-no" title="statement not covered" >t.tr.step(new fo(e.pos-g.length,e.pos+s.nodeSize,e.pos+b,e.pos+s.nodeSize-b,new Dn(w,g.length,0),0,!0));<span class="cstat-no" title="statement not covered" ></span>n(k.scrollIntoView())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Xl(</span>t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(n,r){var o=<span class="cstat-no" title="statement not covered" >n.selection,</span>i=<span class="cstat-no" title="statement not covered" >o.$from,</span>s=<span class="cstat-no" title="statement not covered" >o.$to,</span>a=<span class="cstat-no" title="statement not covered" >i.blockRange(s),</span>c=<span class="cstat-no" title="statement not covered" >a&amp;&amp;yo(a,t,e);<span class="cstat-no" title="statement not covered" ></span>return!!c&amp;&amp;(r&amp;&amp;r(n.tr.wrap(a,c).scrollIntoView()),!0)}</span>}</span>function <span class="fstat-no" title="function not covered" >Ql(</span>t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(n,r){var o=<span class="cstat-no" title="statement not covered" >n.selection,</span>i=<span class="cstat-no" title="statement not covered" >o.from,</span>s=<span class="cstat-no" title="statement not covered" >o.to,</span>a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return n.doc.nodesBetween(i,s,(<span class="fstat-no" title="function not covered" >fu</span>nction(r,o){<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.isTextblock&amp;&amp;!r.hasMarkup(t,e))<span class="cstat-no" title="statement not covered" >if(r.type==t)<span class="cstat-no" title="statement not covered" >a=!0;e</span>lse{var i=<span class="cstat-no" title="statement not covered" >n.doc.resolve(o),</span>s=<span class="cstat-no" title="statement not covered" >i.index();<span class="cstat-no" title="statement not covered" ></span>a=i.parent.canReplaceWith(s,s+1,t)}</span>}</span></span>)),!!a&amp;&amp;(r&amp;&amp;r(n.tr.setBlockType(i,s,t,e).scrollIntoView()),!0)}</span>}</span>function <span class="fstat-no" title="function not covered" >Zl(</span>){var t=<span class="cstat-no" title="statement not covered" >[],</span>e=<span class="cstat-no" title="statement not covered" >arguments.length;<span class="cstat-no" title="statement not covered" ></span>while(e--)<span class="cstat-no" title="statement not covered" >t[e]=arguments[e];<span class="cstat-no" title="statement not covered" >r</span></span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t.length;o++)<span class="cstat-no" title="statement not covered" >if(t[o](e,n,r))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>}</span>var tp=<span class="cstat-no" title="statement not covered" >Zl(Il,Dl,_l),</span>ep=<span class="cstat-no" title="statement not covered" >Zl(Il,zl,Bl),</span>np=<span class="cstat-no" title="statement not covered" >{Enter:Zl($l,ql,Jl,Wl),"Mod-Enter":Hl,Backspace:tp,"Mod-Backspace":tp,Delete:ep,"Mod-Delete":ep,"Mod-a":Ul},</span>rp=<span class="cstat-no" title="statement not covered" >{"Ctrl-h":np["Backspace"],"Alt-Backspace":np["Mod-Backspace"],"Ctrl-d":np["Delete"],"Ctrl-Alt-Backspace":np["Mod-Delete"],"Alt-Delete":np["Mod-Delete"],"Alt-d":np["Mod-Delete"]};<span class="cstat-no" title="statement not covered" ></span>for(var op in np)<span class="cstat-no" title="statement not covered" >rp[op]=np[op];<span class="cstat-no" title="statement not covered" >"</span></span>undefined"!=typeof navigator?/Mac/.test(navigator.platform):"undefined"!=typeof os&amp;&amp;os.platform();f</span>unction <span class="fstat-no" title="function not covered" >ip(</span>t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(n,r){var o=<span class="cstat-no" title="statement not covered" >n.selection,</span>i=<span class="cstat-no" title="statement not covered" >o.$from,</span>s=<span class="cstat-no" title="statement not covered" >o.$to,</span>a=<span class="cstat-no" title="statement not covered" >i.blockRange(s),</span>c=<span class="cstat-no" title="statement not covered" >!1,</span>l=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>if(!a)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(a.depth&gt;=2&amp;&amp;i.node(a.depth-1).type.compatibleContent(t)&amp;&amp;0==a.startIndex){<span class="cstat-no" title="statement not covered" >if(0==i.index(a.depth-1))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar p=<span class="cstat-no" title="statement not covered" >n.doc.resolve(a.start-2);<span class="cstat-no" title="statement not covered" ></span>l=new Qn(p,p,a.depth),a.endIndex&lt;a.parent.childCount&amp;&amp;(a=new Qn(i,n.doc.resolve(s.end(a.depth)),a.depth)),c=!0}</span>v</span>ar u=<span class="cstat-no" title="statement not covered" >yo(l,t,e,a);<span class="cstat-no" title="statement not covered" ></span>return!!u&amp;&amp;(r&amp;&amp;r(sp(n.tr,a,u,c,t).scrollIntoView()),!0)}</span>}</span>function <span class="fstat-no" title="function not covered" >sp(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >Cn.empty,</span>s=<span class="cstat-no" title="statement not covered" >n.length-1;</span>s&gt;=0;s--)<span class="cstat-no" title="statement not covered" >i=Cn.from(n[s].type.create(n[s].attrs,i));<span class="cstat-no" title="statement not covered" >t</span></span>.step(new fo(e.start-(r?2:0),e.end,e.start,e.end,new Dn(i,0,0),n.length,!0));<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;n.length;c++)<span class="cstat-no" title="statement not covered" >n[c].type==o&amp;&amp;(a=c+1);<span class="cstat-no" title="statement not covered" >f</span></span>or(var l=<span class="cstat-no" title="statement not covered" >n.length-a,</span>p=<span class="cstat-no" title="statement not covered" >e.start+n.length-(r?2:0),</span>u=<span class="cstat-no" title="statement not covered" >e.parent,</span>h=<span class="cstat-no" title="statement not covered" >e.startIndex,</span>d=<span class="cstat-no" title="statement not covered" >e.endIndex,</span>f=<span class="cstat-no" title="statement not covered" >!0;</span>h&lt;d;h++,f=!1)<span class="cstat-no" title="statement not covered" >!f&amp;&amp;xo(t.doc,p,l)&amp;&amp;(t.split(p,l),p+=2*l),p+=u.child(h).nodeSize;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >ap(</span>t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r=<span class="cstat-no" title="statement not covered" >e.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.$from,</span>i=<span class="cstat-no" title="statement not covered" >r.$to,</span>s=<span class="cstat-no" title="statement not covered" >o.blockRange(i,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.childCount&amp;&amp;e.firstChild.type==t}</span>));<span class="cstat-no" title="statement not covered" ></span>return!!s&amp;&amp;(!n||(o.node(s.depth-1).type==t?cp(e,n,t,s):lp(e,n,s)))}</span>}</span>function <span class="fstat-no" title="function not covered" >cp(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >t.tr,</span>i=<span class="cstat-no" title="statement not covered" >r.end,</span>s=<span class="cstat-no" title="statement not covered" >r.$to.end(r.depth);<span class="cstat-no" title="statement not covered" ></span>return i&lt;s&amp;&amp;(o.step(new fo(i-1,s,i,s,new Dn(Cn.from(n.create(null,r.parent.copy())),1,0),1,!0)),r=new Qn(o.doc.resolve(r.$from.pos),o.doc.resolve(s),r.depth)),e(o.lift(r,go(r)).scrollIntoView()),!0}</span>function <span class="fstat-no" title="function not covered" >lp(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >t.tr,</span>o=<span class="cstat-no" title="statement not covered" >n.parent,</span>i=<span class="cstat-no" title="statement not covered" >n.end,</span>s=<span class="cstat-no" title="statement not covered" >n.endIndex-1,</span>a=<span class="cstat-no" title="statement not covered" >n.startIndex;</span>s&gt;a;s--)<span class="cstat-no" title="statement not covered" >i-=o.child(s).nodeSize,r.delete(i-1,i+1);v</span></span>ar c=<span class="cstat-no" title="statement not covered" >r.doc.resolve(n.start),</span>l=<span class="cstat-no" title="statement not covered" >c.nodeAfter,</span>p=<span class="cstat-no" title="statement not covered" >0==n.startIndex,</span>u=<span class="cstat-no" title="statement not covered" >n.endIndex==o.childCount,</span>h=<span class="cstat-no" title="statement not covered" >c.node(-1),</span>d=<span class="cstat-no" title="statement not covered" >c.index(-1);<span class="cstat-no" title="statement not covered" ></span>if(!h.canReplace(d+(p?0:1),d+1,l.content.append(u?Cn.empty:Cn.from(o))))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar f=<span class="cstat-no" title="statement not covered" >c.pos,</span>m=<span class="cstat-no" title="statement not covered" >f+l.nodeSize;<span class="cstat-no" title="statement not covered" ></span>return r.step(new fo(f-(p?1:0),m+(u?1:0),f+1,m-1,new Dn((p?Cn.empty:Cn.from(o.copy(Cn.empty))).append(u?Cn.empty:Cn.from(o.copy(Cn.empty))),p?0:1,u?0:1),p?0:1)),e(r.scrollIntoView()),!0}</span>function <span class="fstat-no" title="function not covered" >pp(</span>t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r=<span class="cstat-no" title="statement not covered" >e.selection,</span>o=<span class="cstat-no" title="statement not covered" >r.$from,</span>i=<span class="cstat-no" title="statement not covered" >r.$to,</span>s=<span class="cstat-no" title="statement not covered" >o.blockRange(i,(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.childCount&amp;&amp;e.firstChild.type==t}</span>));<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >s.startIndex;<span class="cstat-no" title="statement not covered" ></span>if(0==a)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >s.parent,</span>l=<span class="cstat-no" title="statement not covered" >c.child(a-1);<span class="cstat-no" title="statement not covered" ></span>if(l.type!=t)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(n){var p=<span class="cstat-no" title="statement not covered" >l.lastChild&amp;&amp;l.lastChild.type==c.type,</span>u=<span class="cstat-no" title="statement not covered" >Cn.from(p?t.create():null),</span>h=<span class="cstat-no" title="statement not covered" >new Dn(Cn.from(t.create(null,Cn.from(c.type.create(null,u)))),p?3:1,0),</span>d=<span class="cstat-no" title="statement not covered" >s.start,</span>f=<span class="cstat-no" title="statement not covered" >s.end;<span class="cstat-no" title="statement not covered" ></span>n(e.tr.step(new fo(d-(p?3:1),f,d,f,h,1,!0)).scrollIntoView())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>}</span>function <span class="fstat-no" title="function not covered" >up(</span>t,e){<span class="cstat-no" title="statement not covered" >return e.nodes[t]?"node":e.marks[t]?"mark":null}</span>function <span class="fstat-no" title="function not covered" >hp(</span>t,e){<span class="cstat-no" title="statement not covered" >if("string"===typeof t){<span class="cstat-no" title="statement not covered" >if(!e.nodes[t])<span class="cstat-no" title="statement not covered" >throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.nodes[t]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >dp(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >hp(e,t.schema),</span>{from:r,to:o}=<span class="cstat-no" title="statement not covered" >t.selection;</span>let i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.doc.nodesBetween(r,o,<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >i=[...i,t]}</span>);c</span>onst s=<span class="cstat-no" title="statement not covered" >i.reverse().find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type.name===n.name)</span>;<span class="cstat-no" title="statement not covered" ></span>return s?{...s.attrs}:{}}</span>function <span class="fstat-no" title="function not covered" >fp(</span>t,e){<span class="cstat-no" title="statement not covered" >if("string"===typeof t){<span class="cstat-no" title="statement not covered" >if(!e.marks[t])<span class="cstat-no" title="statement not covered" >throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.marks[t]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >mp(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >fp(e,t.schema),</span>{from:r,to:o,empty:i}=<span class="cstat-no" title="statement not covered" >t.selection;</span>let s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>i?s=t.selection.$head.marks():t.doc.nodesBetween(r,o,<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s=[...s,...t.marks]}</span>);c</span>onst a=<span class="cstat-no" title="statement not covered" >s.find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type.name===n.name)</span>;<span class="cstat-no" title="statement not covered" ></span>return a?{...a.attrs}:{}}</span>function <span class="fstat-no" title="function not covered" >vp(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >up("string"===typeof e?e:e.name,t.schema);<span class="cstat-no" title="statement not covered" ></span>return"node"===n?dp(t,e):"mark"===n?mp(t,e):{}}</span>function <span class="fstat-no" title="function not covered" >gp(</span>t){<span class="cstat-no" title="statement not covered" >return"[object RegExp]"===Object.prototype.toString.call(t)}</span>function <span class="fstat-no" title="function not covered" >yp(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{strict:!0})</span>{const r=<span class="cstat-no" title="statement not covered" >Object.keys(e);<span class="cstat-no" title="statement not covered" ></span>return!r.length||r.every(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >n.strict?e[r]===t[r]:gp(e[r])?e[r].test(t[r]):e[r]===t[r])</span>}</span>function <span class="fstat-no" title="function not covered" >bp(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const{from:r,to:o,empty:i}=<span class="cstat-no" title="statement not covered" >t.selection,</span>s=<span class="cstat-no" title="statement not covered" >e?hp(e,t.schema):null;</span>let a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(t.doc.nodesBetween(r,o,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(!t.isText){const n=<span class="cstat-no" title="statement not covered" >Math.max(r,e),</span>i=<span class="cstat-no" title="statement not covered" >Math.min(o,e+t.nodeSize);<span class="cstat-no" title="statement not covered" ></span>a=[...a,{node:t,from:n,to:i}]}</span>}</span>),i)<span class="cstat-no" title="statement not covered" >return!!a.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!s||s.name===t.node.type.name)</span>.find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >yp(t.node.attrs,n,{strict:!1}))</span>;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >o-r,</span>l=<span class="cstat-no" title="statement not covered" >a.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!s||s.name===t.node.type.name)</span>.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >yp(t.node.attrs,n,{strict:!1}))</span>.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >e.to-e.from;<span class="cstat-no" title="statement not covered" ></span>return t+n}</span>,0);<span class="cstat-no" title="statement not covered" ></span>return l&gt;=c}</span>function <span class="fstat-no" title="function not covered" >wp(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const{from:r,to:o,empty:i}=<span class="cstat-no" title="statement not covered" >t.selection,</span>s=<span class="cstat-no" title="statement not covered" >e?fp(e,t.schema):null;<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return!!(t.storedMarks||t.selection.$from.marks()).filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!s||s.name===t.type.name)</span>.find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >yp(t.attrs,n,{strict:!1}))</span>;l</span></span>et a=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(t.doc.nodesBetween(r,o,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(t.isText){const n=<span class="cstat-no" title="statement not covered" >Math.max(r,e),</span>i=<span class="cstat-no" title="statement not covered" >Math.min(o,e+t.nodeSize),</span>s=<span class="cstat-no" title="statement not covered" >i-n;<span class="cstat-no" title="statement not covered" ></span>a+=s,c=[...c,...t.marks.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{mark:t,from:n,to:i})</span>)]}</span>}</span>),0===a)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst l=<span class="cstat-no" title="statement not covered" >c.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!s||s.name===t.mark.type.name)</span>.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >yp(t.mark.attrs,n,{strict:!1}))</span>.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >e.to-e.from;<span class="cstat-no" title="statement not covered" ></span>return t+n}</span>,0),</span>p=<span class="cstat-no" title="statement not covered" >c.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!s||t.mark.type!==s&amp;&amp;t.mark.type.excludes(s))</span>.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >e.to-e.from;<span class="cstat-no" title="statement not covered" ></span>return t+n}</span>,0),</span>u=<span class="cstat-no" title="statement not covered" >l&gt;0?l+p:l;<span class="cstat-no" title="statement not covered" ></span>return u&gt;=a}</span>function <span class="fstat-no" title="function not covered" >Op(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return bp(t,null,n)||wp(t,null,n);c</span></span>onst r=<span class="cstat-no" title="statement not covered" >up(e,t.schema);<span class="cstat-no" title="statement not covered" ></span>return"node"===r?bp(t,e,n):"mark"===r&amp;&amp;wp(t,e,n)}</span>function <span class="fstat-no" title="function not covered" >kp(</span>t){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.parentNode&amp;&amp;t.parentNode.removeChild(t)}</span>function <span class="fstat-no" title="function not covered" >xp(</span>t){const e=<span class="cstat-no" title="statement not covered" >`&lt;body&gt;${t}&lt;/body&gt;`;<span class="cstat-no" title="statement not covered" ></span>return(new window.DOMParser).parseFromString(e,"text/html").body}</span>function <span class="fstat-no" title="function not covered" >Sp(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(n={slice:!0,parseOptions:{},...n},"object"===typeof t&amp;&amp;null!==t)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return Array.isArray(t)?Cn.fromArray(t.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.nodeFromJSON(t))</span>):e.nodeFromJSON(t)}</span>catch(r){<span class="cstat-no" title="statement not covered" >return console.warn("[tiptap warn]: Invalid content.","Passed value:",t,"Error:",r),Sp("",e,n)}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f("string"===typeof t){const r=<span class="cstat-no" title="statement not covered" >Ar.fromSchema(e);<span class="cstat-no" title="statement not covered" ></span>return n.slice?r.parseSlice(xp(t),n.parseOptions).content:r.parse(xp(t),n.parseOptions)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Sp("",e,n)}</span>function <span class="fstat-no" title="function not covered" >Mp(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return Sp(t,e,{slice:!1,parseOptions:n})}</span>function <span class="fstat-no" title="function not covered" >Cp(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >Ur.fromSchema(e).serializeFragment(t.content),</span>r=<span class="cstat-no" title="statement not covered" >document.implementation.createHTMLDocument(),</span>o=<span class="cstat-no" title="statement not covered" >r.createElement("div");<span class="cstat-no" title="statement not covered" ></span>return o.appendChild(n),o.innerHTML}</span>function <span class="fstat-no" title="function not covered" >Ep(</span>t,e,n){const{from:r,to:o}=<span class="cstat-no" title="statement not covered" >e,</span>{blockSeparator:i=<span class="branch-0 cbranch-no" title="branch not covered" >"\n\n",</span>textSerializers:s=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>=<span class="cstat-no" title="statement not covered" >n||{};</span>let a=<span class="cstat-no" title="statement not covered" >"",</span>c=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>return t.nodesBetween(r,o,<span class="fstat-no" title="function not covered" >(t</span>,e,n,l)=&gt;{var p;const u=<span class="cstat-no" title="statement not covered" >null===s||void 0===s?void 0:s[t.type.name];<span class="cstat-no" title="statement not covered" ></span>u?(t.isBlock&amp;&amp;!c&amp;&amp;(a+=i,c=!0),a+=u({node:t,pos:e,parent:n,index:l})):t.isText?(a+=null===(p=null===t||void 0===t?void 0:t.text)||void 0===p?void 0:p.slice(Math.max(r,e)-e,o-e),c=!1):t.isBlock&amp;&amp;!c&amp;&amp;(a+=i,c=!0)}</span>),a}</span>function <span class="fstat-no" title="function not covered" >Tp(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >{from:0,to:t.content.size};<span class="cstat-no" title="statement not covered" ></span>return Ep(t,n,e)}</span>function <span class="fstat-no" title="function not covered" >Np(</span>t){var e;const n=<span class="cstat-no" title="statement not covered" >null===(e=t.type.createAndFill())||void 0===e?void 0:e.toJSON(),</span>r=<span class="cstat-no" title="statement not covered" >t.toJSON();<span class="cstat-no" title="statement not covered" ></span>return JSON.stringify(n)===JSON.stringify(r)}</span>function <span class="fstat-no" title="function not covered" >jp(</span>t){<span class="cstat-no" title="statement not covered" >return Object.fromEntries(Object.entries(t.nodes).filter(<span class="fstat-no" title="function not covered" >([</span>,t])=&gt;<span class="cstat-no" title="statement not covered" >t.spec.toText)</span>.map(<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;<span class="cstat-no" title="statement not covered" >[t,e.spec.toText])</span>)}</span>function <span class="fstat-no" title="function not covered" >Ap(</span>t){const e=<span class="cstat-no" title="statement not covered" >document.querySelector("style[data-tiptap-style]");<span class="cstat-no" title="statement not covered" ></span>if(null!==e)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >document.createElement("style");<span class="cstat-no" title="statement not covered" ></span>return n.setAttribute("data-tiptap-style",""),n.innerHTML=t,document.getElementsByTagName("head")[0].appendChild(n),n}</span>class Ip{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.editor=t,this.commands=e}<span class="fstat-no" title="function not covered" ></span>cr</span>eateCommands(){const{commands:t,editor:e}=<span class="cstat-no" title="statement not covered" >this,</span>{state:n,view:r}=<span class="cstat-no" title="statement not covered" >e,</span>{tr:o}=<span class="cstat-no" title="statement not covered" >n,</span>i=<span class="cstat-no" title="statement not covered" >this.buildProps(o);<span class="cstat-no" title="statement not covered" ></span>return Object.fromEntries(Object.entries(t).map(<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;{const n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;{const n=<span class="cstat-no" title="statement not covered" >e(...t)(i);<span class="cstat-no" title="statement not covered" ></span>return o.getMeta("preventDispatch")||r.dispatch(o),n}</span>;<span class="cstat-no" title="statement not covered" ></span>return[t,n]}</span>))}<span class="fstat-no" title="function not covered" ></span>cr</span>eateChain(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const{commands:n,editor:r}=<span class="cstat-no" title="statement not covered" >this,</span>{state:o,view:i}=<span class="cstat-no" title="statement not covered" >r,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >!!t,</span>c=<span class="cstat-no" title="statement not covered" >t||o.tr,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >a||!e||c.getMeta("preventDispatch")||i.dispatch(c),s.every(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!0===t)</span>)</span>,</span>p=<span class="cstat-no" title="statement not covered" >{...Object.fromEntries(Object.entries(n).map(<span class="fstat-no" title="function not covered" >([</span>t,n])=&gt;{const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >this.buildProps(c,e),</span>o=<span class="cstat-no" title="statement not covered" >n(...t)(r);<span class="cstat-no" title="statement not covered" ></span>return s.push(o),p}</span>;<span class="cstat-no" title="statement not covered" ></span>return[t,r]}</span>)),run:l};<span class="cstat-no" title="statement not covered" ></span>return p}<span class="fstat-no" title="function not covered" ></span>cr</span>eateCan(t){const{commands:e,editor:n}=<span class="cstat-no" title="statement not covered" >this,</span>{state:r}=<span class="cstat-no" title="statement not covered" >n,</span>o=<span class="cstat-no" title="statement not covered" >void 0,</span>i=<span class="cstat-no" title="statement not covered" >t||r.tr,</span>s=<span class="cstat-no" title="statement not covered" >this.buildProps(i,o),</span>a=<span class="cstat-no" title="statement not covered" >Object.fromEntries(Object.entries(e).map(<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;<span class="cstat-no" title="statement not covered" >[t,<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;<span class="cstat-no" title="statement not covered" >e(...t)({...s,dispatch:o})]</span>)</span>);<span class="cstat-no" title="statement not covered" ></span>return{...a,chain:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.createChain(i,o)}</span>}<span class="fstat-no" title="function not covered" ></span>bu</span>ildProps(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const{editor:n,commands:r}=<span class="cstat-no" title="statement not covered" >this,</span>{state:o,view:i}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>o.storedMarks&amp;&amp;t.setStoredMarks(o.storedMarks);c</span>onst s=<span class="cstat-no" title="statement not covered" >{tr:t,editor:n,view:i,state:this.chainableState(t,o),dispatch:e?<span class="fstat-no" title="function not covered" >()</span>=&gt;{}:void 0,chain:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.createChain(t),</span>can:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.createCan(t),<span class="fstat-no" title="function not covered" ></span>ge</span>t commands(){<span class="cstat-no" title="statement not covered" >return Object.fromEntries(Object.entries(r).map(<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;<span class="cstat-no" title="statement not covered" >[t,<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;<span class="cstat-no" title="statement not covered" >e(...t)(s)]</span>)</span>)}</span>};<span class="cstat-no" title="statement not covered" ></span>return s}<span class="fstat-no" title="function not covered" ></span>ch</span>ainableState(t,e){let{selection:n}=<span class="cstat-no" title="statement not covered" >t,</span>{doc:r}=<span class="cstat-no" title="statement not covered" >t,</span>{storedMarks:o}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return{...e,schema:e.schema,plugins:e.plugins,apply:e.apply.bind(e),applyTransaction:e.applyTransaction.bind(e),reconfigure:e.reconfigure.bind(e),toJSON:e.toJSON.bind(e),<span class="fstat-no" title="function not covered" >ge</span>t storedMarks(){<span class="cstat-no" title="statement not covered" >return o}</span>,<span class="fstat-no" title="function not covered" >ge</span>t selection(){<span class="cstat-no" title="statement not covered" >return n}</span>,<span class="fstat-no" title="function not covered" >ge</span>t doc(){<span class="cstat-no" title="statement not covered" >return r}</span>,<span class="fstat-no" title="function not covered" >ge</span>t tr(){<span class="cstat-no" title="statement not covered" >return n=t.selection,r=t.doc,o=t.storedMarks,t}</span>}}</span>}function <span class="fstat-no" title="function not covered" >Dp(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >if(void 0===t.config[e]&amp;&amp;t.parent)<span class="cstat-no" title="statement not covered" >return Dp(t.parent,e,n);<span class="cstat-no" title="statement not covered" >i</span></span>f("function"===typeof t.config[e]){const r=<span class="cstat-no" title="statement not covered" >t.config[e].bind({...n,parent:t.parent?Dp(t.parent,e,n):null});<span class="cstat-no" title="statement not covered" ></span>return r}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.config[e]}</span>function <span class="fstat-no" title="function not covered" >Rp(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"extension"===t.type)</span>,</span>n=<span class="cstat-no" title="statement not covered" >t.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"node"===t.type)</span>,</span>r=<span class="cstat-no" title="statement not covered" >t.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"mark"===t.type)</span>;<span class="cstat-no" title="statement not covered" ></span>return{baseExtensions:e,nodeExtensions:n,markExtensions:r}}</span>function <span class="fstat-no" title="function not covered" >_p(</span>t){const e=<span class="cstat-no" title="statement not covered" >[],</span>{nodeExtensions:n,markExtensions:r}=<span class="cstat-no" title="statement not covered" >Rp(t),</span>o=<span class="cstat-no" title="statement not covered" >[...n,...r],</span>i=<span class="cstat-no" title="statement not covered" >{default:null,rendered:!0,renderHTML:null,parseHTML:null,keepOnSplit:!0};<span class="cstat-no" title="statement not covered" ></span>return t.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >{name:t.name,options:t.options},</span>r=<span class="cstat-no" title="statement not covered" >Dp(t,"addGlobalAttributes",n);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >r();<span class="cstat-no" title="statement not covered" ></span>o.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.types.forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >Object.entries(t.attributes).forEach(<span class="fstat-no" title="function not covered" >([</span>t,r])=&gt;{<span class="cstat-no" title="statement not covered" >e.push({type:n,name:t,attribute:{...i,...r}})}</span>)}</span>)}</span>)}</span>),o.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >{name:t.name,options:t.options},</span>r=<span class="cstat-no" title="statement not covered" >Dp(t,"addAttributes",n);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >r();<span class="cstat-no" title="statement not covered" ></span>Object.entries(o).forEach(<span class="fstat-no" title="function not covered" >([</span>n,r])=&gt;{<span class="cstat-no" title="statement not covered" >e.push({type:t.name,name:n,attribute:{...i,...r}})}</span>)}</span>),e}</span>function <span class="fstat-no" title="function not covered" >Pp(</span>...t){<span class="cstat-no" title="statement not covered" >return t.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!!t)</span>.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >{...t};<span class="cstat-no" title="statement not covered" ></span>return Object.entries(e).forEach(<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;{const r=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>n[t]=r?"class"===t?[n[t],e].join(" "):"style"===t?[n[t],e].join("; "):e:e}</span>),n}</span>,{})}</span>function <span class="fstat-no" title="function not covered" >zp(</span>t,e){<span class="cstat-no" title="statement not covered" >return e.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.attribute.rendered)</span>.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.attribute.renderHTML?e.attribute.renderHTML(t.attrs)||{}:{[e.name]:t.attrs[e.name]})</span>.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Pp(t,e),</span>{})}</span>function <span class="fstat-no" title="function not covered" >Bp(</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return 0===Object.keys(t).length&amp;&amp;t.constructor===Object}</span>function <span class="fstat-no" title="function not covered" >Lp(</span>t){<span class="cstat-no" title="statement not covered" >return"string"!==typeof t?t:t.match(/^\d*(\.\d+)?$/)?Number(t):"true"===t||"false"!==t&amp;&amp;t}</span>function <span class="fstat-no" title="function not covered" >Vp(</span>t){var e;<span class="cstat-no" title="statement not covered" >return"class"===(null===(e=t.constructor)||void 0===e?void 0:e.toString().substring(0,5))}</span>function <span class="fstat-no" title="function not covered" >$p(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"object"===typeof t&amp;&amp;!Array.isArray(t)&amp;&amp;!Vp(t)}</span>function <span class="fstat-no" title="function not covered" >Fp(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.style?t:{...t,getAttrs:<span class="fstat-no" title="function not covered" >n=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >t.getAttrs?t.getAttrs(n):t.attrs;<span class="cstat-no" title="statement not covered" ></span>if(!1===r)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >e.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.attribute.rendered)</span>.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const r=<span class="cstat-no" title="statement not covered" >e.attribute.parseHTML?e.attribute.parseHTML(n):Lp(n.getAttribute(e.name));<span class="cstat-no" title="statement not covered" ></span>return $p(r)&amp;&amp;console.warn(`[tiptap warn]: BREAKING CHANGE: "parseHTML" for your attribute "${e.name}" returns an object but should return the value itself. If this is expected you can ignore this message. This warning will be removed in one of the next releases. Further information: https://github.com/ueberdosis/tiptap/issues/1863`),null===r||void 0===r?t:{...t,[e.name]:r}}</span>,{});<span class="cstat-no" title="statement not covered" ></span>return{...r,...o}}</span>}}</span>function <span class="fstat-no" title="function not covered" >Hp(</span>t,e,...n){<span class="cstat-no" title="statement not covered" >return"function"===typeof t?e?t.bind(e)(...n):t(...n):t}</span>function <span class="fstat-no" title="function not covered" >qp(</span>t){<span class="cstat-no" title="statement not covered" >return Object.fromEntries(Object.entries(t).filter(<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;<span class="cstat-no" title="statement not covered" >("attrs"!==t||!Bp(e))&amp;&amp;(null!==e&amp;&amp;void 0!==e))</span>)}</span>function <span class="fstat-no" title="function not covered" >Jp(</span>t){var e;const n=<span class="cstat-no" title="statement not covered" >_p(t),</span>{nodeExtensions:r,markExtensions:o}=<span class="cstat-no" title="statement not covered" >Rp(t),</span>i=<span class="cstat-no" title="statement not covered" >null===(e=r.find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Dp(t,"topNode"))</span>)||void 0===e?void 0:e.name,</span>s=<span class="cstat-no" title="statement not covered" >Object.fromEntries(r.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >n.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type===e.name)</span>,</span>o=<span class="cstat-no" title="statement not covered" >{name:e.name,options:e.options},</span>i=<span class="cstat-no" title="statement not covered" >t.reduce(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{const r=<span class="cstat-no" title="statement not covered" >Dp(n,"extendNodeSchema",o);<span class="cstat-no" title="statement not covered" ></span>return{...t,...r?r(e):{}}}</span>,{}),</span>s=<span class="cstat-no" title="statement not covered" >qp({...i,content:Hp(Dp(e,"content",o)),marks:Hp(Dp(e,"marks",o)),group:Hp(Dp(e,"group",o)),inline:Hp(Dp(e,"inline",o)),atom:Hp(Dp(e,"atom",o)),selectable:Hp(Dp(e,"selectable",o)),draggable:Hp(Dp(e,"draggable",o)),code:Hp(Dp(e,"code",o)),defining:Hp(Dp(e,"defining",o)),isolating:Hp(Dp(e,"isolating",o)),attrs:Object.fromEntries(r.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;<span class="cstat-no" title="statement not covered" >return[t.name,{default:null===(e=null===t||void 0===t?void 0:t.attribute)||void 0===e?void 0:e.default}]}</span>))}),</span>a=<span class="cstat-no" title="statement not covered" >Hp(Dp(e,"parseHTML",o));<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(s.parseDOM=a.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Fp(t,r))</span>);c</span>onst c=<span class="cstat-no" title="statement not covered" >Dp(e,"renderHTML",o);<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;(s.toDOM=<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >c({node:t,HTMLAttributes:zp(t,r)}))</span>;c</span>onst l=<span class="cstat-no" title="statement not covered" >Dp(e,"renderText",o);<span class="cstat-no" title="statement not covered" ></span>return l&amp;&amp;(s.toText=l),[e.name,s]}</span>)),</span>a=<span class="cstat-no" title="statement not covered" >Object.fromEntries(o.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >n.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type===e.name)</span>,</span>o=<span class="cstat-no" title="statement not covered" >{name:e.name,options:e.options},</span>i=<span class="cstat-no" title="statement not covered" >t.reduce(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{const r=<span class="cstat-no" title="statement not covered" >Dp(n,"extendMarkSchema",o);<span class="cstat-no" title="statement not covered" ></span>return{...t,...r?r(e):{}}}</span>,{}),</span>s=<span class="cstat-no" title="statement not covered" >qp({...i,inclusive:Hp(Dp(e,"inclusive",o)),excludes:Hp(Dp(e,"excludes",o)),group:Hp(Dp(e,"group",o)),spanning:Hp(Dp(e,"spanning",o)),attrs:Object.fromEntries(r.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;<span class="cstat-no" title="statement not covered" >return[t.name,{default:null===(e=null===t||void 0===t?void 0:t.attribute)||void 0===e?void 0:e.default}]}</span>))}),</span>a=<span class="cstat-no" title="statement not covered" >Hp(Dp(e,"parseHTML",o));<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(s.parseDOM=a.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Fp(t,r))</span>);c</span>onst c=<span class="cstat-no" title="statement not covered" >Dp(e,"renderHTML",o);<span class="cstat-no" title="statement not covered" ></span>return c&amp;&amp;(s.toDOM=<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >c({mark:t,HTMLAttributes:zp(t,r)}))</span>,[e.name,s]}</span>));<span class="cstat-no" title="statement not covered" ></span>return new Nr({topNode:i,nodes:s,marks:a})}</span>function <span class="fstat-no" title="function not covered" >Wp(</span>t,e){<span class="cstat-no" title="statement not covered" >return e.nodes[t]?e.nodes[t]:e.marks[t]?e.marks[t]:null}</span>class Kp{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.splittableMarks=[],this.editor=e,this.extensions=Kp.resolve(t),this.schema=Jp(this.extensions),this.extensions.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;const n=<span class="cstat-no" title="statement not covered" >{name:t.name,options:t.options,editor:this.editor,type:Wp(t.name,this.schema)};<span class="cstat-no" title="statement not covered" ></span>if("mark"===t.type){const r=<span class="cstat-no" title="statement not covered" >null===(e=Hp(Dp(t,"keepOnSplit",n)))||void 0===e||e;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;this.splittableMarks.push(t.name)}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >Dp(t,"onBeforeCreate",n);<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;this.editor.on("beforeCreate",r);c</span>onst o=<span class="cstat-no" title="statement not covered" >Dp(t,"onCreate",n);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;this.editor.on("create",o);c</span>onst i=<span class="cstat-no" title="statement not covered" >Dp(t,"onUpdate",n);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;this.editor.on("update",i);c</span>onst s=<span class="cstat-no" title="statement not covered" >Dp(t,"onSelectionUpdate",n);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;this.editor.on("selectionUpdate",s);c</span>onst a=<span class="cstat-no" title="statement not covered" >Dp(t,"onTransaction",n);<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;this.editor.on("transaction",a);c</span>onst c=<span class="cstat-no" title="statement not covered" >Dp(t,"onFocus",n);<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;this.editor.on("focus",c);c</span>onst l=<span class="cstat-no" title="statement not covered" >Dp(t,"onBlur",n);<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;this.editor.on("blur",l);c</span>onst p=<span class="cstat-no" title="statement not covered" >Dp(t,"onDestroy",n);<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;this.editor.on("destroy",p)}</span>)}<span class="fstat-no" title="function not covered" ></span>st</span>atic resolve(t){<span class="cstat-no" title="statement not covered" >return Kp.sort(Kp.flatten(t))}<span class="fstat-no" title="function not covered" ></span>st</span>atic flatten(t){<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >{name:t.name,options:t.options},</span>n=<span class="cstat-no" title="statement not covered" >Dp(t,"addExtensions",e);<span class="cstat-no" title="statement not covered" ></span>return n?[t,...this.flatten(n())]:t}</span>).flat(10)}<span class="fstat-no" title="function not covered" ></span>st</span>atic sort(t){const e=<span class="cstat-no" title="statement not covered" >100;<span class="cstat-no" title="statement not covered" ></span>return t.sort(<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;{const r=<span class="cstat-no" title="statement not covered" >Dp(t,"priority")||e,</span>o=<span class="cstat-no" title="statement not covered" >Dp(n,"priority")||e;<span class="cstat-no" title="statement not covered" ></span>return r&gt;o?-1:r&lt;o?1:0}</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>t commands(){<span class="cstat-no" title="statement not covered" >return this.extensions.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >{name:e.name,options:e.options,editor:this.editor,type:Wp(e.name,this.schema)},</span>r=<span class="cstat-no" title="statement not covered" >Dp(e,"addCommands",n);<span class="cstat-no" title="statement not covered" ></span>return r?{...t,...r()}:t}</span>,{})}<span class="fstat-no" title="function not covered" ></span>ge</span>t plugins(){<span class="cstat-no" title="statement not covered" >return[...this.extensions].reverse().map(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >{name:t.name,options:t.options,editor:this.editor,type:Wp(t.name,this.schema)},</span>n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >Dp(t,"addKeyboardShortcuts",e);<span class="cstat-no" title="statement not covered" ></span>if(r){const t=<span class="cstat-no" title="statement not covered" >Object.fromEntries(Object.entries(r()).map(<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;<span class="cstat-no" title="statement not covered" >[t,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e({editor:this.editor})]</span>)</span>),</span>e=<span class="cstat-no" title="statement not covered" >kl(t);<span class="cstat-no" title="statement not covered" ></span>n.push(e)}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >Dp(t,"addInputRules",e);<span class="cstat-no" title="statement not covered" ></span>if(this.editor.options.enableInputRules&amp;&amp;o){const t=<span class="cstat-no" title="statement not covered" >o(),</span>e=<span class="cstat-no" title="statement not covered" >t.length?[El({rules:t})]:[];<span class="cstat-no" title="statement not covered" ></span>n.push(...e)}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >Dp(t,"addPasteRules",e);<span class="cstat-no" title="statement not covered" ></span>if(this.editor.options.enablePasteRules&amp;&amp;i){const t=<span class="cstat-no" title="statement not covered" >i();<span class="cstat-no" title="statement not covered" ></span>n.push(...t)}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >Dp(t,"addProseMirrorPlugins",e);<span class="cstat-no" title="statement not covered" ></span>if(s){const t=<span class="cstat-no" title="statement not covered" >s();<span class="cstat-no" title="statement not covered" ></span>n.push(...t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>).flat()}<span class="fstat-no" title="function not covered" ></span>ge</span>t attributes(){<span class="cstat-no" title="statement not covered" >return _p(this.extensions)}<span class="fstat-no" title="function not covered" ></span>ge</span>t nodeViews(){const{editor:t}=<span class="cstat-no" title="statement not covered" >this,</span>{nodeExtensions:e}=<span class="cstat-no" title="statement not covered" >Rp(this.extensions);<span class="cstat-no" title="statement not covered" ></span>return Object.fromEntries(e.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!!Dp(t,"addNodeView"))</span>.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >this.attributes.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type===e.name)</span>,</span>r=<span class="cstat-no" title="statement not covered" >{name:e.name,options:e.options,editor:t,type:hp(e.name,this.schema)},</span>o=<span class="cstat-no" title="statement not covered" >Dp(e,"addNodeView",r);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(r</span>,i,s,a)=&gt;{const c=<span class="cstat-no" title="statement not covered" >zp(r,n);<span class="cstat-no" title="statement not covered" ></span>return o()({editor:t,node:r,getPos:s,decorations:a,HTMLAttributes:c,extension:e})}</span>;<span class="cstat-no" title="statement not covered" ></span>return[e.name,i]}</span>))}</span>}class Up{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.callbacks={}}<span class="fstat-no" title="function not covered" ></span>on</span>(t,e){<span class="cstat-no" title="statement not covered" >return this.callbacks[t]||(this.callbacks[t]=[]),this.callbacks[t].push(e),this}<span class="fstat-no" title="function not covered" ></span>em</span>it(t,...e){const n=<span class="cstat-no" title="statement not covered" >this.callbacks[t];<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;n.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.apply(this,e))</span>,this}<span class="fstat-no" title="function not covered" ></span>of</span>f(t,e){const n=<span class="cstat-no" title="statement not covered" >this.callbacks[t];<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;(e?this.callbacks[t]=n.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t!==e)</span>:delete this.callbacks[t]),this}<span class="fstat-no" title="function not covered" ></span>re</span>moveAllListeners(){<span class="cstat-no" title="statement not covered" >this.callbacks={}}</span>}function <span class="fstat-no" title="function not covered" >Gp(</span>t){<span class="cstat-no" title="statement not covered" >return Object.prototype.toString.call(t).slice(8,-1)}</span>function <span class="fstat-no" title="function not covered" >Yp(</span>t){<span class="cstat-no" title="statement not covered" >return"Object"===Gp(t)&amp;&amp;(t.constructor===Object&amp;&amp;Object.getPrototypeOf(t)===Object.prototype)}</span>function <span class="fstat-no" title="function not covered" >Xp(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >{...t};<span class="cstat-no" title="statement not covered" ></span>return Yp(t)&amp;&amp;Yp(e)&amp;&amp;Object.keys(e).forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >Yp(e[r])?r in t?n[r]=Xp(t[r],e[r]):Object.assign(n,{[r]:e[r]}):Object.assign(n,{[r]:e[r]})}</span>),n}</span>class Qp{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.type="extension",this.name="extension",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...t},this.name=this.config.name,this.options=this.config.defaultOptions}<span class="fstat-no" title="function not covered" ></span>st</span>atic create(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return new Qp(t)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >this.extend();<span class="cstat-no" title="statement not covered" ></span>return e.options=Xp(this.options,t),e}<span class="fstat-no" title="function not covered" ></span>ex</span>tend(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >new Qp(t);<span class="cstat-no" title="statement not covered" ></span>return e.parent=this,this.child=e,e.name=t.name?t.name:e.parent.name,e.options=t.defaultOptions?t.defaultOptions:e.parent.options,e}</span>}const Zp=<span class="cstat-no" title="statement not covered" >Qp.create({name:"editable",<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){<span class="cstat-no" title="statement not covered" >return[new di({key:new vi("clipboardTextSerializer"),props:{clipboardTextSerializer:<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{editor:t}=<span class="cstat-no" title="statement not covered" >this,</span>{state:e,schema:n}=<span class="cstat-no" title="statement not covered" >t,</span>{doc:r,selection:o}=<span class="cstat-no" title="statement not covered" >e,</span>{from:i,to:s}=<span class="cstat-no" title="statement not covered" >o,</span>a=<span class="cstat-no" title="statement not covered" >jp(n),</span>c=<span class="cstat-no" title="statement not covered" >{from:i,to:s};<span class="cstat-no" title="statement not covered" ></span>return Ep(r,c,{textSerializers:a})}</span>}})]}</span>}),</span>tu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>editor:t,view:e})=&gt;(<span class="cstat-no" title="statement not covered" >requestAnimationFrame(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.isDestroyed||e.dom.blur()}</span>),!0)</span>;</span></span>var eu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,blur:tu});</span>const nu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:e})=&gt;<span class="cstat-no" title="statement not covered" >e.setContent("",t);</span></span></span>var ru=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,clearContent:nu});</span>const ou=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,tr:e,dispatch:n})=&gt;{const{selection:r}=<span class="cstat-no" title="statement not covered" >e,</span>{ranges:o}=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>return o.forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.doc.nodesBetween(r.$from.pos,r.$to.pos,<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(t.type.isText)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >e.doc.resolve(e.mapping.map(r)),</span>i=<span class="cstat-no" title="statement not covered" >e.doc.resolve(e.mapping.map(r+t.nodeSize)),</span>s=<span class="cstat-no" title="statement not covered" >o.blockRange(i);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >go(s);<span class="cstat-no" title="statement not covered" ></span>if(t.type.isTextblock&amp;&amp;n){const{defaultType:t}=<span class="cstat-no" title="statement not covered" >o.parent.contentMatchAt(o.index());<span class="cstat-no" title="statement not covered" ></span>e.setNodeMarkup(s.start,t)}<span class="cstat-no" title="statement not covered" ></span>(</span>a||0===a)&amp;&amp;n&amp;&amp;e.lift(s,a)}</span>)}</span>),!0}</span>;</span></span>var iu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,clearNodes:ou});</span>const su=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t(e);</span></span></span>var au=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,command:su});</span>const cu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >ql(t,e);</span></span></span>var lu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,createParagraphNear:cu});</span>const pu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:e,state:n,dispatch:r})=&gt;{const o=<span class="cstat-no" title="statement not covered" >hp(t,n.schema),</span>i=<span class="cstat-no" title="statement not covered" >e.selection.$anchor;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >i.depth;</span>t&gt;0;t-=1){const n=<span class="cstat-no" title="statement not covered" >i.node(t);<span class="cstat-no" title="statement not covered" ></span>if(n.type===o){<span class="cstat-no" title="statement not covered" >if(r){const n=<span class="cstat-no" title="statement not covered" >i.before(t),</span>r=<span class="cstat-no" title="statement not covered" >i.after(t);<span class="cstat-no" title="statement not covered" ></span>e.delete(n,r).scrollIntoView()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>;</span></span>var uu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,deleteNode:pu});</span>const hu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:e,dispatch:n})=&gt;{const{from:r,to:o}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;e.delete(r,o),!0}</span>;</span></span>var du=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,deleteRange:hu});</span>const fu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >Il(t,e);</span></span></span>var mu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,deleteSelection:fu});</span>const vu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.keyboardShortcut("Enter");</span></span></span>var gu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,enter:vu});</span>const yu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >Hl(t,e);</span></span></span>var bu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,exitCode:yu});</span>function <span class="fstat-no" title="function not covered" >wu(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return t.find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type===e&amp;&amp;yp(t.attrs,n))</span>}</span>function <span class="fstat-no" title="function not covered" >Ou(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return!!wu(t,e,n)}</span>function <span class="fstat-no" title="function not covered" >ku(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >if(!t||!e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >t.parent.childAfter(t.parentOffset);<span class="cstat-no" title="statement not covered" ></span>if(!r.node)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >wu(r.node.marks,e,n);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >t.index(),</span>s=<span class="cstat-no" title="statement not covered" >t.start()+r.offset,</span>a=<span class="cstat-no" title="statement not covered" >i+1,</span>c=<span class="cstat-no" title="statement not covered" >s+r.node.nodeSize;<span class="cstat-no" title="statement not covered" ></span>wu(r.node.marks,e,n);<span class="cstat-no" title="statement not covered" >w</span>hile(i&gt;0&amp;&amp;o.isInSet(t.parent.child(i-1).marks))<span class="cstat-no" title="statement not covered" >i-=1,s-=t.parent.child(i).nodeSize;<span class="cstat-no" title="statement not covered" >w</span></span>hile(a&lt;t.parent.childCount&amp;&amp;Ou(t.parent.child(a).marks,e,n))<span class="cstat-no" title="statement not covered" >c+=t.parent.child(a).nodeSize,a+=1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{from:s,to:c}}</span>const xu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:n,state:r,dispatch:o})=&gt;{const i=<span class="cstat-no" title="statement not covered" >fp(t,r.schema),</span>{doc:s,selection:a}=<span class="cstat-no" title="statement not covered" >n,</span>{$from:c,from:l,to:p}=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>if(o){const t=<span class="cstat-no" title="statement not covered" >ku(c,i,e);<span class="cstat-no" title="statement not covered" ></span>if(t&amp;&amp;t.from&lt;=l&amp;&amp;t.to&gt;=p){const e=<span class="cstat-no" title="statement not covered" >Ko.create(s,t.from,t.to);<span class="cstat-no" title="statement not covered" ></span>n.setSelection(e)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>;</span></span>var Su=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,extendMarkRange:xu});</span>const Mu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >"function"===typeof t?t(e):t;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t+=1)<span class="cstat-no" title="statement not covered" >if(n[t](e))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>;</span></span>var Cu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,first:Mu});</span>function <span class="fstat-no" title="function not covered" >Eu(</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return Math.min(Math.max(t,e),n)}</span>function <span class="fstat-no" title="function not covered" >Tu(</span>t){<span class="cstat-no" title="statement not covered" >return $p(t)&amp;&amp;t instanceof Ko}</span>function <span class="fstat-no" title="function not covered" >Nu(</span>){<span class="cstat-no" title="statement not covered" >return["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)||navigator.userAgent.includes("Mac")&amp;&amp;"ontouchend"in document}</span>function <span class="fstat-no" title="function not covered" >ju(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f("start"===e||!0===e)<span class="cstat-no" title="statement not covered" >return{from:0,to:0};<span class="cstat-no" title="statement not covered" >i</span></span>f("end"===e){const{size:e}=<span class="cstat-no" title="statement not covered" >t.doc.content;<span class="cstat-no" title="statement not covered" ></span>return{from:e,to:e}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{from:e,to:e}}</span>const Au=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>editor:e,view:n,tr:r,dispatch:o})=&gt;{const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >Nu()&amp;&amp;n.dom.focus(),requestAnimationFrame(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e.isDestroyed||(n.focus(),e.commands.scrollIntoView())}</span>)}</span>;<span class="cstat-no" title="statement not covered" ></span>if(n.hasFocus()&amp;&amp;null===t||!1===t)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(o&amp;&amp;null===t&amp;&amp;!Tu(e.state.selection))<span class="cstat-no" title="statement not covered" >return i(),!0;c</span></span>onst{from:s,to:a}=<span class="cstat-no" title="statement not covered" >ju(e.state,t)||e.state.selection,</span>{doc:c,storedMarks:l}=<span class="cstat-no" title="statement not covered" >r,</span>p=<span class="cstat-no" title="statement not covered" >qo.atStart(c).from,</span>u=<span class="cstat-no" title="statement not covered" >qo.atEnd(c).to,</span>h=<span class="cstat-no" title="statement not covered" >Eu(s,p,u),</span>d=<span class="cstat-no" title="statement not covered" >Eu(a,p,u),</span>f=<span class="cstat-no" title="statement not covered" >Ko.create(c,h,d),</span>m=<span class="cstat-no" title="statement not covered" >e.state.selection.eq(f);<span class="cstat-no" title="statement not covered" ></span>return o&amp;&amp;(m||r.setSelection(f),m&amp;&amp;l&amp;&amp;r.setStoredMarks(l),i()),!0}</span>;</span></span>var Iu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,focus:Au});</span>const Du=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >t.every(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e(t,{...n,index:r}))</span>;</span></span></span>var Ru=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,forEach:Du});</span>const _u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:n,commands:r})=&gt;<span class="cstat-no" title="statement not covered" >r.insertContentAt({from:n.selection.from,to:n.selection.to},t,e);</span></span></span>var Pu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,insertContent:_u});</span>function <span class="fstat-no" title="function not covered" >zu(</span>t,e,n){const r=<span class="cstat-no" title="statement not covered" >t.steps.length-1;<span class="cstat-no" title="statement not covered" ></span>if(r&lt;e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >t.steps[r];<span class="cstat-no" title="statement not covered" ></span>if(!(o instanceof ho||o instanceof fo))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >t.mapping.maps[r];</span>let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>i.forEach(<span class="fstat-no" title="function not covered" >(t</span>,e,n,r)=&gt;{<span class="cstat-no" title="statement not covered" >0===s&amp;&amp;(s=r)}</span>),t.setSelection(qo.near(t.doc.resolve(s),n))}</span>const Bu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:r,dispatch:o,editor:i})=&gt;{<span class="cstat-no" title="statement not covered" >if(o){const o=<span class="cstat-no" title="statement not covered" >Sp(e,i.schema,{parseOptions:{preserveWhitespace:"full"},...n||{}});<span class="cstat-no" title="statement not covered" ></span>if("&lt;&gt;"===o.toString())<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst{from:s,to:a}=<span class="cstat-no" title="statement not covered" >"number"===typeof t?{from:t,to:t}:t;<span class="cstat-no" title="statement not covered" ></span>r.replaceWith(s,a,o),zu(r,r.steps.length-1,1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>;</span></span>var Lu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,insertContentAt:Bu});</span>const Vu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >Dl(t,e);</span></span></span>var $u=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,joinBackward:Vu});</span>const Fu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >zl(t,e);</span></span></span>var Hu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,joinForward:Fu});</span>const qu=<span class="cstat-no" title="statement not covered" >"undefined"!==typeof navigator&amp;&amp;/Mac/.test(navigator.platform);</span>function <span class="fstat-no" title="function not covered" >Ju(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.split(/-(?!$)/);</span>let n,r,o,i,s=<span class="cstat-no" title="statement not covered" >e[e.length-1];<span class="cstat-no" title="statement not covered" ></span>"Space"===s&amp;&amp;(s=" ");<span class="cstat-no" title="statement not covered" >f</span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;e.length-1;a+=1){const t=<span class="cstat-no" title="statement not covered" >e[a];<span class="cstat-no" title="statement not covered" ></span>if(/^(cmd|meta|m)$/i.test(t))<span class="cstat-no" title="statement not covered" >i=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(/^a(lt)?$/i.test(t))<span class="cstat-no" title="statement not covered" >n=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(/^(c|ctrl|control)$/i.test(t))<span class="cstat-no" title="statement not covered" >r=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(/^s(hift)?$/i.test(t))<span class="cstat-no" title="statement not covered" >o=!0;e</span>lse{<span class="cstat-no" title="statement not covered" >if(!/^mod$/i.test(t))<span class="cstat-no" title="statement not covered" >throw new Error("Unrecognized modifier name: "+t);<span class="cstat-no" title="statement not covered" >q</span></span>u?i=!0:r=!0}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span></span>r</span>eturn n&amp;&amp;(s="Alt-"+s),r&amp;&amp;(s="Ctrl-"+s),i&amp;&amp;(s="Meta-"+s),o&amp;&amp;(s="Shift-"+s),s}</span>const Wu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>editor:e,view:n,tr:r,dispatch:o})=&gt;{const i=<span class="cstat-no" title="statement not covered" >Ju(t).split(/-(?!$)/),</span>s=<span class="cstat-no" title="statement not covered" >i.find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!["Alt","Ctrl","Meta","Shift"].includes(t))</span>,</span>a=<span class="cstat-no" title="statement not covered" >new KeyboardEvent("keydown",{key:"Space"===s?" ":s,altKey:i.includes("Alt"),ctrlKey:i.includes("Ctrl"),metaKey:i.includes("Meta"),shiftKey:i.includes("Shift"),bubbles:!0,cancelable:!0}),</span>c=<span class="cstat-no" title="statement not covered" >e.captureTransaction(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n.someProp("handleKeyDown",<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t(n,a))</span>}</span>);<span class="cstat-no" title="statement not covered" ></span>return null===c||void 0===c||c.steps.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.map(r.mapping);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;o&amp;&amp;r.maybeStep(e)}</span>),!0}</span>;</span></span>var Ku=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,keyboardShortcut:Wu});</span>const Uu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:n,dispatch:r})=&gt;{const o=<span class="cstat-no" title="statement not covered" >hp(t,n.schema),</span>i=<span class="cstat-no" title="statement not covered" >bp(n,o,e);<span class="cstat-no" title="statement not covered" ></span>return!!i&amp;&amp;Vl(n,r)}</span>;</span></span>var Gu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,lift:Uu});</span>const Yu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >Jl(t,e);</span></span></span>var Xu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,liftEmptyBlock:Yu});</span>const Qu=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:e,dispatch:n})=&gt;{const r=<span class="cstat-no" title="statement not covered" >hp(t,e.schema);<span class="cstat-no" title="statement not covered" ></span>return ap(r)(e,n)}</span>;</span></span>var Zu=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,liftListItem:Qu});</span>const th=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >$l(t,e);</span></span></span>var eh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,newlineInCode:th});</span>function <span class="fstat-no" title="function not covered" >nh(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >"string"===typeof e?[e]:e;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(t).reduce(<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;(<span class="cstat-no" title="statement not covered" >n.includes(r)||(e[r]=t[r]),e)</span>,{})}</span>const rh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:n,state:r,dispatch:o})=&gt;{let i=<span class="cstat-no" title="statement not covered" >null,</span>s=<span class="cstat-no" title="statement not covered" >null;</span>const a=<span class="cstat-no" title="statement not covered" >up("string"===typeof t?t:t.name,r.schema);<span class="cstat-no" title="statement not covered" ></span>return!!a&amp;&amp;("node"===a&amp;&amp;(i=hp(t,r.schema)),"mark"===a&amp;&amp;(s=fp(t,r.schema)),o&amp;&amp;n.selection.ranges.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.doc.nodesBetween(t.$from.pos,t.$to.pos,<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;i===t.type&amp;&amp;n.setNodeMarkup(r,void 0,nh(t.attrs,e)),s&amp;&amp;t.marks.length&amp;&amp;t.marks.forEach(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >s===o.type&amp;&amp;n.addMark(r,r+t.nodeSize,s.create(nh(o.attrs,e)))}</span>)}</span>)}</span>),!0)}</span>;</span></span>var oh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,resetAttributes:rh});</span>const ih=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:t,dispatch:e})=&gt;(<span class="cstat-no" title="statement not covered" >e&amp;&amp;t.scrollIntoView(),!0)</span>;</span></span>var sh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,scrollIntoView:ih});</span>const ah=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >Ul(t,e);</span></span></span>var ch=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,selectAll:ah});</span>const lh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >_l(t,e);</span></span></span>var ph=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,selectNodeBackward:lh});</span>const uh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >Bl(t,e);</span></span></span>var hh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,selectNodeForward:uh});</span>const dh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >Kl(t,e);</span></span></span>var fh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,selectParentNode:dh});</span>const mh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:r,editor:o,dispatch:i})=&gt;{const{doc:s}=<span class="cstat-no" title="statement not covered" >r,</span>a=<span class="cstat-no" title="statement not covered" >Mp(t,o.schema,n),</span>c=<span class="cstat-no" title="statement not covered" >Ko.create(s,0,s.content.size);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;r.setSelection(c).replaceSelectionWith(a,!1).setMeta("preventUpdate",!e),!0}</span>;</span></span>var vh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,setContent:mh});</span>const gh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:n,state:r,dispatch:o})=&gt;{const{selection:i}=<span class="cstat-no" title="statement not covered" >n,</span>{empty:s,ranges:a}=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >fp(t,r.schema);<span class="cstat-no" title="statement not covered" ></span>if(o)<span class="cstat-no" title="statement not covered" >if(s){const t=<span class="cstat-no" title="statement not covered" >mp(r,c);<span class="cstat-no" title="statement not covered" ></span>n.addStoredMark(c.create({...t,...e}))}</span>else <span class="cstat-no" title="statement not covered" >a.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const o=<span class="cstat-no" title="statement not covered" >t.$from.pos,</span>i=<span class="cstat-no" title="statement not covered" >t.$to.pos;<span class="cstat-no" title="statement not covered" ></span>r.doc.nodesBetween(o,i,<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{const s=<span class="cstat-no" title="statement not covered" >Math.max(r,o),</span>a=<span class="cstat-no" title="statement not covered" >Math.min(r+t.nodeSize,i),</span>l=<span class="cstat-no" title="statement not covered" >t.marks.find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type===c)</span>;<span class="cstat-no" title="statement not covered" ></span>l?t.marks.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >c===t.type&amp;&amp;n.addMark(s,a,c.create({...t.attrs,...e}))}</span>):n.addMark(s,a,c.create(e))}</span>)}</span>);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>;</span></span>var yh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,setMark:gh});</span>const bh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:n})=&gt;(<span class="cstat-no" title="statement not covered" >n.setMeta(t,e),!0)</span>;</span></span>var wh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,setMeta:bh});</span>const Oh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:n,dispatch:r})=&gt;{const o=<span class="cstat-no" title="statement not covered" >hp(t,n.schema);<span class="cstat-no" title="statement not covered" ></span>return Ql(o,e)(n,r)}</span>;</span></span>var kh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,setNode:Oh});</span>const xh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:e,dispatch:n})=&gt;{<span class="cstat-no" title="statement not covered" >if(n){const{doc:n}=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >qo.atStart(n).from,</span>o=<span class="cstat-no" title="statement not covered" >qo.atEnd(n).to,</span>i=<span class="cstat-no" title="statement not covered" >Eu(t,r,o),</span>s=<span class="cstat-no" title="statement not covered" >Go.create(n,i);<span class="cstat-no" title="statement not covered" ></span>e.setSelection(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>;</span></span>var Sh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,setNodeSelection:xh});</span>const Mh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:e,dispatch:n})=&gt;{<span class="cstat-no" title="statement not covered" >if(n){const{doc:n}=<span class="cstat-no" title="statement not covered" >e,</span>{from:r,to:o}=<span class="cstat-no" title="statement not covered" >"number"===typeof t?{from:t,to:t}:t,</span>i=<span class="cstat-no" title="statement not covered" >qo.atStart(n).from,</span>s=<span class="cstat-no" title="statement not covered" >qo.atEnd(n).to,</span>a=<span class="cstat-no" title="statement not covered" >Eu(r,i,s),</span>c=<span class="cstat-no" title="statement not covered" >Eu(o,i,s),</span>l=<span class="cstat-no" title="statement not covered" >Ko.create(n,a,c);<span class="cstat-no" title="statement not covered" ></span>e.setSelection(l)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>;</span></span>var Ch=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,setTextSelection:Mh});</span>const Eh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:e,dispatch:n})=&gt;{const r=<span class="cstat-no" title="statement not covered" >hp(t,e.schema);<span class="cstat-no" title="statement not covered" ></span>return pp(r)(e,n)}</span>;</span></span>var Th=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,sinkListItem:Eh});</span>function <span class="fstat-no" title="function not covered" >Nh(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return Object.fromEntries(Object.entries(n).filter(<span class="fstat-no" title="function not covered" >([</span>n])=&gt;{const r=<span class="cstat-no" title="statement not covered" >t.find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type===e&amp;&amp;t.name===n)</span>;<span class="cstat-no" title="statement not covered" ></span>return!!r&amp;&amp;r.attribute.keepOnSplit}</span>))}</span>function <span class="fstat-no" title="function not covered" >jh(</span>t){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.edgeCount;e+=1){const{type:n}=<span class="cstat-no" title="statement not covered" >t.edge(e);<span class="cstat-no" title="statement not covered" ></span>if(n.isTextblock&amp;&amp;!n.hasRequiredAttrs())<span class="cstat-no" title="statement not covered" >return n}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>function <span class="fstat-no" title="function not covered" >Ah(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >t.storedMarks||t.selection.$to.parentOffset&amp;&amp;t.selection.$from.marks();<span class="cstat-no" title="statement not covered" ></span>if(n){const r=<span class="cstat-no" title="statement not covered" >n.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >null===e||void 0===e?void 0:e.includes(t.type.name))</span>;<span class="cstat-no" title="statement not covered" ></span>t.tr.ensureMarks(r)}</span>}</span>const Ih=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>keepMarks:t=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:e,state:n,dispatch:r,editor:o})=&gt;{const{selection:i,doc:s}=<span class="cstat-no" title="statement not covered" >e,</span>{$from:a,$to:c}=<span class="cstat-no" title="statement not covered" >i,</span>l=<span class="cstat-no" title="statement not covered" >o.extensionManager.attributes,</span>p=<span class="cstat-no" title="statement not covered" >Nh(l,a.node().type.name,a.node().attrs);<span class="cstat-no" title="statement not covered" ></span>if(i instanceof Go&amp;&amp;i.node.isBlock)<span class="cstat-no" title="statement not covered" >return!(!a.parentOffset||!xo(s,a.pos))&amp;&amp;(r&amp;&amp;(t&amp;&amp;Ah(n,o.extensionManager.splittableMarks),e.split(a.pos).scrollIntoView()),!0);<span class="cstat-no" title="statement not covered" >i</span></span>f(!a.parent.isBlock)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r){const r=<span class="cstat-no" title="statement not covered" >c.parentOffset===c.parent.content.size;<span class="cstat-no" title="statement not covered" ></span>i instanceof Ko&amp;&amp;e.deleteSelection();c</span>onst s=<span class="cstat-no" title="statement not covered" >0===a.depth?void 0:jh(a.node(-1).contentMatchAt(a.indexAfter(-1)));</span>let l=<span class="cstat-no" title="statement not covered" >r&amp;&amp;s?[{type:s,attrs:p}]:void 0,</span>u=<span class="cstat-no" title="statement not covered" >xo(e.doc,e.mapping.map(a.pos),1,l);<span class="cstat-no" title="statement not covered" ></span>if(l||u||!xo(e.doc,e.mapping.map(a.pos),1,s?[{type:s}]:void 0)||(u=!0,l=s?[{type:s,attrs:p}]:void 0),u&amp;&amp;(e.split(e.mapping.map(a.pos),1,l),s&amp;&amp;!r&amp;&amp;!a.parentOffset&amp;&amp;a.parent.type!==s)){const t=<span class="cstat-no" title="statement not covered" >e.mapping.map(a.before()),</span>n=<span class="cstat-no" title="statement not covered" >e.doc.resolve(t);<span class="cstat-no" title="statement not covered" ></span>a.node(-1).canReplaceWith(n.index(),n.index()+1,s)&amp;&amp;e.setNodeMarkup(e.mapping.map(a.before()),s)}<span class="cstat-no" title="statement not covered" ></span>t</span>&amp;&amp;Ah(n,o.extensionManager.splittableMarks),e.scrollIntoView()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>;</span></span>var Dh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,splitBlock:Ih});</span>const Rh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:e,state:n,dispatch:r,editor:o})=&gt;{var i;const s=<span class="cstat-no" title="statement not covered" >hp(t,n.schema),</span>{$from:a,$to:c}=<span class="cstat-no" title="statement not covered" >n.selection,</span>l=<span class="cstat-no" title="statement not covered" >n.selection.node;<span class="cstat-no" title="statement not covered" ></span>if(l&amp;&amp;l.isBlock||a.depth&lt;2||!a.sameParent(c))<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst p=<span class="cstat-no" title="statement not covered" >a.node(-1);<span class="cstat-no" title="statement not covered" ></span>if(p.type!==s)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst u=<span class="cstat-no" title="statement not covered" >o.extensionManager.attributes;<span class="cstat-no" title="statement not covered" ></span>if(0===a.parent.content.size&amp;&amp;a.node(-1).childCount===a.indexAfter(-1)){<span class="cstat-no" title="statement not covered" >if(2===a.depth||a.node(-3).type!==s||a.index(-2)!==a.node(-2).childCount-1)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(r){let t=<span class="cstat-no" title="statement not covered" >Cn.empty;</span>const n=<span class="cstat-no" title="statement not covered" >a.index(-1)?1:a.index(-2)?2:3;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >a.depth-n;</span>e&gt;=a.depth-3;e-=1)<span class="cstat-no" title="statement not covered" >t=Cn.from(a.node(e).copy(t));c</span></span>onst r=<span class="cstat-no" title="statement not covered" >a.indexAfter(-1)&lt;a.node(-2).childCount?1:a.indexAfter(-2)&lt;a.node(-3).childCount?2:3,</span>o=<span class="cstat-no" title="statement not covered" >Nh(u,a.node().type.name,a.node().attrs),</span>c=<span class="cstat-no" title="statement not covered" >(null===(i=s.contentMatch.defaultType)||void 0===i?void 0:i.createAndFill(o))||void 0;<span class="cstat-no" title="statement not covered" ></span>t=t.append(Cn.from(s.createAndFill(null,c)||void 0));c</span>onst l=<span class="cstat-no" title="statement not covered" >a.before(a.depth-(n-1));<span class="cstat-no" title="statement not covered" ></span>e.replace(l,a.after(-r),new Dn(t,4-n,0));l</span>et p=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>e.doc.nodesBetween(l,e.doc.content.size,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(p&gt;-1)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>.isTextblock&amp;&amp;0===t.content.size&amp;&amp;(p=e+1)}</span>),p&gt;-1&amp;&amp;e.setSelection(Ko.near(e.doc.resolve(p))),e.scrollIntoView()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>c</span>onst h=<span class="cstat-no" title="statement not covered" >c.pos===a.end()?p.contentMatchAt(0).defaultType:null,</span>d=<span class="cstat-no" title="statement not covered" >Nh(u,p.type.name,p.attrs),</span>f=<span class="cstat-no" title="statement not covered" >Nh(u,a.node().type.name,a.node().attrs);<span class="cstat-no" title="statement not covered" ></span>e.delete(a.pos,c.pos);c</span>onst m=<span class="cstat-no" title="statement not covered" >h?[{type:s,attrs:d},{type:h,attrs:f}]:[{type:s,attrs:d}];<span class="cstat-no" title="statement not covered" ></span>return!!xo(e.doc,a.pos,2)&amp;&amp;(r&amp;&amp;e.split(a.pos,2,m).scrollIntoView(),!0)}</span>;</span></span>var _h=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,splitListItem:Rh});</span>function <span class="fstat-no" title="function not covered" >Ph(</span>t,e){<span class="cstat-no" title="statement not covered" >for(let n=<span class="cstat-no" title="statement not covered" >t.depth;</span>n&gt;0;n-=1){const r=<span class="cstat-no" title="statement not covered" >t.node(n);<span class="cstat-no" title="statement not covered" ></span>if(e(r))<span class="cstat-no" title="statement not covered" >return{pos:n&gt;0?t.before(n):0,start:t.start(n),depth:n,node:r}}</span></span>}</span>function <span class="fstat-no" title="function not covered" >zh(</span>t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Ph(e.$from,t)}</span></span>function <span class="fstat-no" title="function not covered" >Bh(</span>t,e){const{nodeExtensions:n}=<span class="cstat-no" title="statement not covered" >Rp(e),</span>r=<span class="cstat-no" title="statement not covered" >n.find(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.name===t)</span>;<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >{name:r.name,options:r.options},</span>i=<span class="cstat-no" title="statement not covered" >Hp(Dp(r,"group",o));<span class="cstat-no" title="statement not covered" ></span>return"string"===typeof i&amp;&amp;i.split(" ").includes("list")}</span>const Lh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>editor:n,tr:r,state:o,dispatch:i,chain:s,commands:a,can:c})=&gt;{const{extensions:l}=<span class="cstat-no" title="statement not covered" >n.extensionManager,</span>p=<span class="cstat-no" title="statement not covered" >hp(t,o.schema),</span>u=<span class="cstat-no" title="statement not covered" >hp(e,o.schema),</span>{selection:h}=<span class="cstat-no" title="statement not covered" >o,</span>{$from:d,$to:f}=<span class="cstat-no" title="statement not covered" >h,</span>m=<span class="cstat-no" title="statement not covered" >d.blockRange(f);<span class="cstat-no" title="statement not covered" ></span>if(!m)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst v=<span class="cstat-no" title="statement not covered" >zh(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Bh(t.type.name,l))</span>(h);<span class="cstat-no" title="statement not covered" ></span>if(m.depth&gt;=1&amp;&amp;v&amp;&amp;m.depth-v.depth&lt;=1){<span class="cstat-no" title="statement not covered" >if(v.node.type===p)<span class="cstat-no" title="statement not covered" >return a.liftListItem(u);<span class="cstat-no" title="statement not covered" >i</span></span>f(Bh(v.node.type.name,l)&amp;&amp;p.validContent(v.node.content)&amp;&amp;i)<span class="cstat-no" title="statement not covered" >return r.setNodeMarkup(v.pos,p),!0}</span></span>c</span>onst g=<span class="cstat-no" title="statement not covered" >c().wrapInList(p);<span class="cstat-no" title="statement not covered" ></span>return g?a.wrapInList(p):s().clearNodes().wrapInList(p).run()}</span>;</span></span>var Vh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,toggleList:Lh});</span>const $h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:r,commands:o})=&gt;{const{extendEmptyMarkRange:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="cstat-no" title="statement not covered" >n,</span>s=<span class="cstat-no" title="statement not covered" >fp(t,r.schema),</span>a=<span class="cstat-no" title="statement not covered" >wp(r,s,e);<span class="cstat-no" title="statement not covered" ></span>return a?o.unsetMark(s,{extendEmptyMarkRange:i}):o.setMark(s,e)}</span>;</span></span>var Fh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,toggleMark:$h});</span>const Hh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:r,commands:o})=&gt;{const i=<span class="cstat-no" title="statement not covered" >hp(t,r.schema),</span>s=<span class="cstat-no" title="statement not covered" >hp(e,r.schema),</span>a=<span class="cstat-no" title="statement not covered" >bp(r,i,n);<span class="cstat-no" title="statement not covered" ></span>return a?o.setNode(s):o.setNode(i,n)}</span>;</span></span>var qh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,toggleNode:Hh});</span>const Jh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:n,dispatch:r})=&gt;{const o=<span class="cstat-no" title="statement not covered" >hp(t,n.schema),</span>i=<span class="cstat-no" title="statement not covered" >bp(n,o,e);<span class="cstat-no" title="statement not covered" ></span>return i?Vl(n,r):Xl(o,e)(n,r)}</span>;</span></span>var Wh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,toggleWrap:Jh});</span>const Kh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >Nl(t,e);</span></span></span>var Uh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,undoInputRule:Kh});</span>const Gh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:t,state:e,dispatch:n})=&gt;{const{selection:r}=<span class="cstat-no" title="statement not covered" >t,</span>{empty:o,ranges:i}=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>return o||n&amp;&amp;Object.entries(e.schema.marks).forEach(<span class="fstat-no" title="function not covered" >([</span>,e])=&gt;{<span class="cstat-no" title="statement not covered" >i.forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.removeMark(n.$from.pos,n.$to.pos,e)}</span>)}</span>),!0}</span>;</span></span>var Yh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,unsetAllMarks:Gh});</span>const Xh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:n,state:r,dispatch:o})=&gt;{var i;const{extendEmptyMarkRange:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="cstat-no" title="statement not covered" >e,</span>{selection:a}=<span class="cstat-no" title="statement not covered" >n,</span>c=<span class="cstat-no" title="statement not covered" >fp(t,r.schema),</span>{$from:l,empty:p,ranges:u}=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(p&amp;&amp;s){let{from:t,to:e}=<span class="cstat-no" title="statement not covered" >a;</span>const r=<span class="cstat-no" title="statement not covered" >null===(i=l.marks().find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.type===c)</span>)||void 0===i?void 0:i.attrs,</span>o=<span class="cstat-no" title="statement not covered" >ku(l,c,r);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;(t=o.from,e=o.to),n.removeMark(t,e,c)}</span>else <span class="cstat-no" title="statement not covered" >u.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.removeMark(t.$from.pos,t.$to.pos,c)}</span>);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.removeStoredMark(c),!0}</span>;</span></span>var Qh=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,unsetMark:Xh});</span>const Zh=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>tr:n,state:r,dispatch:o})=&gt;{let i=<span class="cstat-no" title="statement not covered" >null,</span>s=<span class="cstat-no" title="statement not covered" >null;</span>const a=<span class="cstat-no" title="statement not covered" >up("string"===typeof t?t:t.name,r.schema);<span class="cstat-no" title="statement not covered" ></span>return!!a&amp;&amp;("node"===a&amp;&amp;(i=hp(t,r.schema)),"mark"===a&amp;&amp;(s=fp(t,r.schema)),o&amp;&amp;n.selection.ranges.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const o=<span class="cstat-no" title="statement not covered" >t.$from.pos,</span>a=<span class="cstat-no" title="statement not covered" >t.$to.pos;<span class="cstat-no" title="statement not covered" ></span>r.doc.nodesBetween(o,a,<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;i===t.type&amp;&amp;n.setNodeMarkup(r,void 0,{...t.attrs,...e}),s&amp;&amp;t.marks.length&amp;&amp;t.marks.forEach(<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(s===i.type){const c=<span class="cstat-no" title="statement not covered" >Math.max(r,o),</span>l=<span class="cstat-no" title="statement not covered" >Math.min(r+t.nodeSize,a);<span class="cstat-no" title="statement not covered" ></span>n.addMark(c,l,s.create({...i.attrs,...e}))}</span>}</span>)}</span>)}</span>),!0)}</span>;</span></span>var td=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,updateAttributes:Zh});</span>const ed=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:n,dispatch:r})=&gt;{const o=<span class="cstat-no" title="statement not covered" >hp(t,n.schema),</span>i=<span class="cstat-no" title="statement not covered" >bp(n,o,e);<span class="cstat-no" title="statement not covered" ></span>return!i&amp;&amp;Xl(o,e)(n,r)}</span>;</span></span>var nd=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,wrapIn:ed});</span>const rd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:n,dispatch:r})=&gt;{const o=<span class="cstat-no" title="statement not covered" >hp(t,n.schema);<span class="cstat-no" title="statement not covered" ></span>return ip(o,e)(n,r)}</span>;</span></span>var od=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,wrapInList:rd});</span>const id=<span class="cstat-no" title="statement not covered" >Qp.create({name:"commands",<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{...eu,...ru,...iu,...au,...lu,...uu,...du,...mu,...gu,...bu,...Su,...Cu,...Iu,...Ru,...Pu,...Lu,...$u,...Hu,...Ku,...Gu,...Xu,...Zu,...eh,...oh,...sh,...ch,...ph,...hh,...fh,...vh,...yh,...wh,...kh,...Sh,...Ch,...Th,...Dh,..._h,...Vh,...Fh,...qh,...Wh,...Uh,...Yh,...Qh,...td,...nd,...od}}</span>}),</span>sd=<span class="cstat-no" title="statement not covered" >Qp.create({name:"editable",<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){<span class="cstat-no" title="statement not covered" >return[new di({key:new vi("editable"),props:{editable:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.options.editable}</span>})]}</span>}),</span>ad=<span class="cstat-no" title="statement not covered" >Qp.create({name:"focusEvents",<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){const{editor:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return[new di({key:new vi("focusEvents"),props:{attributes:{tabindex:"0"},handleDOMEvents:{focus:<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >t.isFocused=!0;c</span>onst r=<span class="cstat-no" title="statement not covered" >t.state.tr.setMeta("focus",{event:n}).setMeta("addToHistory",!1);<span class="cstat-no" title="statement not covered" ></span>return e.dispatch(r),!1}</span>,blur:<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >t.isFocused=!1;c</span>onst r=<span class="cstat-no" title="statement not covered" >t.state.tr.setMeta("blur",{event:n}).setMeta("addToHistory",!1);<span class="cstat-no" title="statement not covered" ></span>return e.dispatch(r),!1}</span>}}})]}</span>}),</span>cd=<span class="cstat-no" title="statement not covered" >Qp.create({name:"keymap",<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){const t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.first(<span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >[<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.undoInputRule(),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.deleteSelection(),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.joinBackward(),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.selectNodeBackward()]</span>)</span>,</span></span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.first(<span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >[<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.deleteSelection(),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.joinForward(),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.selectNodeForward()]</span>)</span>;<span class="cstat-no" title="statement not covered" ></span></span>return{Enter:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.first(<span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >[<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.newlineInCode(),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.createParagraphNear(),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.liftEmptyBlock(),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.splitBlock()]</span>)</span>,</span>"Mod-Enter":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.exitCode(),</span>Backspace:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t(),</span>"Mod-Backspace":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t(),</span>Delete:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e(),</span>"Mod-Delete":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e()}</span>}</span>});</span>var ld=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,ClipboardTextSerializer:Zp,Commands:id,Editable:sd,FocusEvents:ad,Keymap:cd});</span>const pd=<span class="cstat-no" title="statement not covered" >'.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: "liga" 0; /* the above doesn\'t seem to work in Edge */\n}\n\n.ProseMirror [contenteditable="false"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable="false"] [contenteditable="true"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n}\n\n.ProseMirror-gapcursor:after {\n  content: "";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}';</span>class ud extends Up{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >super(),this.isFocused=!1,this.options={element:document.createElement("div"),content:"",injectCSS:!0,extensions:[],autofocus:!1,editable:!0,editorProps:{},parseOptions:{},enableInputRules:!0,enablePasteRules:!0,onBeforeCreate:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null,</span>onCreate:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null,</span>onUpdate:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null,</span>onSelectionUpdate:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null,</span>onTransaction:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null,</span>onFocus:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null,</span>onBlur:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null,</span>onDestroy:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null}</span>,this.isCapturingTransaction=!1,this.capturedTransaction=null,this.setOptions(t),this.createExtensionManager(),this.createCommandManager(),this.createSchema(),this.on("beforeCreate",this.options.onBeforeCreate),this.emit("beforeCreate",{editor:this}),this.createView(),this.injectCSS(),this.on("create",this.options.onCreate),this.on("update",this.options.onUpdate),this.on("selectionUpdate",this.options.onSelectionUpdate),this.on("transaction",this.options.onTransaction),this.on("focus",this.options.onFocus),this.on("blur",this.options.onBlur),this.on("destroy",this.options.onDestroy),window.setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.isDestroyed||(this.commands.focus(this.options.autofocus),this.emit("create",{editor:this}))}</span>,0)}<span class="fstat-no" title="function not covered" ></span>ge</span>t commands(){<span class="cstat-no" title="statement not covered" >return this.commandManager.createCommands()}<span class="fstat-no" title="function not covered" ></span>ch</span>ain(){<span class="cstat-no" title="statement not covered" >return this.commandManager.createChain()}<span class="fstat-no" title="function not covered" ></span>ca</span>n(){<span class="cstat-no" title="statement not covered" >return this.commandManager.createCan()}<span class="fstat-no" title="function not covered" ></span>in</span>jectCSS(){<span class="cstat-no" title="statement not covered" >this.options.injectCSS&amp;&amp;document&amp;&amp;(this.css=Ap(pd))}<span class="fstat-no" title="function not covered" ></span>se</span>tOptions(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.options={...this.options,...t},this.view&amp;&amp;this.state&amp;&amp;!this.isDestroyed&amp;&amp;(this.options.editorProps&amp;&amp;this.view.setProps(this.options.editorProps),this.view.updateState(this.state))}<span class="fstat-no" title="function not covered" ></span>se</span>tEditable(t){<span class="cstat-no" title="statement not covered" >this.setOptions({editable:t})}<span class="fstat-no" title="function not covered" ></span>ge</span>t isEditable(){<span class="cstat-no" title="statement not covered" >return this.options.editable&amp;&amp;this.view&amp;&amp;this.view.editable}<span class="fstat-no" title="function not covered" ></span>ge</span>t state(){<span class="cstat-no" title="statement not covered" >return this.view.state}<span class="fstat-no" title="function not covered" ></span>re</span>gisterPlugin(t,e){const n=<span class="cstat-no" title="statement not covered" >"function"===typeof e?e(t,this.state.plugins):[...this.state.plugins,t],</span>r=<span class="cstat-no" title="statement not covered" >this.state.reconfigure({plugins:n});<span class="cstat-no" title="statement not covered" ></span>this.view.updateState(r)}<span class="fstat-no" title="function not covered" ></span>un</span>registerPlugin(t){<span class="cstat-no" title="statement not covered" >if(this.isDestroyed)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >"string"===typeof t?t+"$":t.key,</span>n=<span class="cstat-no" title="statement not covered" >this.state.reconfigure({plugins:this.state.plugins.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.key.startsWith(e))</span>});<span class="cstat-no" title="statement not covered" ></span>this.view.updateState(n)}<span class="fstat-no" title="function not covered" ></span>cr</span>eateExtensionManager(){const t=<span class="cstat-no" title="statement not covered" >Object.entries(ld).map(<span class="fstat-no" title="function not covered" >([</span>,t])=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,</span>e=<span class="cstat-no" title="statement not covered" >[...t,...this.options.extensions].filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >["extension","node","mark"].includes(null===t||void 0===t?void 0:t.type))</span>;<span class="cstat-no" title="statement not covered" ></span>this.extensionManager=new Kp(e,this)}<span class="fstat-no" title="function not covered" ></span>cr</span>eateCommandManager(){<span class="cstat-no" title="statement not covered" >this.commandManager=new Ip(this,this.extensionManager.commands)}<span class="fstat-no" title="function not covered" ></span>cr</span>eateSchema(){<span class="cstat-no" title="statement not covered" >this.schema=this.extensionManager.schema}<span class="fstat-no" title="function not covered" ></span>cr</span>eateView(){<span class="cstat-no" title="statement not covered" >this.view=new Qc(this.options.element,{...this.options.editorProps,dispatchTransaction:this.dispatchTransaction.bind(this),state:li.create({doc:Mp(this.options.content,this.schema,this.options.parseOptions)})});c</span>onst t=<span class="cstat-no" title="statement not covered" >this.state.reconfigure({plugins:this.extensionManager.plugins});<span class="cstat-no" title="statement not covered" ></span>this.view.updateState(t),this.createNodeViews();c</span>onst e=<span class="cstat-no" title="statement not covered" >this.view.dom;<span class="cstat-no" title="statement not covered" ></span>e.editor=this}<span class="fstat-no" title="function not covered" ></span>cr</span>eateNodeViews(){<span class="cstat-no" title="statement not covered" >this.view.setProps({nodeViews:this.extensionManager.nodeViews})}<span class="fstat-no" title="function not covered" ></span>ca</span>ptureTransaction(t){<span class="cstat-no" title="statement not covered" >this.isCapturingTransaction=!0,t(),this.isCapturingTransaction=!1;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.capturedTransaction;<span class="cstat-no" title="statement not covered" ></span>return this.capturedTransaction=null,e}<span class="fstat-no" title="function not covered" ></span>di</span>spatchTransaction(t){<span class="cstat-no" title="statement not covered" >if(this.isCapturingTransaction)<span class="cstat-no" title="statement not covered" >return this.capturedTransaction?void t.steps.forEach(<span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;<span class="cstat-no" title="statement not covered" >return null===(e=this.capturedTransaction)||void 0===e?void 0:e.step(t)}</span>):void(this.capturedTransaction=t);c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.state.apply(t),</span>n=<span class="cstat-no" title="statement not covered" >!this.state.selection.eq(e.selection);<span class="cstat-no" title="statement not covered" ></span>this.view.updateState(e),this.emit("transaction",{editor:this,transaction:t}),n&amp;&amp;this.emit("selectionUpdate",{editor:this,transaction:t});c</span>onst r=<span class="cstat-no" title="statement not covered" >t.getMeta("focus"),</span>o=<span class="cstat-no" title="statement not covered" >t.getMeta("blur");<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;this.emit("focus",{editor:this,event:r.event,transaction:t}),o&amp;&amp;this.emit("blur",{editor:this,event:o.event,transaction:t}),t.docChanged&amp;&amp;!t.getMeta("preventUpdate")&amp;&amp;this.emit("update",{editor:this,transaction:t})}<span class="fstat-no" title="function not covered" ></span>ge</span>tAttributes(t){<span class="cstat-no" title="statement not covered" >return vp(this.state,t)}<span class="fstat-no" title="function not covered" ></span>is</span>Active(t,e){const n=<span class="cstat-no" title="statement not covered" >"string"===typeof t?t:null,</span>r=<span class="cstat-no" title="statement not covered" >"string"===typeof t?e:t;<span class="cstat-no" title="statement not covered" ></span>return Op(this.state,n,r)}<span class="fstat-no" title="function not covered" ></span>ge</span>tJSON(){<span class="cstat-no" title="statement not covered" >return this.state.doc.toJSON()}<span class="fstat-no" title="function not covered" ></span>ge</span>tHTML(){<span class="cstat-no" title="statement not covered" >return Cp(this.state.doc,this.schema)}<span class="fstat-no" title="function not covered" ></span>ge</span>tText(t){const{blockSeparator:e=<span class="branch-0 cbranch-no" title="branch not covered" >"\n\n",</span>textSerializers:n=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>=<span class="cstat-no" title="statement not covered" >t||{};<span class="cstat-no" title="statement not covered" ></span>return Tp(this.state.doc,{blockSeparator:e,textSerializers:{...n,...jp(this.schema)}})}<span class="fstat-no" title="function not covered" ></span>ge</span>t isEmpty(){<span class="cstat-no" title="statement not covered" >return Np(this.state.doc)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCharacterCount(){<span class="cstat-no" title="statement not covered" >return this.state.doc.content.size-2}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.emit("destroy"),this.view&amp;&amp;this.view.destroy(),this.removeAllListeners(),kp(this.css)}<span class="fstat-no" title="function not covered" ></span>ge</span>t isDestroyed(){var t;<span class="cstat-no" title="statement not covered" >return!(null===(t=this.view)||void 0===t?void 0:t.docView)}</span>}class hd{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.type="node",this.name="node",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...t},this.name=this.config.name,this.options=this.config.defaultOptions}<span class="fstat-no" title="function not covered" ></span>st</span>atic create(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return new hd(t)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >this.extend();<span class="cstat-no" title="statement not covered" ></span>return e.options=Xp(this.options,t),e}<span class="fstat-no" title="function not covered" ></span>ex</span>tend(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >new hd(t);<span class="cstat-no" title="statement not covered" ></span>return e.parent=this,this.child=e,e.name=t.name?t.name:e.parent.name,e.options=t.defaultOptions?t.defaultOptions:e.parent.options,e}</span>}class dd{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.type="mark",this.name="mark",this.parent=null,this.child=null,this.config={name:this.name,defaultOptions:{}},this.config={...this.config,...t},this.name=this.config.name,this.options=this.config.defaultOptions}<span class="fstat-no" title="function not covered" ></span>st</span>atic create(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return new dd(t)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >this.extend();<span class="cstat-no" title="statement not covered" ></span>return e.options=Xp(this.options,t),e}<span class="fstat-no" title="function not covered" ></span>ex</span>tend(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const e=<span class="cstat-no" title="statement not covered" >new dd(t);<span class="cstat-no" title="statement not covered" ></span>return e.parent=this,this.child=e,e.name=t.name?t.name:e.parent.name,e.options=t.defaultOptions?t.defaultOptions:e.parent.options,e}</span>}function <span class="fstat-no" title="function not covered" >fd(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return new Sl(t,<span class="fstat-no" title="function not covered" >(t</span>,r,o,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >n instanceof Function?n(r):n,</span>{tr:a}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return r[0]&amp;&amp;a.replaceWith(o-1,i,e.create(s)),a}</span>)}</span>function <span class="fstat-no" title="function not covered" >md(</span>t,e,n){let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return n.doc.nodesBetween(t,e,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >r=[...r,...t.marks.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;(<span class="cstat-no" title="statement not covered" >{from:e,to:e+t.nodeSize,mark:n})</span>)]}</span>),r}</span>function <span class="fstat-no" title="function not covered" >vd(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return new Sl(t,<span class="fstat-no" title="function not covered" >(t</span>,r,o,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >n instanceof Function?n(r):n,</span>{tr:a}=<span class="cstat-no" title="statement not covered" >t,</span>c=<span class="cstat-no" title="statement not covered" >r[r.length-1],</span>l=<span class="cstat-no" title="statement not covered" >r[0];</span>let p=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(c){const n=<span class="cstat-no" title="statement not covered" >l.search(/\S/),</span>r=<span class="cstat-no" title="statement not covered" >o+l.indexOf(c),</span>u=<span class="cstat-no" title="statement not covered" >r+c.length,</span>h=<span class="cstat-no" title="statement not covered" >md(o,i,t).filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const{excluded:n}=<span class="cstat-no" title="statement not covered" >t.mark.type;<span class="cstat-no" title="statement not covered" ></span>return n.find(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.name===e.name)</span>}</span>).filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.to&gt;r)</span>;<span class="cstat-no" title="statement not covered" ></span>if(h.length)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >u</span></span>&lt;i&amp;&amp;a.delete(u,i),r&gt;o&amp;&amp;a.delete(o+n,r),p=o+n+c.length,a.addMark(o+n,p,e.create(s)),a.removeStoredMark(e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>)}</span>function <span class="fstat-no" title="function not covered" >gd(</span>t,e,n){const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(o</span>,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return o.forEach(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(o.isText&amp;&amp;o.text){const{text:r}=<span class="cstat-no" title="statement not covered" >o;</span>let a,c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>while(null!==(a=t.exec(r))){const t=<span class="cstat-no" title="statement not covered" >Math.max(a.length-2,0),</span>r=<span class="cstat-no" title="statement not covered" >Math.max(a.length-1,0);<span class="cstat-no" title="statement not covered" ></span>if(null===i||void 0===i?void 0:i.type.allowsMarkType(e)){const i=<span class="cstat-no" title="statement not covered" >a.index,</span>l=<span class="cstat-no" title="statement not covered" >i+a[0].indexOf(a[t]),</span>p=<span class="cstat-no" title="statement not covered" >l+a[t].length,</span>u=<span class="cstat-no" title="statement not covered" >l+a[t].lastIndexOf(a[r]),</span>h=<span class="cstat-no" title="statement not covered" >u+a[r].length,</span>d=<span class="cstat-no" title="statement not covered" >n instanceof Function?n(a):n;<span class="cstat-no" title="statement not covered" ></span>if(!d&amp;&amp;void 0!==d)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >l</span></span>&gt;0&amp;&amp;s.push(o.cut(c,l)),s.push(o.cut(u,h).mark(e.create(d).addToSet(o.marks))),c=p}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>&lt;r.length&amp;&amp;s.push(o.cut(c))}</span>else <span class="cstat-no" title="statement not covered" >s.push(o.copy(r(o.content,o)))}</span></span>),Cn.fromArray(s)}</span>;<span class="cstat-no" title="statement not covered" ></span>return new di({key:new vi("markPasteRule"),props:{transformPasted:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >new Dn(r(t.content),t.openStart,t.openEnd)}</span>})}</span>function <span class="fstat-no" title="function not covered" >yd(</span>t){<span class="cstat-no" title="statement not covered" >return $p(t)&amp;&amp;t instanceof Go}</span>function <span class="fstat-no" title="function not covered" >bd(</span>t,e,n){const r=<span class="cstat-no" title="statement not covered" >t.coordsAtPos(e),</span>o=<span class="cstat-no" title="statement not covered" >t.coordsAtPos(n,-1),</span>i=<span class="cstat-no" title="statement not covered" >Math.min(r.top,o.top),</span>s=<span class="cstat-no" title="statement not covered" >Math.max(r.bottom,o.bottom),</span>a=<span class="cstat-no" title="statement not covered" >Math.min(r.left,o.left),</span>c=<span class="cstat-no" title="statement not covered" >Math.max(r.right,o.right),</span>l=<span class="cstat-no" title="statement not covered" >c-a,</span>p=<span class="cstat-no" title="statement not covered" >s-i,</span>u=<span class="cstat-no" title="statement not covered" >a,</span>h=<span class="cstat-no" title="statement not covered" >i,</span>d=<span class="cstat-no" title="statement not covered" >{top:i,bottom:s,left:a,right:c,width:l,height:p,x:u,y:h};<span class="cstat-no" title="statement not covered" ></span>return{...d,toJSON:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >d}</span>}</span>class wd{<span class="fstat-no" title="function not covered" >co</span>nstructor({editor:t,element:e,view:n,tippyOptions:r=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>shouldShow:o}){<span class="cstat-no" title="statement not covered" >this.preventHide=!1,this.shouldShow=<span class="fstat-no" title="function not covered" >({</span>state:t,from:e,to:n})=&gt;{const{doc:r,selection:o}=<span class="cstat-no" title="statement not covered" >t,</span>{empty:i}=<span class="cstat-no" title="statement not covered" >o,</span>s=<span class="cstat-no" title="statement not covered" >!r.textBetween(e,n).length&amp;&amp;Tu(t.selection);<span class="cstat-no" title="statement not covered" ></span>return!i&amp;&amp;!s}</span>,this.mousedownHandler=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.preventHide=!0}</span>,this.dragstartHandler=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.hide()}</span>,this.focusHandler=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.update(this.editor.view))</span>}</span>,this.blurHandler=<span class="fstat-no" title="function not covered" >({</span>event:t})=&gt;{var e;<span class="cstat-no" title="statement not covered" >this.preventHide?this.preventHide=!1:(null===t||void 0===t?void 0:t.relatedTarget)&amp;&amp;(null===(e=this.element.parentNode)||void 0===e?void 0:e.contains(t.relatedTarget))||this.hide()}</span>,this.editor=t,this.element=e,this.view=n,o&amp;&amp;(this.shouldShow=o),this.element.addEventListener("mousedown",this.mousedownHandler,{capture:!0}),this.view.dom.addEventListener("dragstart",this.dragstartHandler),this.editor.on("focus",this.focusHandler),this.editor.on("blur",this.blurHandler),this.tippyOptions=r,this.element.remove(),this.element.style.visibility="visible"}<span class="fstat-no" title="function not covered" ></span>cr</span>eateTooltip(){const{element:t}=<span class="cstat-no" title="statement not covered" >this.editor.options,</span>e=<span class="cstat-no" title="statement not covered" >!!t.parentElement;<span class="cstat-no" title="statement not covered" ></span>!this.tippy&amp;&amp;e&amp;&amp;(this.tippy=wn(t,{duration:0,getReferenceClientRect:null,content:this.element,interactive:!0,trigger:"manual",placement:"top",hideOnClick:"toggle",...this.tippyOptions}))}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){var n,r;const{state:o,composing:i}=<span class="cstat-no" title="statement not covered" >t,</span>{doc:s,selection:a}=<span class="cstat-no" title="statement not covered" >o,</span>c=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.doc.eq(s)&amp;&amp;e.selection.eq(a);<span class="cstat-no" title="statement not covered" ></span>if(i||c)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.createTooltip();c</span>onst{ranges:l}=<span class="cstat-no" title="statement not covered" >a,</span>p=<span class="cstat-no" title="statement not covered" >Math.min(...l.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.$from.pos)</span>),</span>u=<span class="cstat-no" title="statement not covered" >Math.max(...l.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.$to.pos)</span>),</span>h=<span class="cstat-no" title="statement not covered" >null===(n=this.shouldShow)||void 0===n?void 0:n.call(this,{editor:this.editor,view:t,state:o,oldState:e,from:p,to:u});<span class="cstat-no" title="statement not covered" ></span>h?(null===(r=this.tippy)||void 0===r||r.setProps({getReferenceClientRect:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(yd(o.selection)){const e=<span class="cstat-no" title="statement not covered" >t.nodeDOM(p);<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return e.getBoundingClientRect()}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn bd(t,p,u)}</span>}),this.show()):this.hide()}<span class="fstat-no" title="function not covered" ></span>sh</span>ow(){var t;<span class="cstat-no" title="statement not covered" >null===(t=this.tippy)||void 0===t||t.show()}<span class="fstat-no" title="function not covered" ></span>hi</span>de(){var t;<span class="cstat-no" title="statement not covered" >null===(t=this.tippy)||void 0===t||t.hide()}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){var t;<span class="cstat-no" title="statement not covered" >null===(t=this.tippy)||void 0===t||t.destroy(),this.element.removeEventListener("mousedown",this.mousedownHandler),this.view.dom.removeEventListener("dragstart",this.dragstartHandler),this.editor.off("focus",this.focusHandler),this.editor.off("blur",this.blurHandler)}</span>}const Od=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >new di({key:"string"===typeof t.pluginKey?new vi(t.pluginKey):t.pluginKey,view:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new wd({view:e,...t})}</span>);<span class="cstat-no" title="statement not covered" ></span></span>Qp.create({name:"bubbleMenu",defaultOptions:{element:null,tippyOptions:{},pluginKey:"bubbleMenu",shouldShow:null},<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){<span class="cstat-no" title="statement not covered" >return this.options.element?[Od({pluginKey:this.options.pluginKey,editor:this.editor,element:this.options.element,tippyOptions:this.options.tippyOptions,shouldShow:this.options.shouldShow})]:[]}</span>});c</span>lass kd{<span class="fstat-no" title="function not covered" >co</span>nstructor({editor:t,element:e,view:n,tippyOptions:r=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>shouldShow:o}){<span class="cstat-no" title="statement not covered" >this.preventHide=!1,this.shouldShow=<span class="fstat-no" title="function not covered" >({</span>state:t})=&gt;{const{selection:e}=<span class="cstat-no" title="statement not covered" >t,</span>{$anchor:n,empty:r}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >1===n.depth,</span>i=<span class="cstat-no" title="statement not covered" >n.parent.isTextblock&amp;&amp;!n.parent.type.spec.code&amp;&amp;!n.parent.textContent;<span class="cstat-no" title="statement not covered" ></span>return!!(r&amp;&amp;o&amp;&amp;i)}</span>,this.mousedownHandler=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.preventHide=!0}</span>,this.focusHandler=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.update(this.editor.view))</span>}</span>,this.blurHandler=<span class="fstat-no" title="function not covered" >({</span>event:t})=&gt;{var e;<span class="cstat-no" title="statement not covered" >this.preventHide?this.preventHide=!1:(null===t||void 0===t?void 0:t.relatedTarget)&amp;&amp;(null===(e=this.element.parentNode)||void 0===e?void 0:e.contains(t.relatedTarget))||this.hide()}</span>,this.editor=t,this.element=e,this.view=n,o&amp;&amp;(this.shouldShow=o),this.element.addEventListener("mousedown",this.mousedownHandler,{capture:!0}),this.editor.on("focus",this.focusHandler),this.editor.on("blur",this.blurHandler),this.tippyOptions=r,this.element.remove(),this.element.style.visibility="visible"}<span class="fstat-no" title="function not covered" ></span>cr</span>eateTooltip(){const{element:t}=<span class="cstat-no" title="statement not covered" >this.editor.options,</span>e=<span class="cstat-no" title="statement not covered" >!!t.parentElement;<span class="cstat-no" title="statement not covered" ></span>!this.tippy&amp;&amp;e&amp;&amp;(this.tippy=wn(t,{duration:0,getReferenceClientRect:null,content:this.element,interactive:!0,trigger:"manual",placement:"right",hideOnClick:"toggle",...this.tippyOptions}))}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){var n,r;const{state:o,composing:i}=<span class="cstat-no" title="statement not covered" >t,</span>{doc:s,selection:a}=<span class="cstat-no" title="statement not covered" >o,</span>{from:c,to:l}=<span class="cstat-no" title="statement not covered" >a,</span>p=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.doc.eq(s)&amp;&amp;e.selection.eq(a);<span class="cstat-no" title="statement not covered" ></span>if(i||p)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.createTooltip();c</span>onst u=<span class="cstat-no" title="statement not covered" >null===(n=this.shouldShow)||void 0===n?void 0:n.call(this,{editor:this.editor,view:t,state:o,oldState:e});<span class="cstat-no" title="statement not covered" ></span>u?(null===(r=this.tippy)||void 0===r||r.setProps({getReferenceClientRect:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >bd(t,c,l)}</span>),this.show()):this.hide()}<span class="fstat-no" title="function not covered" ></span>sh</span>ow(){var t;<span class="cstat-no" title="statement not covered" >null===(t=this.tippy)||void 0===t||t.show()}<span class="fstat-no" title="function not covered" ></span>hi</span>de(){var t;<span class="cstat-no" title="statement not covered" >null===(t=this.tippy)||void 0===t||t.hide()}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){var t;<span class="cstat-no" title="statement not covered" >null===(t=this.tippy)||void 0===t||t.destroy(),this.element.removeEventListener("mousedown",this.mousedownHandler),this.editor.off("focus",this.focusHandler),this.editor.off("blur",this.blurHandler)}</span>}const xd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >new di({key:"string"===typeof t.pluginKey?new vi(t.pluginKey):t.pluginKey,view:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new kd({view:e,...t})}</span>);<span class="cstat-no" title="statement not covered" ></span></span>Qp.create({name:"floatingMenu",defaultOptions:{element:null,tippyOptions:{},pluginKey:"floatingMenu",shouldShow:null},<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){<span class="cstat-no" title="statement not covered" >return this.options.element?[xd({pluginKey:this.options.pluginKey,editor:this.editor,element:this.options.element,tippyOptions:this.options.tippyOptions,shouldShow:this.options.shouldShow})]:[]}</span>}),Object(r["defineComponent"])({name:"BubbleMenu",props:{pluginKey:{type:null,default:"bubbleMenu"},editor:{type:Object,required:!0},tippyOptions:{type:Object,default:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{})</span>},shouldShow:{type:Function,default:null}},<span class="fstat-no" title="function not covered" >se</span>tup(t,{slots:e}){const n=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(null);<span class="cstat-no" title="statement not covered" ></span>return Object(r["onMounted"])(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{pluginKey:e,editor:r,tippyOptions:o,shouldShow:i}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>r.registerPlugin(Od({pluginKey:e,editor:r,element:n.value,tippyOptions:o,shouldShow:i}))}</span>),Object(r["onBeforeUnmount"])(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{pluginKey:e,editor:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>n.unregisterPlugin(e)}</span>),<span class="fstat-no" title="function not covered" >()</span>=&gt;{var t;<span class="cstat-no" title="statement not covered" >return Object(r["h"])("div",{ref:n},null===(t=e.default)||void 0===t?void 0:t.call(e))}</span>}</span>});f</span>unction <span class="fstat-no" title="function not covered" >Sd(</span>t){<span class="cstat-no" title="statement not covered" >return Object(r["customRef"])(<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;(<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >return e(),t}</span>,<span class="fstat-no" title="function not covered" >se</span>t(e){<span class="cstat-no" title="statement not covered" >t=e,requestAnimationFrame(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >requestAnimationFrame(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n()}</span>)}</span>)}</span>})</span>)}</span>class Md extends ud{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return super(t),this.vueRenderers=Object(r["reactive"])(new Map),this.contentComponent=null,this.reactiveState=Sd(this.view.state),this.on("transaction",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.reactiveState.value=this.view.state}</span>),Object(r["markRaw"])(this)}<span class="fstat-no" title="function not covered" ></span>ge</span>t state(){<span class="cstat-no" title="statement not covered" >return this.reactiveState?this.reactiveState.value:this.view.state}<span class="fstat-no" title="function not covered" ></span>re</span>gisterPlugin(t,e){<span class="cstat-no" title="statement not covered" >super.registerPlugin(t,e),this.reactiveState.value=this.view.state}<span class="fstat-no" title="function not covered" ></span>un</span>registerPlugin(t){<span class="cstat-no" title="statement not covered" >super.unregisterPlugin(t),this.reactiveState.value=this.view.state}</span>}const Cd=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({name:"EditorContent",props:{editor:{default:null,type:Object}},<span class="fstat-no" title="function not covered" >se</span>tup(t){const e=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(),</span>n=<span class="cstat-no" title="statement not covered" >Object(r["getCurrentInstance"])();<span class="cstat-no" title="statement not covered" ></span>return Object(r["watchEffect"])(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const o=<span class="cstat-no" title="statement not covered" >t.editor;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;o.options.element&amp;&amp;e.value&amp;&amp;Object(r["nextTick"])(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!e.value||!o.options.element.firstChild)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >Object(r["unref"])(e.value);<span class="cstat-no" title="statement not covered" ></span>e.value.append(...o.options.element.childNodes),o.contentComponent=n.ctx._,o.setOptions({element:t}),o.createNodeViews()}</span>)}</span>),Object(r["onBeforeUnmount"])(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const e=<span class="cstat-no" title="statement not covered" >t.editor;<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.isDestroyed||e.view.setProps({nodeViews:{}}),e.contentComponent=null,!e.options.element.firstChild)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>n.append(...e.options.element.childNodes),e.setOptions({element:n})}</span>),{rootEl:e}}</span>,<span class="fstat-no" title="function not covered" >re</span>nder(){const t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.editor&amp;&amp;this.editor.vueRenderers.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >Object(r["h"])(r["Teleport"],{to:e.teleportElement,key:e.id},Object(r["h"])(e.component,{ref:e.id,...e.props}));<span class="cstat-no" title="statement not covered" ></span>t.push(n)}</span>),Object(r["h"])("div",{ref:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.rootEl=t}</span>},...t)}</span>}),</span>Ed=(<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({name:"FloatingMenu",props:{pluginKey:{type:null,default:"floatingMenu"},editor:{type:Object,required:!0},tippyOptions:{type:Object,default:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{})</span>},shouldShow:{type:Function,default:null}},<span class="fstat-no" title="function not covered" >se</span>tup(t,{slots:e}){const n=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(null);<span class="cstat-no" title="statement not covered" ></span>return Object(r["onMounted"])(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{pluginKey:e,editor:r,tippyOptions:o,shouldShow:i}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>r.registerPlugin(xd({pluginKey:e,editor:r,element:n.value,tippyOptions:o,shouldShow:i}))}</span>),Object(r["onBeforeUnmount"])(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{pluginKey:e,editor:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>n.unregisterPlugin(e)}</span>),<span class="fstat-no" title="function not covered" >()</span>=&gt;{var t;<span class="cstat-no" title="statement not covered" >return Object(r["h"])("div",{ref:n},null===(t=e.default)||void 0===t?void 0:t.call(e))}</span>}</span>}),<span class="fstat-no" title="function not covered" >(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{const e=<span class="cstat-no" title="statement not covered" >Object(r["shallowRef"])();<span class="cstat-no" title="statement not covered" ></span>return Object(r["onMounted"])(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e.value=new Md(t)}</span>),Object(r["onBeforeUnmount"])(<span class="fstat-no" title="function not covered" >()</span>=&gt;{var t;<span class="cstat-no" title="statement not covered" >null===(t=e.value)||void 0===t||t.destroy()}</span>),e}</span>)</span>;class Td{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,{props:e=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>editor:n}){<span class="cstat-no" title="statement not covered" >if(this.id=Math.floor(4294967295*Math.random()).toString(),this.editor=n,this.component=Object(r["markRaw"])(t),this.teleportElement=document.createElement("div"),this.element=this.teleportElement,this.props=Object(r["reactive"])(e),this.editor.vueRenderers.set(this.id,this),this.editor.contentComponent){<span class="cstat-no" title="statement not covered" >if(this.editor.contentComponent.update(),1!==this.teleportElement.children.length)<span class="cstat-no" title="statement not covered" >throw Error("VueRenderer doesn’t support multiple child elements.");<span class="cstat-no" title="statement not covered" >t</span></span>his.element=this.teleportElement.firstElementChild}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t ref(){var t;<span class="cstat-no" title="statement not covered" >return null===(t=this.editor.contentComponent)||void 0===t?void 0:t.refs[this.id]}<span class="fstat-no" title="function not covered" ></span>up</span>dateProps(t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >Object.entries(t).forEach(<span class="fstat-no" title="function not covered" >([</span>t,e])=&gt;{<span class="cstat-no" title="statement not covered" >this.props[t]=e}</span>)}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.editor.vueRenderers.delete(this.id)}</span>}<span class="cstat-no" title="statement not covered" >Boolean;<span class="cstat-no" title="statement not covered" >O</span>bject(r["defineComponent"])({props:{as:{type:String,default:"div"}},inject:["onDragStart","decorationClasses"],<span class="fstat-no" title="function not covered" >re</span>nder(){var t,e;<span class="cstat-no" title="statement not covered" >return Object(r["h"])(this.as,{class:this.decorationClasses.value,style:{whiteSpace:"normal"},"data-node-view-wrapper":"",onDragStart:this.onDragStart},null===(e=(t=this.$slots).default)||void 0===e?void 0:e.call(t))}</span>}),Object(r["defineComponent"])({props:{as:{type:String,default:"div"}},<span class="fstat-no" title="function not covered" >re</span>nder(){<span class="cstat-no" title="statement not covered" >return Object(r["h"])(this.as,{style:{whiteSpace:"pre-wrap"},"data-node-view-content":""})}</span>});c</span>onst Nd=<span class="cstat-no" title="statement not covered" >hd.create({name:"doc",topNode:!0,content:"block+"});</span>var jd=<span class="cstat-no" title="statement not covered" >Nd;</span>const Ad=<span class="cstat-no" title="statement not covered" >hd.create({name:"paragraph",priority:1e3,defaultOptions:{HTMLAttributes:{}},group:"block",content:"inline*",<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"p"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["p",Pp(this.options.HTMLAttributes,t),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setParagraph:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.setNode("paragraph")}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-Alt-0":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.setParagraph()}</span>}</span>}),</span>Id=<span class="cstat-no" title="statement not covered" >hd.create({name:"text",group:"inline"});</span>var Dd=<span class="cstat-no" title="statement not covered" >Id;</span>function <span class="fstat-no" title="function not covered" >Rd(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0;</span>;r++){<span class="cstat-no" title="statement not covered" >if(r==t.childCount||r==e.childCount)<span class="cstat-no" title="statement not covered" >return t.childCount==e.childCount?null:n;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t.child(r),</span>i=<span class="cstat-no" title="statement not covered" >e.child(r);<span class="cstat-no" title="statement not covered" ></span>if(o!=i){<span class="cstat-no" title="statement not covered" >if(!o.sameMarkup(i))<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.isText&amp;&amp;o.text!=i.text){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>o.text[s]==i.text[s];s++)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o.content.size||i.content.size){var a=<span class="cstat-no" title="statement not covered" >Rd(o.content,i.content,n+1);<span class="cstat-no" title="statement not covered" ></span>if(null!=a)<span class="cstat-no" title="statement not covered" >return a}<span class="cstat-no" title="statement not covered" ></span></span>n</span>+=o.nodeSize}</span>else <span class="cstat-no" title="statement not covered" >n+=o.nodeSize}</span></span>}</span>function <span class="fstat-no" title="function not covered" >_d(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >t.childCount,</span>i=<span class="cstat-no" title="statement not covered" >e.childCount;</span>;){<span class="cstat-no" title="statement not covered" >if(0==o||0==i)<span class="cstat-no" title="statement not covered" >return o==i?null:{a:n,b:r};v</span></span>ar s=<span class="cstat-no" title="statement not covered" >t.child(--o),</span>a=<span class="cstat-no" title="statement not covered" >e.child(--i),</span>c=<span class="cstat-no" title="statement not covered" >s.nodeSize;<span class="cstat-no" title="statement not covered" ></span>if(s!=a){<span class="cstat-no" title="statement not covered" >if(!s.sameMarkup(a))<span class="cstat-no" title="statement not covered" >return{a:n,b:r};<span class="cstat-no" title="statement not covered" >i</span></span>f(s.isText&amp;&amp;s.text!=a.text){var l=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" >Math.min(s.text.length,a.text.length);<span class="cstat-no" title="statement not covered" ></span>while(l&lt;p&amp;&amp;s.text[s.text.length-l-1]==a.text[a.text.length-l-1])<span class="cstat-no" title="statement not covered" >l++,n--,r--;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{a:n,b:r}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.content.size||a.content.size){var u=<span class="cstat-no" title="statement not covered" >_d(s.content,a.content,n-1,r-1);<span class="cstat-no" title="statement not covered" ></span>if(u)<span class="cstat-no" title="statement not covered" >return u}<span class="cstat-no" title="statement not covered" ></span></span>n</span>-=c,r-=c}</span>else <span class="cstat-no" title="statement not covered" >n-=c,r-=c}</span></span>}</span>var Pd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(this.content=t,this.size=e||0,null==e)<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >this.size+=t[n].nodeSize}</span></span></span>,</span>zd=<span class="cstat-no" title="statement not covered" >{firstChild:{configurable:!0},lastChild:{configurable:!0},childCount:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>Pd.prototype.nodesBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=0);<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;e;i++){var a=<span class="cstat-no" title="statement not covered" >this.content[i],</span>c=<span class="cstat-no" title="statement not covered" >s+a.nodeSize;<span class="cstat-no" title="statement not covered" ></span>if(c&gt;t&amp;&amp;!1!==n(a,r+s,o,i)&amp;&amp;a.content.size){var l=<span class="cstat-no" title="statement not covered" >s+1;<span class="cstat-no" title="statement not covered" ></span>a.nodesBetween(Math.max(0,t-l),Math.min(a.content.size,e-l),n,r+l)}<span class="cstat-no" title="statement not covered" ></span>s</span>=c}</span>}</span>,Pd.prototype.descendants=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.nodesBetween(0,this.size,t)}</span>,Pd.prototype.textBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >"",</span>i=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>return this.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(s,a){<span class="cstat-no" title="statement not covered" >s.isText?(o+=s.text.slice(Math.max(t,a)-a,e-a),i=!n):s.isLeaf&amp;&amp;r?(o+=r,i=!n):!i&amp;&amp;s.isBlock&amp;&amp;(o+=n,i=!0)}</span>),0),o}</span>,Pd.prototype.append=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t.size)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.size)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.lastChild,</span>n=<span class="cstat-no" title="statement not covered" >t.firstChild,</span>r=<span class="cstat-no" title="statement not covered" >this.content.slice(),</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(e.isText&amp;&amp;e.sameMarkup(n)&amp;&amp;(r[r.length-1]=e.withText(e.text+n.text),o=1);o&lt;t.content.length;o++)<span class="cstat-no" title="statement not covered" >r.push(t.content[o]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Pd(r,this.size+t.size)}</span>,Pd.prototype.cut=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(null==e&amp;&amp;(e=this.size),0==t&amp;&amp;e==this.size)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;t)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e;o++){var s=<span class="cstat-no" title="statement not covered" >this.content[o],</span>a=<span class="cstat-no" title="statement not covered" >i+s.nodeSize;<span class="cstat-no" title="statement not covered" ></span>a&gt;t&amp;&amp;((i&lt;t||a&gt;e)&amp;&amp;(s=s.isText?s.cut(Math.max(0,t-i),Math.min(s.text.length,e-i)):s.cut(Math.max(0,t-i-1),Math.min(s.content.size,e-i-1))),n.push(s),r+=s.nodeSize),i=a}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn new Pd(n,r)}</span>,Pd.prototype.cutByIndex=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t==e?Pd.empty:0==t&amp;&amp;e==this.content.length?this:new Pd(this.content.slice(t,e))}</span>,Pd.prototype.replaceChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this.content[t];<span class="cstat-no" title="statement not covered" ></span>if(n==e)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.content.slice(),</span>o=<span class="cstat-no" title="statement not covered" >this.size+e.nodeSize-n.nodeSize;<span class="cstat-no" title="statement not covered" ></span>return r[t]=e,new Pd(r,o)}</span>,Pd.prototype.addToStart=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Pd([t].concat(this.content),this.size+t.nodeSize)}</span>,Pd.prototype.addToEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Pd(this.content.concat(t),this.size+t.nodeSize)}</span>,Pd.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.content.length!=t.content.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.content.length;e++)<span class="cstat-no" title="statement not covered" >if(!this.content[e].eq(t.content[e]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,zd.firstChild.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.length?this.content[0]:null}</span>,zd.lastChild.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.length?this.content[this.content.length-1]:null}</span>,zd.childCount.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.length}</span>,Pd.prototype.child=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.content[t];<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index "+t+" out of range for "+this);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,Pd.prototype.maybeChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.content[t]}</span>,Pd.prototype.forEach=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.content.length;e++){var r=<span class="cstat-no" title="statement not covered" >this.content[e];<span class="cstat-no" title="statement not covered" ></span>t(r,n,e),n+=r.nodeSize}</span>}</span>,Pd.prototype.findDiffStart=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=0),Rd(this,t,e)}</span>,Pd.prototype.findDiffEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=this.size),void 0===n&amp;&amp;(n=t.size),_d(this,t,e,n)}</span>,Pd.prototype.findIndex=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(void 0===e&amp;&amp;(e=-1),0==t)<span class="cstat-no" title="statement not covered" >return Ld(0,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(t==this.size)<span class="cstat-no" title="statement not covered" >return Ld(this.content.length,t);<span class="cstat-no" title="statement not covered" >i</span></span>f(t&gt;this.size||t&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Position "+t+" outside of fragment ("+this+")");<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>;n++){var o=<span class="cstat-no" title="statement not covered" >this.child(n),</span>i=<span class="cstat-no" title="statement not covered" >r+o.nodeSize;<span class="cstat-no" title="statement not covered" ></span>if(i&gt;=t)<span class="cstat-no" title="statement not covered" >return i==t||e&gt;0?Ld(n+1,i):Ld(n,r);<span class="cstat-no" title="statement not covered" >r</span></span>=i}</span>}</span>,Pd.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"&lt;"+this.toStringInner()+"&gt;"}</span>,Pd.prototype.toStringInner=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.join(", ")}</span>,Pd.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.length?this.content.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toJSON()}</span>)):null}</span>,Pd.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return Pd.empty;<span class="cstat-no" title="statement not covered" >i</span></span>f(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Fragment.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Pd(e.map(t.nodeFromJSON))}</span>,Pd.fromArray=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return Pd.empty;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e,n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++){var o=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>n+=o.nodeSize,r&amp;&amp;o.isText&amp;&amp;t[r-1].sameMarkup(o)?(e||(e=t.slice(0,r)),e[e.length-1]=o.withText(e[e.length-1].text+o.text)):e&amp;&amp;e.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new Pd(e||t,n)}</span>,Pd.from=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return Pd.empty;<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof Pd)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(t))<span class="cstat-no" title="statement not covered" >return this.fromArray(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.attrs)<span class="cstat-no" title="statement not covered" >return new Pd([t],t.nodeSize);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new RangeError("Can not convert "+t+" to a Fragment"+(t.nodesBetween?" (looks like multiple versions of prosemirror-model were loaded)":""))}</span>,Object.defineProperties(Pd.prototype,zd);v</span>ar Bd=<span class="cstat-no" title="statement not covered" >{index:0,offset:0};</span>function <span class="fstat-no" title="function not covered" >Ld(</span>t,e){<span class="cstat-no" title="statement not covered" >return Bd.index=t,Bd.offset=e,Bd}</span>function <span class="fstat-no" title="function not covered" >Vd(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t===e)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t||"object"!=typeof t||!e||"object"!=typeof e)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >Array.isArray(t);<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(e)!=n)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(n){<span class="cstat-no" title="statement not covered" >if(t.length!=e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++)<span class="cstat-no" title="statement not covered" >if(!Vd(t[r],e[r]))<span class="cstat-no" title="statement not covered" >return!1}</span></span></span>else{<span class="cstat-no" title="statement not covered" >for(var o in t)<span class="cstat-no" title="statement not covered" >if(!(o in e)||!Vd(t[o],e[o]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(var i in e)<span class="cstat-no" title="statement not covered" >if(!(i in t))<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>Pd.empty=new Pd([],0);v</span>ar $d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.type=t,this.attrs=e}</span>;</span>function <span class="fstat-no" title="function not covered" >Fd(</span>t){var e=<span class="cstat-no" title="statement not covered" >Error.call(this,t);<span class="cstat-no" title="statement not covered" ></span>return e.__proto__=Fd.prototype,e}<span class="cstat-no" title="statement not covered" ></span>$d.prototype.addToSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e,n=<span class="cstat-no" title="statement not covered" >!1,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r++){var o=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>if(this.eq(o))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.type.excludes(o.type))<span class="cstat-no" title="statement not covered" >e||(e=t.slice(0,r));e</span>lse{<span class="cstat-no" title="statement not covered" >if(o.type.excludes(this.type))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >!</span></span>n&amp;&amp;o.type.rank&gt;this.type.rank&amp;&amp;(e||(e=t.slice(0,r)),e.push(this),n=!0),e&amp;&amp;e.push(o)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e||(e=t.slice()),n||e.push(this),e}</span>,$d.prototype.removeFromSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(this.eq(t[e]))<span class="cstat-no" title="statement not covered" >return t.slice(0,e).concat(t.slice(e+1));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t}</span>,$d.prototype.isInSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(this.eq(t[e]))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>,$d.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this==t||this.type==t.type&amp;&amp;Vd(this.attrs,t.attrs)}</span>,$d.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >{type:this.type.name};<span class="cstat-no" title="statement not covered" ></span>for(var e in this.attrs){<span class="cstat-no" title="statement not covered" >t.attrs=this.attrs;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,$d.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Mark.fromJSON");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.marks[e.type];<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new RangeError("There is no mark type "+e.type+" in this schema");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.create(e.attrs)}</span>,$d.sameSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t==e)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.length!=e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >if(!t[n].eq(e[n]))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,$d.setFrom=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t||0==t.length)<span class="cstat-no" title="statement not covered" >return $d.none;<span class="cstat-no" title="statement not covered" >i</span></span>f(t instanceof $d)<span class="cstat-no" title="statement not covered" >return[t];v</span></span>ar e=<span class="cstat-no" title="statement not covered" >t.slice();<span class="cstat-no" title="statement not covered" ></span>return e.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.type.rank-e.type.rank}</span>)),e}</span>,$d.none=[],Fd.prototype=Object.create(Error.prototype),Fd.prototype.constructor=Fd,Fd.prototype.name="ReplaceError";v</span>ar Hd=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.content=t,this.openStart=e,this.openEnd=n}</span>,</span>qd=<span class="cstat-no" title="statement not covered" >{size:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >Jd(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.findIndex(e),</span>o=<span class="cstat-no" title="statement not covered" >r.index,</span>i=<span class="cstat-no" title="statement not covered" >r.offset,</span>s=<span class="cstat-no" title="statement not covered" >t.maybeChild(o),</span>a=<span class="cstat-no" title="statement not covered" >t.findIndex(n),</span>c=<span class="cstat-no" title="statement not covered" >a.index,</span>l=<span class="cstat-no" title="statement not covered" >a.offset;<span class="cstat-no" title="statement not covered" ></span>if(i==e||s.isText){<span class="cstat-no" title="statement not covered" >if(l!=n&amp;&amp;!t.child(c).isText)<span class="cstat-no" title="statement not covered" >throw new RangeError("Removing non-flat range");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.cut(0,e).append(t.cut(n))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o!=c)<span class="cstat-no" title="statement not covered" >throw new RangeError("Removing non-flat range");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.replaceChild(o,s.copy(Jd(s.content,e-i-1,n-i-1)))}</span>function <span class="fstat-no" title="function not covered" >Wd(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >t.findIndex(e),</span>i=<span class="cstat-no" title="statement not covered" >o.index,</span>s=<span class="cstat-no" title="statement not covered" >o.offset,</span>a=<span class="cstat-no" title="statement not covered" >t.maybeChild(i);<span class="cstat-no" title="statement not covered" ></span>if(s==e||a.isText)<span class="cstat-no" title="statement not covered" >return r&amp;&amp;!r.canReplace(i,i,n)?null:t.cut(0,e).append(n).append(t.cut(e));v</span></span>ar c=<span class="cstat-no" title="statement not covered" >Wd(a.content,e-s-1,n);<span class="cstat-no" title="statement not covered" ></span>return c&amp;&amp;t.replaceChild(i,a.copy(c))}</span>function <span class="fstat-no" title="function not covered" >Kd(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(n.openStart&gt;t.depth)<span class="cstat-no" title="statement not covered" >throw new Fd("Inserted content deeper than insertion position");<span class="cstat-no" title="statement not covered" >i</span></span>f(t.depth-n.openStart!=e.depth-n.openEnd)<span class="cstat-no" title="statement not covered" >throw new Fd("Inconsistent open depths");<span class="cstat-no" title="statement not covered" >r</span></span>eturn Ud(t,e,n,0)}</span>function <span class="fstat-no" title="function not covered" >Ud(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >t.index(r),</span>i=<span class="cstat-no" title="statement not covered" >t.node(r);<span class="cstat-no" title="statement not covered" ></span>if(o==e.index(r)&amp;&amp;r&lt;t.depth-n.openStart){var s=<span class="cstat-no" title="statement not covered" >Ud(t,e,n,r+1);<span class="cstat-no" title="statement not covered" ></span>return i.copy(i.content.replaceChild(o,s))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n.content.size){<span class="cstat-no" title="statement not covered" >if(n.openStart||n.openEnd||t.depth!=r||e.depth!=r){var a=<span class="cstat-no" title="statement not covered" >nf(n,t),</span>c=<span class="cstat-no" title="statement not covered" >a.start,</span>l=<span class="cstat-no" title="statement not covered" >a.end;<span class="cstat-no" title="statement not covered" ></span>return Zd(i,tf(t,c,l,e,r))}</span>v</span>ar p=<span class="cstat-no" title="statement not covered" >t.parent,</span>u=<span class="cstat-no" title="statement not covered" >p.content;<span class="cstat-no" title="statement not covered" ></span>return Zd(p,u.cut(0,t.parentOffset).append(n.content).append(u.cut(e.parentOffset)))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Zd(i,ef(t,e,r))}</span>function <span class="fstat-no" title="function not covered" >Gd(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e.type.compatibleContent(t.type))<span class="cstat-no" title="statement not covered" >throw new Fd("Cannot join "+e.type.name+" onto "+t.type.name)}</span></span>function <span class="fstat-no" title="function not covered" >Yd(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.node(n);<span class="cstat-no" title="statement not covered" ></span>return Gd(r,e.node(n)),r}</span>function <span class="fstat-no" title="function not covered" >Xd(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >e.length-1;<span class="cstat-no" title="statement not covered" ></span>n&gt;=0&amp;&amp;t.isText&amp;&amp;t.sameMarkup(e[n])?e[n]=t.withText(e[n].text+t.text):e.push(t)}</span>function <span class="fstat-no" title="function not covered" >Qd(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >(e||t).node(n),</span>i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >e?e.index(n):o.childCount;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(i=t.index(n),t.depth&gt;n?i++:t.textOffset&amp;&amp;(Xd(t.nodeAfter,r),i++));<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >i;</span>a&lt;s;a++)<span class="cstat-no" title="statement not covered" >Xd(o.child(a),r);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;e.depth==n&amp;&amp;e.textOffset&amp;&amp;Xd(e.nodeBefore,r)}</span>function <span class="fstat-no" title="function not covered" >Zd(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!t.type.validContent(e))<span class="cstat-no" title="statement not covered" >throw new Fd("Invalid content for node "+t.type.name);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.copy(e)}</span>function <span class="fstat-no" title="function not covered" >tf(</span>t,e,n,r,o){var i=<span class="cstat-no" title="statement not covered" >t.depth&gt;o&amp;&amp;Yd(t,e,o+1),</span>s=<span class="cstat-no" title="statement not covered" >r.depth&gt;o&amp;&amp;Yd(n,r,o+1),</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return Qd(null,t,o,a),i&amp;&amp;s&amp;&amp;e.index(o)==n.index(o)?(Gd(i,s),Xd(Zd(i,tf(t,e,n,r,o+1)),a)):(i&amp;&amp;Xd(Zd(i,ef(t,e,o+1)),a),Qd(e,n,o,a),s&amp;&amp;Xd(Zd(s,ef(n,r,o+1)),a)),Qd(r,null,o,a),new Pd(a)}</span>function <span class="fstat-no" title="function not covered" >ef(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(Qd(null,t,n,r),t.depth&gt;n){var o=<span class="cstat-no" title="statement not covered" >Yd(t,e,n+1);<span class="cstat-no" title="statement not covered" ></span>Xd(Zd(o,ef(t,e,n+1)),r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Qd(e,null,n,r),new Pd(r)}</span>function <span class="fstat-no" title="function not covered" >nf(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >e.depth-t.openStart,</span>r=<span class="cstat-no" title="statement not covered" >e.node(n),</span>o=<span class="cstat-no" title="statement not covered" >r.copy(t.content),</span>i=<span class="cstat-no" title="statement not covered" >n-1;</span>i&gt;=0;i--)<span class="cstat-no" title="statement not covered" >o=e.node(i).copy(Pd.from(o));<span class="cstat-no" title="statement not covered" >r</span></span>eturn{start:o.resolveNoCache(t.openStart+n),end:o.resolveNoCache(o.content.size-t.openEnd-n)}}<span class="cstat-no" title="statement not covered" ></span>qd.size.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.size-this.openStart-this.openEnd}</span>,Hd.prototype.insertAt=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Wd(this.content,t+this.openStart,e,null);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;new Hd(n,this.openStart,this.openEnd)}</span>,Hd.prototype.removeBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new Hd(Jd(this.content,t+this.openStart,e+this.openStart),this.openStart,this.openEnd)}</span>,Hd.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.content.eq(t.content)&amp;&amp;this.openStart==t.openStart&amp;&amp;this.openEnd==t.openEnd}</span>,Hd.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content+"("+this.openStart+","+this.openEnd+")"}</span>,Hd.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.content.size)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >{content:this.content.toJSON()};<span class="cstat-no" title="statement not covered" ></span>return this.openStart&gt;0&amp;&amp;(t.openStart=this.openStart),this.openEnd&gt;0&amp;&amp;(t.openEnd=this.openEnd),t}</span>,Hd.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return Hd.empty;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e.openStart||0,</span>r=<span class="cstat-no" title="statement not covered" >e.openEnd||0;<span class="cstat-no" title="statement not covered" ></span>if("number"!=typeof n||"number"!=typeof r)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Slice.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Hd(Pd.fromJSON(t,e.content),n,r)}</span>,Hd.maxOpen=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=!0);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >t.firstChild;</span>o&amp;&amp;!o.isLeaf&amp;&amp;(e||!o.type.spec.isolating);o=o.firstChild)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >t.lastChild;</span>i&amp;&amp;!i.isLeaf&amp;&amp;(e||!i.type.spec.isolating);i=i.lastChild)<span class="cstat-no" title="statement not covered" >r++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Hd(t,n,r)}</span>,Object.defineProperties(Hd.prototype,qd),Hd.empty=new Hd(Pd.empty,0,0);v</span>ar rf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.pos=t,this.path=e,this.depth=e.length/3-1,this.parentOffset=n}</span>,</span>of=<span class="cstat-no" title="statement not covered" >{parent:{configurable:!0},doc:{configurable:!0},textOffset:{configurable:!0},nodeAfter:{configurable:!0},nodeBefore:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>rf.prototype.resolveDepth=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==t?this.depth:t&lt;0?this.depth+t:t}</span>,of.parent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node(this.depth)}</span>,of.doc.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.node(0)}</span>,rf.prototype.node=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.path[3*this.resolveDepth(t)]}</span>,rf.prototype.index=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.path[3*this.resolveDepth(t)+1]}</span>,rf.prototype.indexAfter=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=this.resolveDepth(t),this.index(t)+(t!=this.depth||this.textOffset?1:0)}</span>,rf.prototype.start=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=this.resolveDepth(t),0==t?0:this.path[3*t-1]+1}</span>,rf.prototype.end=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t=this.resolveDepth(t),this.start(t)+this.node(t).content.size}</span>,rf.prototype.before=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t=this.resolveDepth(t),!t)<span class="cstat-no" title="statement not covered" >throw new RangeError("There is no position before the top-level node");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t==this.depth+1?this.pos:this.path[3*t-1]}</span>,rf.prototype.after=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t=this.resolveDepth(t),!t)<span class="cstat-no" title="statement not covered" >throw new RangeError("There is no position after the top-level node");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t==this.depth+1?this.pos:this.path[3*t-1]+this.path[3*t].nodeSize}</span>,of.textOffset.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.pos-this.path[this.path.length-1]}</span>,of.nodeAfter.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.parent,</span>e=<span class="cstat-no" title="statement not covered" >this.index(this.depth);<span class="cstat-no" title="statement not covered" ></span>if(e==t.childCount)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.pos-this.path[this.path.length-1],</span>r=<span class="cstat-no" title="statement not covered" >t.child(e);<span class="cstat-no" title="statement not covered" ></span>return n?t.child(e).cut(n):r}</span>,of.nodeBefore.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.index(this.depth),</span>e=<span class="cstat-no" title="statement not covered" >this.pos-this.path[this.path.length-1];<span class="cstat-no" title="statement not covered" ></span>return e?this.parent.child(t).cut(0,e):0==t?null:this.parent.child(t-1)}</span>,rf.prototype.posAtIndex=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e=this.resolveDepth(e);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >this.path[3*e],</span>r=<span class="cstat-no" title="statement not covered" >0==e?0:this.path[3*e-1]+1,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t;o++)<span class="cstat-no" title="statement not covered" >r+=n.child(o).nodeSize;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,rf.prototype.marks=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.parent,</span>e=<span class="cstat-no" title="statement not covered" >this.index();<span class="cstat-no" title="statement not covered" ></span>if(0==t.content.size)<span class="cstat-no" title="statement not covered" >return $d.none;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.textOffset)<span class="cstat-no" title="statement not covered" >return t.child(e).marks;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.maybeChild(e-1),</span>r=<span class="cstat-no" title="statement not covered" >t.maybeChild(e);<span class="cstat-no" title="statement not covered" ></span>if(!n){var o=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>n=r,r=o}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >n.marks,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >!1!==i[s].type.spec.inclusive||r&amp;&amp;i[s].isInSet(r.marks)||(i=i[s--].removeFromSet(i));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>,rf.prototype.marksAcross=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.parent.maybeChild(this.index());<span class="cstat-no" title="statement not covered" ></span>if(!e||!e.isInline)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >e.marks,</span>r=<span class="cstat-no" title="statement not covered" >t.parent.maybeChild(t.index()),</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n.length;o++)<span class="cstat-no" title="statement not covered" >!1!==n[o].type.spec.inclusive||r&amp;&amp;n[o].isInSet(r.marks)||(n=n[o--].removeFromSet(n));<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,rf.prototype.sharedDepth=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.depth;</span>e&gt;0;e--)<span class="cstat-no" title="statement not covered" >if(this.start(e)&lt;=t&amp;&amp;this.end(e)&gt;=t)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn 0}</span>,rf.prototype.blockRange=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(void 0===t&amp;&amp;(t=this),t.pos&lt;this.pos)<span class="cstat-no" title="statement not covered" >return t.blockRange(this);<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >this.depth-(this.parent.inlineContent||this.pos==t.pos?1:0);</span>n&gt;=0;n--)<span class="cstat-no" title="statement not covered" >if(t.pos&lt;=this.end(n)&amp;&amp;(!e||e(this.node(n))))<span class="cstat-no" title="statement not covered" >return new lf(this,t,n)}</span></span></span>,rf.prototype.sameParent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.pos-this.parentOffset==t.pos-t.parentOffset}</span>,rf.prototype.max=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.pos&gt;this.pos?t:this}</span>,rf.prototype.min=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.pos&lt;this.pos?t:this}</span>,rf.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >"",</span>e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;=this.depth;e++)<span class="cstat-no" title="statement not covered" >t+=(t?"/":"")+this.node(e).type.name+"_"+this.index(e-1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t+":"+this.parentOffset}</span>,rf.resolve=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!(e&gt;=0&amp;&amp;e&lt;=t.content.size))<span class="cstat-no" title="statement not covered" >throw new RangeError("Position "+e+" out of range");<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>i=<span class="cstat-no" title="statement not covered" >t;</span>;){var s=<span class="cstat-no" title="statement not covered" >i.content.findIndex(o),</span>a=<span class="cstat-no" title="statement not covered" >s.index,</span>c=<span class="cstat-no" title="statement not covered" >s.offset,</span>l=<span class="cstat-no" title="statement not covered" >o-c;<span class="cstat-no" title="statement not covered" ></span>if(n.push(i,a,r+c),!l)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(i=i.child(a),i.isText)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>=l-1,r+=c+1}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn new rf(e,n,o)}</span>,rf.resolveCached=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;sf.length;n++){var r=<span class="cstat-no" title="statement not covered" >sf[n];<span class="cstat-no" title="statement not covered" ></span>if(r.pos==e&amp;&amp;r.doc==t)<span class="cstat-no" title="statement not covered" >return r}</span></span>v</span>ar o=<span class="cstat-no" title="statement not covered" >sf[af]=rf.resolve(t,e);<span class="cstat-no" title="statement not covered" ></span>return af=(af+1)%cf,o}</span>,Object.defineProperties(rf.prototype,of);v</span>ar sf=<span class="cstat-no" title="statement not covered" >[],</span>af=<span class="cstat-no" title="statement not covered" >0,</span>cf=<span class="cstat-no" title="statement not covered" >12,</span>lf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.$from=t,this.$to=e,this.depth=n}</span>,</span>pf=<span class="cstat-no" title="statement not covered" >{start:{configurable:!0},end:{configurable:!0},parent:{configurable:!0},startIndex:{configurable:!0},endIndex:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>pf.start.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.before(this.depth+1)}</span>,pf.end.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$to.after(this.depth+1)}</span>,pf.parent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.node(this.depth)}</span>,pf.startIndex.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.index(this.depth)}</span>,pf.endIndex.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$to.indexAfter(this.depth)}</span>,Object.defineProperties(lf.prototype,pf);v</span>ar uf=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>hf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.type=t,this.attrs=e,this.content=n||Pd.empty,this.marks=r||$d.none}</span>,</span>df=<span class="cstat-no" title="statement not covered" >{nodeSize:{configurable:!0},childCount:{configurable:!0},textContent:{configurable:!0},firstChild:{configurable:!0},lastChild:{configurable:!0},isBlock:{configurable:!0},isTextblock:{configurable:!0},inlineContent:{configurable:!0},isInline:{configurable:!0},isText:{configurable:!0},isLeaf:{configurable:!0},isAtom:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >ff(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t.length-1;</span>n&gt;=0;n--)<span class="cstat-no" title="statement not covered" >e=t[n].type.name+"("+e+")";<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>df.nodeSize.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isLeaf?1:2+this.content.size}</span>,df.childCount.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.childCount}</span>,hf.prototype.child=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.content.child(t)}</span>,hf.prototype.maybeChild=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.content.maybeChild(t)}</span>,hf.prototype.forEach=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.content.forEach(t)}</span>,hf.prototype.nodesBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=0),this.content.nodesBetween(t,e,n,r,this)}</span>,hf.prototype.descendants=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.nodesBetween(0,this.content.size,t)}</span>,df.textContent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.textBetween(0,this.content.size,"")}</span>,hf.prototype.textBetween=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return this.content.textBetween(t,e,n,r)}</span>,df.firstChild.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.firstChild}</span>,df.lastChild.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.content.lastChild}</span>,hf.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this==t||this.sameMarkup(t)&amp;&amp;this.content.eq(t.content)}</span>,hf.prototype.sameMarkup=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.hasMarkup(t.type,t.attrs,t.marks)}</span>,hf.prototype.hasMarkup=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return this.type==t&amp;&amp;Vd(this.attrs,e||t.defaultAttrs||uf)&amp;&amp;$d.sameSet(this.marks,n||$d.none)}</span>,hf.prototype.copy=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return void 0===t&amp;&amp;(t=null),t==this.content?this:new this.constructor(this.type,this.attrs,t,this.marks)}</span>,hf.prototype.mark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t==this.marks?this:new this.constructor(this.type,this.attrs,this.content,t)}</span>,hf.prototype.cut=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return 0==t&amp;&amp;e==this.content.size?this:this.copy(this.content.cut(t,e))}</span>,hf.prototype.slice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(void 0===e&amp;&amp;(e=this.content.size),void 0===n&amp;&amp;(n=!1),t==e)<span class="cstat-no" title="statement not covered" >return Hd.empty;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.resolve(t),</span>o=<span class="cstat-no" title="statement not covered" >this.resolve(e),</span>i=<span class="cstat-no" title="statement not covered" >n?0:r.sharedDepth(e),</span>s=<span class="cstat-no" title="statement not covered" >r.start(i),</span>a=<span class="cstat-no" title="statement not covered" >r.node(i),</span>c=<span class="cstat-no" title="statement not covered" >a.content.cut(r.pos-s,o.pos-s);<span class="cstat-no" title="statement not covered" ></span>return new Hd(c,r.depth-i,o.depth-i)}</span>,hf.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return Kd(this.resolve(t),this.resolve(e),n)}</span>,hf.prototype.nodeAt=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this;</span>;){var n=<span class="cstat-no" title="statement not covered" >e.content.findIndex(t),</span>r=<span class="cstat-no" title="statement not covered" >n.index,</span>o=<span class="cstat-no" title="statement not covered" >n.offset;<span class="cstat-no" title="statement not covered" ></span>if(e=e.maybeChild(r),!e)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(o==t||e.isText)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >t</span></span>-=o+1}</span>}</span>,hf.prototype.childAfter=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.content.findIndex(t),</span>n=<span class="cstat-no" title="statement not covered" >e.index,</span>r=<span class="cstat-no" title="statement not covered" >e.offset;<span class="cstat-no" title="statement not covered" ></span>return{node:this.content.maybeChild(n),index:n,offset:r}}</span>,hf.prototype.childBefore=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(0==t)<span class="cstat-no" title="statement not covered" >return{node:null,index:0,offset:0};v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.content.findIndex(t),</span>n=<span class="cstat-no" title="statement not covered" >e.index,</span>r=<span class="cstat-no" title="statement not covered" >e.offset;<span class="cstat-no" title="statement not covered" ></span>if(r&lt;t)<span class="cstat-no" title="statement not covered" >return{node:this.content.child(n),index:n,offset:r};v</span></span>ar o=<span class="cstat-no" title="statement not covered" >this.content.child(n-1);<span class="cstat-no" title="statement not covered" ></span>return{node:o,index:n-1,offset:r-o.nodeSize}}</span>,hf.prototype.resolve=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return rf.resolveCached(this,t)}</span>,hf.prototype.resolveNoCache=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return rf.resolve(this,t)}</span>,hf.prototype.rangeHasMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return e&gt;t&amp;&amp;this.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n.isInSet(t.marks)&amp;&amp;(r=!0),!r}</span>)),r}</span>,df.isBlock.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isBlock}</span>,df.isTextblock.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isTextblock}</span>,df.inlineContent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.inlineContent}</span>,df.isInline.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isInline}</span>,df.isText.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isText}</span>,df.isLeaf.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isLeaf}</span>,df.isAtom.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.type.isAtom}</span>,hf.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(this.type.spec.toDebugString)<span class="cstat-no" title="statement not covered" >return this.type.spec.toDebugString(this);v</span></span>ar t=<span class="cstat-no" title="statement not covered" >this.type.name;<span class="cstat-no" title="statement not covered" ></span>return this.content.size&amp;&amp;(t+="("+this.content.toStringInner()+")"),ff(this.marks,t)}</span>,hf.prototype.contentMatchAt=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.type.contentMatch.matchFragment(this.content,0,t);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >throw new Error("Called contentMatchAt on a node with invalid content");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,hf.prototype.canReplace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=Pd.empty),void 0===r&amp;&amp;(r=0),void 0===o&amp;&amp;(o=n.childCount);v</span>ar i=<span class="cstat-no" title="statement not covered" >this.contentMatchAt(t).matchFragment(n,r,o),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.matchFragment(this.content,e);<span class="cstat-no" title="statement not covered" ></span>if(!s||!s.validEnd)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var a=<span class="cstat-no" title="statement not covered" >r;</span>a&lt;o;a++)<span class="cstat-no" title="statement not covered" >if(!this.type.allowsMarks(n.child(a).marks))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,hf.prototype.canReplaceWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >if(r&amp;&amp;!this.type.allowsMarks(r))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >this.contentMatchAt(t).matchType(n),</span>i=<span class="cstat-no" title="statement not covered" >o&amp;&amp;o.matchFragment(this.content,e);<span class="cstat-no" title="statement not covered" ></span>return!!i&amp;&amp;i.validEnd}</span>,hf.prototype.canAppend=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.content.size?this.canReplace(this.childCount,this.childCount,t.content):this.type.compatibleContent(t.type)}</span>,hf.prototype.check=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.type.validContent(this.content))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid content for node "+this.type.name+": "+this.content.toString().slice(0,50));<span class="cstat-no" title="statement not covered" >f</span></span>or(var t=<span class="cstat-no" title="statement not covered" >$d.none,</span>e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.marks.length;e++)<span class="cstat-no" title="statement not covered" >t=this.marks[e].addToSet(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(!$d.sameSet(t,this.marks))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid collection of marks for node "+this.type.name+": "+this.marks.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.type.name}</span>)));<span class="cstat-no" title="statement not covered" >t</span></span>his.content.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.check()}</span>))}</span>,hf.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >{type:this.type.name};<span class="cstat-no" title="statement not covered" ></span>for(var e in this.attrs){<span class="cstat-no" title="statement not covered" >t.attrs=this.attrs;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.content.size&amp;&amp;(t.content=this.content.toJSON()),this.marks.length&amp;&amp;(t.marks=this.marks.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toJSON()}</span>))),t}</span>,hf.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Node.fromJSON");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(e.marks){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(e.marks))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid mark data for Node.fromJSON");<span class="cstat-no" title="statement not covered" >n</span></span>=e.marks.map(t.markFromJSON)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("text"==e.type){<span class="cstat-no" title="statement not covered" >if("string"!=typeof e.text)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid text node in JSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.text(e.text,n)}</span>v</span>ar r=<span class="cstat-no" title="statement not covered" >Pd.fromJSON(t,e.content);<span class="cstat-no" title="statement not covered" ></span>return t.nodeType(e.type).create(e.attrs,r,n)}</span>,Object.defineProperties(hf.prototype,df);v</span>ar mf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.validEnd=t,this.next=[],this.wrapCache=[]}</span>,</span>vf=<span class="cstat-no" title="statement not covered" >{inlineContent:{configurable:!0},defaultType:{configurable:!0},edgeCount:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>mf.parse=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >new gf(t,e);<span class="cstat-no" title="statement not covered" ></span>if(null==n.next)<span class="cstat-no" title="statement not covered" >return mf.empty;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >bf(n);<span class="cstat-no" title="statement not covered" ></span>n.next&amp;&amp;n.err("Unexpected trailing text");v</span>ar o=<span class="cstat-no" title="statement not covered" >Nf(Cf(r));<span class="cstat-no" title="statement not covered" ></span>return jf(o,n),o}</span>,mf.prototype.matchType=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.next.length;e+=2)<span class="cstat-no" title="statement not covered" >if(this.next[e]==t)<span class="cstat-no" title="statement not covered" >return this.next[e+1];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn null}</span>,mf.prototype.matchFragment=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=0),void 0===n&amp;&amp;(n=t.childCount);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >e;</span>r&amp;&amp;o&lt;n;o++)<span class="cstat-no" title="statement not covered" >r=r.matchType(t.child(o).type);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,vf.inlineContent.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.next[0];<span class="cstat-no" title="statement not covered" ></span>return!!t&amp;&amp;t.isInline}</span>,vf.defaultType.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;this.next.length;t+=2){var e=<span class="cstat-no" title="statement not covered" >this.next[t];<span class="cstat-no" title="statement not covered" ></span>if(!e.isText&amp;&amp;!e.hasRequiredAttrs())<span class="cstat-no" title="statement not covered" >return e}</span></span>}</span>,mf.prototype.compatible=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.next.length;e+=2)<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.next.length;n+=2)<span class="cstat-no" title="statement not covered" >if(this.next[e]==t.next[n])<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn!1}</span>,mf.prototype.fillBefore=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=!1),void 0===n&amp;&amp;(n=0);v</span>ar r=<span class="cstat-no" title="statement not covered" >[this];</span>function <span class="fstat-no" title="function not covered" >o(</span>i,s){var a=<span class="cstat-no" title="statement not covered" >i.matchFragment(t,n);<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;(!e||a.validEnd))<span class="cstat-no" title="statement not covered" >return Pd.from(s.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.createAndFill()}</span>)));<span class="cstat-no" title="statement not covered" >f</span></span>or(var c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;i.next.length;c+=2){var l=<span class="cstat-no" title="statement not covered" >i.next[c],</span>p=<span class="cstat-no" title="statement not covered" >i.next[c+1];<span class="cstat-no" title="statement not covered" ></span>if(!l.isText&amp;&amp;!l.hasRequiredAttrs()&amp;&amp;-1==r.indexOf(p)){<span class="cstat-no" title="statement not covered" >r.push(p);v</span>ar u=<span class="cstat-no" title="statement not covered" >o(p,s.concat(l));<span class="cstat-no" title="statement not covered" ></span>if(u)<span class="cstat-no" title="statement not covered" >return u}</span></span>}</span>}<span class="cstat-no" title="statement not covered" ></span>return o(this,[])}</span>,mf.prototype.findWrapping=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.wrapCache.length;e+=2)<span class="cstat-no" title="statement not covered" >if(this.wrapCache[e]==t)<span class="cstat-no" title="statement not covered" >return this.wrapCache[e+1];v</span></span></span>ar n=<span class="cstat-no" title="statement not covered" >this.computeWrapping(t);<span class="cstat-no" title="statement not covered" ></span>return this.wrapCache.push(t,n),n}</span>,mf.prototype.computeWrapping=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>n=<span class="cstat-no" title="statement not covered" >[{match:this,type:null,via:null}];<span class="cstat-no" title="statement not covered" ></span>while(n.length){var r=<span class="cstat-no" title="statement not covered" >n.shift(),</span>o=<span class="cstat-no" title="statement not covered" >r.match;<span class="cstat-no" title="statement not covered" ></span>if(o.matchType(t)){<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >r;</span>s.type;s=s.via)<span class="cstat-no" title="statement not covered" >i.push(s.type);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i.reverse()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.next.length;a+=2){var c=<span class="cstat-no" title="statement not covered" >o.next[a];<span class="cstat-no" title="statement not covered" ></span>c.isLeaf||c.hasRequiredAttrs()||c.name in e||r.type&amp;&amp;!o.next[a+1].validEnd||(n.push({match:c.contentMatch,type:c,via:r}),e[c.name]=!0)}</span>}</span>}</span>,vf.edgeCount.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.next.length&gt;&gt;1}</span>,mf.prototype.edge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t&lt;&lt;1;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;=this.next.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("There's no "+t+"th edge in this content match");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{type:this.next[e],next:this.next[e+1]}}</span>,mf.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >e(</span>n){<span class="cstat-no" title="statement not covered" >t.push(n);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;n.next.length;r+=2)<span class="cstat-no" title="statement not covered" >-1==t.indexOf(n.next[r])&amp;&amp;e(n.next[r])}<span class="cstat-no" title="statement not covered" ></span></span>return e(this),t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >n+(e.validEnd?"*":" ")+" ",</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.next.length;o+=2)<span class="cstat-no" title="statement not covered" >r+=(o?", ":"")+e.next[o].name+"-&gt;"+t.indexOf(e.next[o+1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>)).join("\n")}</span>,Object.defineProperties(mf.prototype,vf),mf.empty=new mf(!0);v</span>ar gf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.string=t,this.nodeTypes=e,this.inline=null,this.pos=0,this.tokens=t.split(/\s*(?=\b|\W|$)/),""==this.tokens[this.tokens.length-1]&amp;&amp;this.tokens.pop(),""==this.tokens[0]&amp;&amp;this.tokens.shift()}</span>,</span>yf=<span class="cstat-no" title="statement not covered" >{next:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >bf(</span>t){var e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >e.push(wf(t))}</span>while(t.eat("|"));<span class="cstat-no" title="statement not covered" >r</span>eturn 1==e.length?e[0]:{type:"choice",exprs:e}}</span>function <span class="fstat-no" title="function not covered" >wf(</span>t){var e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >e.push(Of(t))}</span>while(t.next&amp;&amp;")"!=t.next&amp;&amp;"|"!=t.next);<span class="cstat-no" title="statement not covered" >r</span>eturn 1==e.length?e[0]:{type:"seq",exprs:e}}</span>function <span class="fstat-no" title="function not covered" >Of(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >Mf(t);</span>;)<span class="cstat-no" title="statement not covered" >if(t.eat("+"))<span class="cstat-no" title="statement not covered" >e={type:"plus",expr:e};e</span>lse <span class="cstat-no" title="statement not covered" >if(t.eat("*"))<span class="cstat-no" title="statement not covered" >e={type:"star",expr:e};e</span>lse <span class="cstat-no" title="statement not covered" >if(t.eat("?"))<span class="cstat-no" title="statement not covered" >e={type:"opt",expr:e};e</span>lse{<span class="cstat-no" title="statement not covered" >if(!t.eat("{"))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >e</span></span>=xf(t,e)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >kf(</span>t){<span class="cstat-no" title="statement not covered" >/\D/.test(t.next)&amp;&amp;t.err("Expected number, got '"+t.next+"'");v</span>ar e=<span class="cstat-no" title="statement not covered" >Number(t.next);<span class="cstat-no" title="statement not covered" ></span>return t.pos++,e}</span>function <span class="fstat-no" title="function not covered" >xf(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >kf(t),</span>r=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>return t.eat(",")&amp;&amp;(r="}"!=t.next?kf(t):-1),t.eat("}")||t.err("Unclosed braced range"),{type:"range",min:n,max:r,expr:e}}</span>function <span class="fstat-no" title="function not covered" >Sf(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >t.nodeTypes,</span>r=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return[r];v</span></span>ar o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(var i in n){var s=<span class="cstat-no" title="statement not covered" >n[i];<span class="cstat-no" title="statement not covered" ></span>s.groups.indexOf(e)&gt;-1&amp;&amp;o.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0==o.length&amp;&amp;t.err("No node type or group '"+e+"' found"),o}</span>function <span class="fstat-no" title="function not covered" >Mf(</span>t){<span class="cstat-no" title="statement not covered" >if(t.eat("(")){var e=<span class="cstat-no" title="statement not covered" >bf(t);<span class="cstat-no" title="statement not covered" ></span>return t.eat(")")||t.err("Missing closing paren"),e}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!/\W/.test(t.next)){var n=<span class="cstat-no" title="statement not covered" >Sf(t,t.next).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null==t.inline?t.inline=e.isInline:t.inline!=e.isInline&amp;&amp;t.err("Mixing inline and block content"),{type:"name",value:e}}</span>));<span class="cstat-no" title="statement not covered" ></span>return t.pos++,1==n.length?n[0]:{type:"choice",exprs:n}}<span class="cstat-no" title="statement not covered" ></span>t</span>.err("Unexpected token '"+t.next+"'")}</span>function <span class="fstat-no" title="function not covered" >Cf(</span>t){var e=<span class="cstat-no" title="statement not covered" >[[]];<span class="cstat-no" title="statement not covered" ></span>return o(i(t,0),n()),e;f</span>unction <span class="fstat-no" title="function not covered" >n(</span>){<span class="cstat-no" title="statement not covered" >return e.push([])-1}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,n,r){var o=<span class="cstat-no" title="statement not covered" >{term:r,to:n};<span class="cstat-no" title="statement not covered" ></span>return e[t].push(o),o}</span>function <span class="fstat-no" title="function not covered" >o(</span>t,e){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.to=e}</span>))}</span>function <span class="fstat-no" title="function not covered" >i(</span>t,e){<span class="cstat-no" title="statement not covered" >if("choice"==t.type)<span class="cstat-no" title="statement not covered" >return t.exprs.reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t.concat(i(n,e))}</span>),[]);<span class="cstat-no" title="statement not covered" >i</span></span>f("seq"==t.type)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>;s++){var a=<span class="cstat-no" title="statement not covered" >i(t.exprs[s],e);<span class="cstat-no" title="statement not covered" ></span>if(s==t.exprs.length-1)<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >o</span></span>(a,e=n())}</span>e</span>lse{<span class="cstat-no" title="statement not covered" >if("star"==t.type){var c=<span class="cstat-no" title="statement not covered" >n();<span class="cstat-no" title="statement not covered" ></span>return r(e,c),o(i(t.expr,c),c),[r(c)]}<span class="cstat-no" title="statement not covered" ></span>i</span>f("plus"==t.type){var l=<span class="cstat-no" title="statement not covered" >n();<span class="cstat-no" title="statement not covered" ></span>return o(i(t.expr,e),l),o(i(t.expr,l),l),[r(l)]}<span class="cstat-no" title="statement not covered" ></span>i</span>f("opt"==t.type)<span class="cstat-no" title="statement not covered" >return[r(e)].concat(i(t.expr,e));<span class="cstat-no" title="statement not covered" >i</span></span>f("range"==t.type){<span class="cstat-no" title="statement not covered" >for(var p=<span class="cstat-no" title="statement not covered" >e,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;t.min;u++){var h=<span class="cstat-no" title="statement not covered" >n();<span class="cstat-no" title="statement not covered" ></span>o(i(t.expr,p),h),p=h}<span class="cstat-no" title="statement not covered" ></span>i</span>f(-1==t.max)<span class="cstat-no" title="statement not covered" >o(i(t.expr,p),p);e</span>lse <span class="cstat-no" title="statement not covered" >for(var d=<span class="cstat-no" title="statement not covered" >t.min;</span>d&lt;t.max;d++){var f=<span class="cstat-no" title="statement not covered" >n();<span class="cstat-no" title="statement not covered" ></span>r(p,f),o(i(t.expr,p),f),p=f}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn[r(p)]}<span class="cstat-no" title="statement not covered" ></span>i</span>f("name"==t.type)<span class="cstat-no" title="statement not covered" >return[r(e,null,t.value)]}</span></span>}</span>}function <span class="fstat-no" title="function not covered" >Ef(</span>t,e){<span class="cstat-no" title="statement not covered" >return e-t}</span>function <span class="fstat-no" title="function not covered" >Tf(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return r(e),n.sort(Ef);f</span>unction <span class="fstat-no" title="function not covered" >r(</span>e){var o=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>if(1==o.length&amp;&amp;!o[0].term)<span class="cstat-no" title="statement not covered" >return r(o[0].to);<span class="cstat-no" title="statement not covered" >n</span></span>.push(e);<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;o.length;i++){var s=<span class="cstat-no" title="statement not covered" >o[i],</span>a=<span class="cstat-no" title="statement not covered" >s.term,</span>c=<span class="cstat-no" title="statement not covered" >s.to;<span class="cstat-no" title="statement not covered" ></span>a||-1!=n.indexOf(c)||r(c)}</span>}</span>}function <span class="fstat-no" title="function not covered" >Nf(</span>t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>return n(Tf(t,0));f</span>unction <span class="fstat-no" title="function not covered" >n(</span>r){var o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t[e].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.term,</span>r=<span class="cstat-no" title="statement not covered" >e.to;<span class="cstat-no" title="statement not covered" ></span>if(n){var i=<span class="cstat-no" title="statement not covered" >o.indexOf(n),</span>s=<span class="cstat-no" title="statement not covered" >i&gt;-1&amp;&amp;o[i+1];<span class="cstat-no" title="statement not covered" ></span>Tf(t,r).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >s||o.push(n,s=[]),-1==s.indexOf(t)&amp;&amp;s.push(t)}</span>))}</span>}</span>))}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >e[r.join(",")]=new mf(r.indexOf(t.length-1)&gt;-1),</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;o.length;s+=2){var a=<span class="cstat-no" title="statement not covered" >o[s+1].sort(Ef);<span class="cstat-no" title="statement not covered" ></span>i.next.push(o[s],e[a.join(",")]||n(a))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>}function <span class="fstat-no" title="function not covered" >jf(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >[t];</span>n&lt;r.length;n++){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >r[n],</span>i=<span class="cstat-no" title="statement not covered" >!o.validEnd,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;o.next.length;a+=2){var c=<span class="cstat-no" title="statement not covered" >o.next[a],</span>l=<span class="cstat-no" title="statement not covered" >o.next[a+1];<span class="cstat-no" title="statement not covered" ></span>s.push(c.name),!i||c.isText||c.hasRequiredAttrs()||(i=!1),-1==r.indexOf(l)&amp;&amp;r.push(l)}<span class="cstat-no" title="statement not covered" ></span>i</span>&amp;&amp;e.err("Only non-generatable nodes ("+s.join(", ")+") in a required position (see https://prosemirror.net/docs/guide/#generatable)")}</span>}</span>function <span class="fstat-no" title="function not covered" >Af(</span>t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>for(var n in t){var r=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>if(!r.hasDefault)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >e</span></span>[n]=r.default}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >If(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>for(var r in t){var o=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e[r];<span class="cstat-no" title="statement not covered" ></span>if(void 0===o){var i=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>if(!i.hasDefault)<span class="cstat-no" title="statement not covered" >throw new RangeError("No value supplied for attribute "+r);<span class="cstat-no" title="statement not covered" >o</span></span>=i.default}<span class="cstat-no" title="statement not covered" ></span>n</span>[r]=o}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >Df(</span>t){var e=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >e[n]=new Pf(t[n]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>yf.next.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.tokens[this.pos]}</span>,gf.prototype.eat=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.next==t&amp;&amp;(this.pos++||!0)}</span>,gf.prototype.err=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >throw new SyntaxError(t+" (in content expression '"+this.string+"')")}</span>,Object.defineProperties(gf.prototype,yf);v</span>ar Rf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.name=t,this.schema=e,this.spec=n,this.groups=n.group?n.group.split(" "):[],this.attrs=Df(n.attrs),this.defaultAttrs=Af(this.attrs),this.contentMatch=null,this.markSet=null,this.inlineContent=null,this.isBlock=!(n.inline||"text"==t),this.isText="text"==t}</span>,</span>_f=<span class="cstat-no" title="statement not covered" >{isInline:{configurable:!0},isTextblock:{configurable:!0},isLeaf:{configurable:!0},isAtom:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>_f.isInline.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!this.isBlock}</span>,_f.isTextblock.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isBlock&amp;&amp;this.inlineContent}</span>,_f.isLeaf.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.contentMatch==mf.empty}</span>,_f.isAtom.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.isLeaf||this.spec.atom}</span>,Rf.prototype.hasRequiredAttrs=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in this.attrs)<span class="cstat-no" title="statement not covered" >if(this.attrs[t].isRequired)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>,Rf.prototype.compatibleContent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this==t||this.contentMatch.compatible(t.contentMatch)}</span>,Rf.prototype.computeAttrs=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!t&amp;&amp;this.defaultAttrs?this.defaultAttrs:If(this.attrs,t)}</span>,Rf.prototype.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(this.isText)<span class="cstat-no" title="statement not covered" >throw new Error("NodeType.create can't construct text nodes");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new hf(this,this.computeAttrs(t),Pd.from(e),$d.setFrom(n))}</span>,Rf.prototype.createChecked=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(e=Pd.from(e),!this.validContent(e))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid content for node "+this.name);<span class="cstat-no" title="statement not covered" >r</span></span>eturn new hf(this,this.computeAttrs(t),e,$d.setFrom(n))}</span>,Rf.prototype.createAndFill=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(t=this.computeAttrs(t),e=Pd.from(e),e.size){var r=<span class="cstat-no" title="statement not covered" >this.contentMatch.fillBefore(e);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >e</span></span>=r.append(e)}</span>v</span>ar o=<span class="cstat-no" title="statement not covered" >this.contentMatch.matchFragment(e).fillBefore(Pd.empty,!0);<span class="cstat-no" title="statement not covered" ></span>return o?new hf(this,t,e.append(o),$d.setFrom(n)):null}</span>,Rf.prototype.validContent=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.contentMatch.matchFragment(t);<span class="cstat-no" title="statement not covered" ></span>if(!e||!e.validEnd)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.childCount;n++)<span class="cstat-no" title="statement not covered" >if(!this.allowsMarks(t.child(n).marks))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,Rf.prototype.allowsMarkType=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null==this.markSet||this.markSet.indexOf(t)&gt;-1}</span>,Rf.prototype.allowsMarks=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(null==this.markSet)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(!this.allowsMarkType(t[e].type))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,Rf.prototype.allowedMarks=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(null==this.markSet)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(var e,n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >this.allowsMarkType(t[n].type)?e&amp;&amp;e.push(t[n]):e||(e=t.slice(0,n));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e?e.length?e:$d.empty:t}</span>,Rf.compile=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >return n[t]=new Rf(t,e,r)}</span>));v</span>ar r=<span class="cstat-no" title="statement not covered" >e.spec.topNode||"doc";<span class="cstat-no" title="statement not covered" ></span>if(!n[r])<span class="cstat-no" title="statement not covered" >throw new RangeError("Schema is missing its top node type ('"+r+"')");<span class="cstat-no" title="statement not covered" >i</span></span>f(!n.text)<span class="cstat-no" title="statement not covered" >throw new RangeError("Every schema needs a 'text' type");<span class="cstat-no" title="statement not covered" >f</span></span>or(var o in n.text.attrs)<span class="cstat-no" title="statement not covered" >throw new RangeError("The text node type should not have attributes");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,Object.defineProperties(Rf.prototype,_f);v</span>ar Pf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.hasDefault=Object.prototype.hasOwnProperty.call(t,"default"),this.default=t.default}</span>,</span>zf=<span class="cstat-no" title="statement not covered" >{isRequired:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>zf.isRequired.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!this.hasDefault}</span>,Object.defineProperties(Pf.prototype,zf);v</span>ar Bf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.name=t,this.schema=n,this.spec=r,this.attrs=Df(r.attrs),this.rank=e,this.excluded=null;v</span>ar o=<span class="cstat-no" title="statement not covered" >Af(this.attrs);<span class="cstat-no" title="statement not covered" ></span>this.instance=o&amp;&amp;new $d(this,o)}</span>;<span class="cstat-no" title="statement not covered" ></span>Bf.prototype.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!t&amp;&amp;this.instance?this.instance:new $d(this,If(this.attrs,t))}</span>,Bf.compile=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,o){<span class="cstat-no" title="statement not covered" >return n[t]=new Bf(t,r++,e,o)}</span>)),n}</span>,Bf.prototype.removeFromSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >t[e].type==this&amp;&amp;(t=t.slice(0,e).concat(t.slice(e+1)),e--);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,Bf.prototype.isInSet=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(t[e].type==this)<span class="cstat-no" title="statement not covered" >return t[e]}</span></span></span>,Bf.prototype.excludes=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.excluded.indexOf(t)&gt;-1}</span>;v</span>ar Lf=<span class="cstat-no" title="statement not covered" >{address:!0,article:!0,aside:!0,blockquote:!0,canvas:!0,dd:!0,div:!0,dl:!0,fieldset:!0,figcaption:!0,figure:!0,footer:!0,form:!0,h1:!0,h2:!0,h3:!0,h4:!0,h5:!0,h6:!0,header:!0,hgroup:!0,hr:!0,li:!0,noscript:!0,ol:!0,output:!0,p:!0,pre:!0,section:!0,table:!0,tfoot:!0,ul:!0},</span>Vf=<span class="cstat-no" title="statement not covered" >{head:!0,noscript:!0,object:!0,script:!0,style:!0,title:!0},</span>$f=<span class="cstat-no" title="statement not covered" >{ol:!0,ul:!0},</span>Ff=<span class="cstat-no" title="statement not covered" >1,</span>Hf=<span class="cstat-no" title="statement not covered" >2,</span>qf=<span class="cstat-no" title="statement not covered" >4;</span>function <span class="fstat-no" title="function not covered" >Jf(</span>t){<span class="cstat-no" title="statement not covered" >return(t?Ff:0)|("full"===t?Hf:0)}</span>var Wf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r,o,i,s){<span class="cstat-no" title="statement not covered" >this.type=t,this.attrs=e,this.solid=o,this.match=i||(s&amp;qf?null:t.contentMatch),this.options=s,this.content=[],this.marks=n,this.activeMarks=$d.none,this.pendingMarks=r,this.stashMarks=[]}</span>;<span class="cstat-no" title="statement not covered" ></span>Wf.prototype.findWrapping=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!this.match){<span class="cstat-no" title="statement not covered" >if(!this.type)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.type.contentMatch.fillBefore(Pd.from(t));<span class="cstat-no" title="statement not covered" ></span>if(!e){var n,r=<span class="cstat-no" title="statement not covered" >this.type.contentMatch;<span class="cstat-no" title="statement not covered" ></span>return(n=r.findWrapping(t.type))?(this.match=r,n):null}<span class="cstat-no" title="statement not covered" ></span>t</span>his.match=this.type.contentMatch.matchFragment(e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.match.findWrapping(t.type)}</span>,Wf.prototype.finish=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!(this.options&amp;Ff)){var e,n=<span class="cstat-no" title="statement not covered" >this.content[this.content.length-1];<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.isText&amp;&amp;(e=/[ \t\r\n\u000c]+$/.exec(n.text))&amp;&amp;(n.text.length==e[0].length?this.content.pop():this.content[this.content.length-1]=n.withText(n.text.slice(0,n.text.length-e[0].length)))}</span>v</span>ar r=<span class="cstat-no" title="statement not covered" >Pd.from(this.content);<span class="cstat-no" title="statement not covered" ></span>return!t&amp;&amp;this.match&amp;&amp;(r=r.append(this.match.fillBefore(Pd.empty,!0))),this.type?this.type.create(this.attrs,r,this.marks):r}</span>,Wf.prototype.popFromStashMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.stashMarks.length-1;</span>e&gt;=0;e--)<span class="cstat-no" title="statement not covered" >if(t.eq(this.stashMarks[e]))<span class="cstat-no" title="statement not covered" >return this.stashMarks.splice(e,1)[0]}</span></span></span>,Wf.prototype.applyPending=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >this.pendingMarks;</span>e&lt;n.length;e++){var r=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>(this.type?this.type.allowsMarkType(r.type):Xf(r.type,t))&amp;&amp;!r.isInSet(this.activeMarks)&amp;&amp;(this.activeMarks=r.addToSet(this.activeMarks),this.pendingMarks=r.removeFromSet(this.pendingMarks))}</span>}</span>,Wf.prototype.inlineContext=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.type?this.type.inlineContent:this.content.length?this.content[0].isInline:t.parentNode&amp;&amp;!Lf.hasOwnProperty(t.parentNode.nodeName.toLowerCase())}</span>;v</span>ar Kf=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.parser=t,this.options=e,this.isOpen=n;v</span>ar r,o=<span class="cstat-no" title="statement not covered" >e.topNode,</span>i=<span class="cstat-no" title="statement not covered" >Jf(e.preserveWhitespace)|(n?qf:0);<span class="cstat-no" title="statement not covered" ></span>r=o?new Wf(o.type,o.attrs,$d.none,$d.none,!0,e.topMatch||o.type.contentMatch,i):new Wf(n?null:t.schema.topNodeType,null,$d.none,$d.none,!0,null,i),this.nodes=[r],this.open=0,this.find=e.findPositions,this.needsBlock=!1}</span>,</span>Uf=<span class="cstat-no" title="statement not covered" >{top:{configurable:!0},currentPos:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >Gf(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.firstChild,</span>n=<span class="cstat-no" title="statement not covered" >null;</span>e;e=e.nextSibling){var r=<span class="cstat-no" title="statement not covered" >1==e.nodeType?e.nodeName.toLowerCase():null;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;$f.hasOwnProperty(r)&amp;&amp;n?(n.appendChild(e),e=n):"li"==r?n=e:r&amp;&amp;(n=null)}</span>}</span>function <span class="fstat-no" title="function not covered" >Yf(</span>t){var e,n=<span class="cstat-no" title="statement not covered" >/\s*([\w-]+)\s*:\s*([^;]+)/g,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>while(e=n.exec(t))<span class="cstat-no" title="statement not covered" >r.push(e[1],e[2].trim());<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Xf(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >e.schema.nodes,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(r){var o=<span class="cstat-no" title="statement not covered" >n[r];<span class="cstat-no" title="statement not covered" ></span>if(o.allowsMarkType(t)){var i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >i.push(t);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.edgeCount;n++){var r=<span class="cstat-no" title="statement not covered" >t.edge(n),</span>o=<span class="cstat-no" title="statement not covered" >r.type,</span>a=<span class="cstat-no" title="statement not covered" >r.next;<span class="cstat-no" title="statement not covered" ></span>if(o==e)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(i.indexOf(a)&lt;0&amp;&amp;s(a))<span class="cstat-no" title="statement not covered" >return!0}</span></span>}</span>;<span class="cstat-no" title="statement not covered" ></span>return s(o.contentMatch)?{v:!0}:void 0}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>for(var o in n){var i=<span class="cstat-no" title="statement not covered" >r(o);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i.v}</span></span>}</span>function <span class="fstat-no" title="function not covered" >Qf(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >if(t.eq(e[n]))<span class="cstat-no" title="statement not covered" >return e[n]}<span class="cstat-no" title="statement not covered" ></span></span></span>Uf.top.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.nodes[this.open]}</span>,Kf.prototype.addDOM=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(3==t.nodeType)<span class="cstat-no" title="statement not covered" >this.addTextNode(t);e</span>lse <span class="cstat-no" title="statement not covered" >if(1==t.nodeType){var e=<span class="cstat-no" title="statement not covered" >t.getAttribute("style"),</span>n=<span class="cstat-no" title="statement not covered" >e?this.readStyles(Yf(e)):null,</span>r=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>if(null!=n)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n.length;o++)<span class="cstat-no" title="statement not covered" >this.addPendingMark(n[o]);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(this.addElement(t),null!=n)<span class="cstat-no" title="statement not covered" >for(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;n.length;i++)<span class="cstat-no" title="statement not covered" >this.removePendingMark(n[i],r)}</span></span></span>}</span></span>,Kf.prototype.addTextNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.nodeValue,</span>n=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>if(n.options&amp;Hf||n.inlineContext(t)||/[^ \t\r\n\u000c]/.test(e)){<span class="cstat-no" title="statement not covered" >if(n.options&amp;Ff)<span class="cstat-no" title="statement not covered" >e=n.options&amp;Hf?e.replace(/\r\n?/g,"\n"):e.replace(/\r?\n|\r/g," ");e</span>lse <span class="cstat-no" title="statement not covered" >if(e=e.replace(/[ \t\r\n\u000c]+/g," "),/^[ \t\r\n\u000c]/.test(e)&amp;&amp;this.open==this.nodes.length-1){var r=<span class="cstat-no" title="statement not covered" >n.content[n.content.length-1],</span>o=<span class="cstat-no" title="statement not covered" >t.previousSibling;<span class="cstat-no" title="statement not covered" ></span>(!r||o&amp;&amp;"BR"==o.nodeName||r.isText&amp;&amp;/[ \t\r\n\u000c]$/.test(r.text))&amp;&amp;(e=e.slice(1))}<span class="cstat-no" title="statement not covered" ></span>e</span></span>&amp;&amp;this.insertNode(this.parser.schema.text(e)),this.findInText(t)}</span>else <span class="cstat-no" title="statement not covered" >this.findInside(t)}</span></span>,Kf.prototype.addElement=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n,r=<span class="cstat-no" title="statement not covered" >t.nodeName.toLowerCase();<span class="cstat-no" title="statement not covered" ></span>$f.hasOwnProperty(r)&amp;&amp;this.parser.normalizeLists&amp;&amp;Gf(t);v</span>ar o=<span class="cstat-no" title="statement not covered" >this.options.ruleFromNode&amp;&amp;this.options.ruleFromNode(t)||(n=this.parser.matchTag(t,this,e));<span class="cstat-no" title="statement not covered" ></span>if(o?o.ignore:Vf.hasOwnProperty(r))<span class="cstat-no" title="statement not covered" >this.findInside(t),this.ignoreFallback(t);e</span>lse <span class="cstat-no" title="statement not covered" >if(!o||o.skip||o.closeParent){<span class="cstat-no" title="statement not covered" >o&amp;&amp;o.closeParent?this.open=Math.max(0,this.open-1):o&amp;&amp;o.skip.nodeType&amp;&amp;(t=o.skip);v</span>ar i,s=<span class="cstat-no" title="statement not covered" >this.top,</span>a=<span class="cstat-no" title="statement not covered" >this.needsBlock;<span class="cstat-no" title="statement not covered" ></span>if(Lf.hasOwnProperty(r))<span class="cstat-no" title="statement not covered" >i=!0,s.type||(this.needsBlock=!0);e</span>lse <span class="cstat-no" title="statement not covered" >if(!t.firstChild)<span class="cstat-no" title="statement not covered" >return void this.leafFallback(t);<span class="cstat-no" title="statement not covered" >t</span></span></span>his.addAll(t),i&amp;&amp;this.sync(s),this.needsBlock=a}</span>else <span class="cstat-no" title="statement not covered" >this.addElementByRule(t,o,!1===o.consuming?n:null)}</span></span></span>,Kf.prototype.leafFallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"BR"==t.nodeName&amp;&amp;this.top.type&amp;&amp;this.top.type.inlineContent&amp;&amp;this.addTextNode(t.ownerDocument.createTextNode("\n"))}</span>,Kf.prototype.ignoreFallback=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >"BR"!=t.nodeName||this.top.type&amp;&amp;this.top.type.inlineContent||this.findPlace(this.parser.schema.text("-"))}</span>,Kf.prototype.readStyles=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >$d.none;<span class="cstat-no" title="statement not covered" ></span>t:<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;t.length;n+=2)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >null;</span>;){var o=<span class="cstat-no" title="statement not covered" >this.parser.matchStyle(t[n],t[n+1],this,r);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >continue t;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.ignore)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(e=this.parser.schema.marks[o.mark].create(o.attrs).addToSet(e),!1!==o.consuming)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span>=o}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn e}</span>,Kf.prototype.addElementByRule=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r,o,i,s,a=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e.node?(o=this.parser.schema.nodes[e.node],o.isLeaf?this.insertNode(o.create(e.attrs))||this.leafFallback(t):r=this.enter(o,e.attrs,e.preserveWhitespace)):(i=this.parser.schema.marks[e.mark],s=i.create(e.attrs),this.addPendingMark(s));v</span>ar c=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;o.isLeaf)<span class="cstat-no" title="statement not covered" >this.findInside(t);e</span>lse <span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >this.addElement(t,n);e</span>lse <span class="cstat-no" title="statement not covered" >if(e.getContent)<span class="cstat-no" title="statement not covered" >this.findInside(t),e.getContent(t,this.parser.schema).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return a.insertNode(t)}</span>));e</span>lse{var l=<span class="cstat-no" title="statement not covered" >e.contentElement;<span class="cstat-no" title="statement not covered" ></span>"string"==typeof l?l=t.querySelector(l):"function"==typeof l&amp;&amp;(l=l(t)),l||(l=t),this.findAround(t,l,!0),this.addAll(l,r)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>&amp;&amp;(this.sync(c),this.open--),s&amp;&amp;this.removePendingMark(s,c)}</span>,Kf.prototype.addAll=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >n||0,</span>i=<span class="cstat-no" title="statement not covered" >n?t.childNodes[n]:t.firstChild,</span>s=<span class="cstat-no" title="statement not covered" >null==r?null:t.childNodes[r];</span>i!=s;i=i.nextSibling,++o)<span class="cstat-no" title="statement not covered" >this.findAtPoint(t,o),this.addDOM(i),e&amp;&amp;Lf.hasOwnProperty(i.nodeName.toLowerCase())&amp;&amp;this.sync(e);<span class="cstat-no" title="statement not covered" >t</span></span>his.findAtPoint(t,o)}</span>,Kf.prototype.findPlace=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e,n,r=<span class="cstat-no" title="statement not covered" >this.open;</span>r&gt;=0;r--){var o=<span class="cstat-no" title="statement not covered" >this.nodes[r],</span>i=<span class="cstat-no" title="statement not covered" >o.findWrapping(t);<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;(!e||e.length&gt;i.length)&amp;&amp;(e=i,n=o,!i.length))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.solid)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(!e)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>his.sync(n);<span class="cstat-no" title="statement not covered" >f</span>or(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;e.length;s++)<span class="cstat-no" title="statement not covered" >this.enterInner(e[s],null,!1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn!0}</span>,Kf.prototype.insertNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t.isInline&amp;&amp;this.needsBlock&amp;&amp;!this.top.type){var e=<span class="cstat-no" title="statement not covered" >this.textblockFromContext();<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;this.enterInner(e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.findPlace(t)){<span class="cstat-no" title="statement not covered" >this.closeExtra();v</span>ar n=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>n.applyPending(t.type),n.match&amp;&amp;(n.match=n.match.matchType(t.type));<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >n.activeMarks,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t.marks.length;o++)<span class="cstat-no" title="statement not covered" >n.type&amp;&amp;!n.type.allowsMarkType(t.marks[o].type)||(r=t.marks[o].addToSet(r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.content.push(t.mark(r)),!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>,Kf.prototype.enter=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this.findPlace(t.create(e));<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;this.enterInner(t,e,!0,n),r}</span>,Kf.prototype.enterInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.closeExtra();v</span>ar o=<span class="cstat-no" title="statement not covered" >this.top;<span class="cstat-no" title="statement not covered" ></span>o.applyPending(t),o.match=o.match&amp;&amp;o.match.matchType(t,e);v</span>ar i=<span class="cstat-no" title="statement not covered" >null==r?o.options&amp;~qf:Jf(r);<span class="cstat-no" title="statement not covered" ></span>o.options&amp;qf&amp;&amp;0==o.content.length&amp;&amp;(i|=qf),this.nodes.push(new Wf(t,e,o.activeMarks,o.pendingMarks,n,null,i)),this.open++}</span>,Kf.prototype.closeExtra=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.nodes.length-1;<span class="cstat-no" title="statement not covered" ></span>if(e&gt;this.open){<span class="cstat-no" title="statement not covered" >for(;e&gt;this.open;e--)<span class="cstat-no" title="statement not covered" >this.nodes[e-1].content.push(this.nodes[e].finish(t));<span class="cstat-no" title="statement not covered" >t</span></span>his.nodes.length=this.open+1}</span>}</span>,Kf.prototype.finish=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.open=0,this.closeExtra(this.isOpen),this.nodes[0].finish(this.isOpen||this.options.topOpen)}</span>,Kf.prototype.sync=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.open;</span>e&gt;=0;e--)<span class="cstat-no" title="statement not covered" >if(this.nodes[e]==t)<span class="cstat-no" title="statement not covered" >return void(this.open=e)}</span></span></span>,Uf.currentPos.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.closeExtra();<span class="cstat-no" title="statement not covered" >f</span>or(var t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >this.open;</span>e&gt;=0;e--){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >this.nodes[e].content,</span>r=<span class="cstat-no" title="statement not covered" >n.length-1;</span>r&gt;=0;r--)<span class="cstat-no" title="statement not covered" >t+=n[r].nodeSize;<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;t++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,Kf.prototype.findAtPoint=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(this.find)<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.find.length;n++)<span class="cstat-no" title="statement not covered" >this.find[n].node==t&amp;&amp;this.find[n].offset==e&amp;&amp;(this.find[n].pos=this.currentPos)}</span></span></span>,Kf.prototype.findInside=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.find)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.find.length;e++)<span class="cstat-no" title="statement not covered" >null==this.find[e].pos&amp;&amp;1==t.nodeType&amp;&amp;t.contains(this.find[e].node)&amp;&amp;(this.find[e].pos=this.currentPos)}</span></span></span>,Kf.prototype.findAround=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(t!=e&amp;&amp;this.find)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.find.length;r++)<span class="cstat-no" title="statement not covered" >if(null==this.find[r].pos&amp;&amp;1==t.nodeType&amp;&amp;t.contains(this.find[r].node)){var o=<span class="cstat-no" title="statement not covered" >e.compareDocumentPosition(this.find[r].node);<span class="cstat-no" title="statement not covered" ></span>o&amp;(n?2:4)&amp;&amp;(this.find[r].pos=this.currentPos)}</span>}</span></span></span>,Kf.prototype.findInText=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.find)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.find.length;e++)<span class="cstat-no" title="statement not covered" >this.find[e].node==t&amp;&amp;(this.find[e].pos=this.currentPos-(t.nodeValue.length-this.find[e].offset))}</span></span></span>,Kf.prototype.matchesContext=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(t.indexOf("|")&gt;-1)<span class="cstat-no" title="statement not covered" >return t.split(/\s*\|\s*/).some(this.matchesContext,this);v</span></span>ar n=<span class="cstat-no" title="statement not covered" >t.split("/"),</span>r=<span class="cstat-no" title="statement not covered" >this.options.context,</span>o=<span class="cstat-no" title="statement not covered" >!this.isOpen&amp;&amp;(!r||r.parent.type==this.nodes[0].type),</span>i=<span class="cstat-no" title="statement not covered" >-(r?r.depth+1:0)+(o?0:1),</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,a){<span class="cstat-no" title="statement not covered" >for(;t&gt;=0;t--){var c=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>if(""==c){<span class="cstat-no" title="statement not covered" >if(t==n.length-1||0==t)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >f</span></span>or(;a&gt;=i;a--)<span class="cstat-no" title="statement not covered" >if(s(t-1,a))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>v</span>ar l=<span class="cstat-no" title="statement not covered" >a&gt;0||0==a&amp;&amp;o?e.nodes[a].type:r&amp;&amp;a&gt;=i?r.node(a-i).type:null;<span class="cstat-no" title="statement not covered" ></span>if(!l||l.name!=c&amp;&amp;-1==l.groups.indexOf(c))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >a</span></span>--}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>;<span class="cstat-no" title="statement not covered" ></span>return s(n.length-1,this.open)}</span>,Kf.prototype.textblockFromContext=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.options.context;<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.depth;</span>e&gt;=0;e--){var n=<span class="cstat-no" title="statement not covered" >t.node(e).contentMatchAt(t.indexAfter(e)).defaultType;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;n.isTextblock&amp;&amp;n.defaultAttrs)<span class="cstat-no" title="statement not covered" >return n}<span class="cstat-no" title="statement not covered" ></span></span>f</span></span>or(var r in this.parser.schema.nodes){var o=<span class="cstat-no" title="statement not covered" >this.parser.schema.nodes[r];<span class="cstat-no" title="statement not covered" ></span>if(o.isTextblock&amp;&amp;o.defaultAttrs)<span class="cstat-no" title="statement not covered" >return o}</span></span>}</span>,Kf.prototype.addPendingMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Qf(t,this.top.pendingMarks);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;this.top.stashMarks.push(e),this.top.pendingMarks=t.addToSet(this.top.pendingMarks)}</span>,Kf.prototype.removePendingMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >this.open;</span>n&gt;=0;n--){var r=<span class="cstat-no" title="statement not covered" >this.nodes[n],</span>o=<span class="cstat-no" title="statement not covered" >r.pendingMarks.lastIndexOf(t);<span class="cstat-no" title="statement not covered" ></span>if(o&gt;-1)<span class="cstat-no" title="statement not covered" >r.pendingMarks=t.removeFromSet(r.pendingMarks);e</span>lse{<span class="cstat-no" title="statement not covered" >r.activeMarks=t.removeFromSet(r.activeMarks);v</span>ar i=<span class="cstat-no" title="statement not covered" >r.popFromStashMark(t);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;r.type&amp;&amp;r.type.allowsMarkType(i.type)&amp;&amp;(r.activeMarks=i.addToSet(r.activeMarks))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r==e)<span class="cstat-no" title="statement not covered" >break}</span></span>}</span>,Object.defineProperties(Kf.prototype,Uf);v</span>ar Zf=<span class="cstat-no" title="statement not covered" >65535,</span>tm=<span class="cstat-no" title="statement not covered" >Math.pow(2,16);</span>function <span class="fstat-no" title="function not covered" >em(</span>t,e){<span class="cstat-no" title="statement not covered" >return t+e*tm}</span>function <span class="fstat-no" title="function not covered" >nm(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;Zf}</span>function <span class="fstat-no" title="function not covered" >rm(</span>t){<span class="cstat-no" title="statement not covered" >return(t-(t&amp;Zf))/tm}</span>var om=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=!1),void 0===n&amp;&amp;(n=null),this.pos=t,this.deleted=e,this.recover=n}</span>,</span>im=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=!1),this.ranges=t,this.inverted=e}</span>;<span class="cstat-no" title="statement not covered" ></span>im.prototype.recover=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >nm(t);<span class="cstat-no" title="statement not covered" ></span>if(!this.inverted)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;n;r++)<span class="cstat-no" title="statement not covered" >e+=this.ranges[3*r+2]-this.ranges[3*r+1];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this.ranges[3*n]+e+rm(t)}</span>,im.prototype.mapResult=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=1),this._map(t,e,!1)}</span>,im.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=1),this._map(t,e,!0)}</span>,im.prototype._map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >this.inverted?2:1,</span>i=<span class="cstat-no" title="statement not covered" >this.inverted?1:2,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;this.ranges.length;s+=3){var a=<span class="cstat-no" title="statement not covered" >this.ranges[s]-(this.inverted?r:0);<span class="cstat-no" title="statement not covered" ></span>if(a&gt;t)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >this.ranges[s+o],</span>l=<span class="cstat-no" title="statement not covered" >this.ranges[s+i],</span>p=<span class="cstat-no" title="statement not covered" >a+c;<span class="cstat-no" title="statement not covered" ></span>if(t&lt;=p){var u=<span class="cstat-no" title="statement not covered" >c?t==a?-1:t==p?1:e:e,</span>h=<span class="cstat-no" title="statement not covered" >a+r+(u&lt;0?0:l);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return h;v</span></span>ar d=<span class="cstat-no" title="statement not covered" >t==(e&lt;0?a:p)?null:em(s/3,t-a);<span class="cstat-no" title="statement not covered" ></span>return new om(h,e&lt;0?t!=a:t!=p,d)}<span class="cstat-no" title="statement not covered" ></span>r</span>+=l-c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n?t+r:new om(t+r)}</span>,im.prototype.touches=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >nm(e),</span>o=<span class="cstat-no" title="statement not covered" >this.inverted?2:1,</span>i=<span class="cstat-no" title="statement not covered" >this.inverted?1:2,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;this.ranges.length;s+=3){var a=<span class="cstat-no" title="statement not covered" >this.ranges[s]-(this.inverted?n:0);<span class="cstat-no" title="statement not covered" ></span>if(a&gt;t)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >this.ranges[s+o],</span>l=<span class="cstat-no" title="statement not covered" >a+c;<span class="cstat-no" title="statement not covered" ></span>if(t&lt;=l&amp;&amp;s==3*r)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >n</span></span>+=this.ranges[s+i]-c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>,im.prototype.forEach=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.inverted?2:1,</span>n=<span class="cstat-no" title="statement not covered" >this.inverted?1:2,</span>r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;this.ranges.length;r+=3){var i=<span class="cstat-no" title="statement not covered" >this.ranges[r],</span>s=<span class="cstat-no" title="statement not covered" >i-(this.inverted?o:0),</span>a=<span class="cstat-no" title="statement not covered" >i+(this.inverted?0:o),</span>c=<span class="cstat-no" title="statement not covered" >this.ranges[r+e],</span>l=<span class="cstat-no" title="statement not covered" >this.ranges[r+n];<span class="cstat-no" title="statement not covered" ></span>t(s,s+c,a,a+l),o+=l-c}</span>}</span>,im.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new im(this.ranges,!this.inverted)}</span>,im.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.inverted?"-":"")+JSON.stringify(this.ranges)}</span>,im.offset=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0==t?im.empty:new im(t&lt;0?[0,-t,0]:[0,0,t])}</span>,im.empty=new im([]);v</span>ar sm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.maps=t||[],this.from=n||0,this.to=null==r?this.maps.length:r,this.mirror=e}</span>;</span>function <span class="fstat-no" title="function not covered" >am(</span>t){var e=<span class="cstat-no" title="statement not covered" >Error.call(this,t);<span class="cstat-no" title="statement not covered" ></span>return e.__proto__=am.prototype,e}<span class="cstat-no" title="statement not covered" ></span>sm.prototype.slice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===t&amp;&amp;(t=0),void 0===e&amp;&amp;(e=this.maps.length),new sm(this.maps,this.mirror,t,e)}</span>,sm.prototype.copy=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new sm(this.maps.slice(),this.mirror&amp;&amp;this.mirror.slice(),this.from,this.to)}</span>,sm.prototype.appendMap=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.to=this.maps.push(t),null!=e&amp;&amp;this.setMirror(this.maps.length-1,e)}</span>,sm.prototype.appendMapping=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >this.maps.length;</span>e&lt;t.maps.length;e++){var r=<span class="cstat-no" title="statement not covered" >t.getMirror(e);<span class="cstat-no" title="statement not covered" ></span>this.appendMap(t.maps[e],null!=r&amp;&amp;r&lt;e?n+r:null)}</span>}</span>,sm.prototype.getMirror=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.mirror)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.mirror.length;e++)<span class="cstat-no" title="statement not covered" >if(this.mirror[e]==t)<span class="cstat-no" title="statement not covered" >return this.mirror[e+(e%2?-1:1)]}</span></span></span></span>,sm.prototype.setMirror=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.mirror||(this.mirror=[]),this.mirror.push(t,e)}</span>,sm.prototype.appendMappingInverted=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.maps.length-1,</span>n=<span class="cstat-no" title="statement not covered" >this.maps.length+t.maps.length;</span>e&gt;=0;e--){var r=<span class="cstat-no" title="statement not covered" >t.getMirror(e);<span class="cstat-no" title="statement not covered" ></span>this.appendMap(t.maps[e].invert(),null!=r&amp;&amp;r&gt;e?n-r-1:null)}</span>}</span>,sm.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >new sm;<span class="cstat-no" title="statement not covered" ></span>return t.appendMappingInverted(this),t}</span>,sm.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(void 0===e&amp;&amp;(e=1),this.mirror)<span class="cstat-no" title="statement not covered" >return this._map(t,e,!0);<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >this.from;</span>n&lt;this.to;n++)<span class="cstat-no" title="statement not covered" >t=this.maps[n].map(t,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,sm.prototype.mapResult=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=1),this._map(t,e,!1)}</span>,sm.prototype._map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >this.from;</span>o&lt;this.to;o++){var i=<span class="cstat-no" title="statement not covered" >this.maps[o],</span>s=<span class="cstat-no" title="statement not covered" >i.mapResult(t,e);<span class="cstat-no" title="statement not covered" ></span>if(null!=s.recover){var a=<span class="cstat-no" title="statement not covered" >this.getMirror(o);<span class="cstat-no" title="statement not covered" ></span>if(null!=a&amp;&amp;a&gt;o&amp;&amp;a&lt;this.to){<span class="cstat-no" title="statement not covered" >o=a,t=this.maps[a].recover(s.recover);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>.deleted&amp;&amp;(r=!0),t=s.pos}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n?t:new om(t,r)}</span>,am.prototype=Object.create(Error.prototype),am.prototype.constructor=am,am.prototype.name="TransformError";v</span>ar cm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.doc=t,this.steps=[],this.docs=[],this.mapping=new sm}</span>,</span>lm=<span class="cstat-no" title="statement not covered" >{before:{configurable:!0},docChanged:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >pm(</span>){<span class="cstat-no" title="statement not covered" >throw new Error("Override me")}<span class="cstat-no" title="statement not covered" ></span>lm.before.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.docs.length?this.docs[0]:this.doc}</span>,cm.prototype.step=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.maybeStep(t);<span class="cstat-no" title="statement not covered" ></span>if(e.failed)<span class="cstat-no" title="statement not covered" >throw new am(e.failed);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,cm.prototype.maybeStep=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.apply(this.doc);<span class="cstat-no" title="statement not covered" ></span>return e.failed||this.addStep(t,e.doc),e}</span>,lm.docChanged.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.steps.length&gt;0}</span>,cm.prototype.addStep=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.docs.push(this.doc),this.steps.push(t),this.mapping.appendMap(t.getMap()),this.doc=e}</span>,Object.defineProperties(cm.prototype,lm);v</span>ar um=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>hm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" ></span>hm.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return pm()}</span>,hm.prototype.getMap=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return im.empty}</span>,hm.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return pm()}</span>,hm.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return pm()}</span>,hm.prototype.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null}</span>,hm.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return pm()}</span>,hm.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e||!e.stepType)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Step.fromJSON");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >um[e.stepType];<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new RangeError("No step type "+e.stepType+" defined");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.fromJSON(t,e)}</span>,hm.jsonID=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t in um)<span class="cstat-no" title="statement not covered" >throw new RangeError("Duplicate use of step JSON ID "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn um[t]=e,e.prototype.jsonID=t,e}</span>;v</span>ar dm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.doc=t,this.failed=e}</span>;<span class="cstat-no" title="statement not covered" ></span>dm.ok=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new dm(t,null)}</span>,dm.fail=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new dm(null,t)}</span>,dm.fromReplace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return dm.ok(t.replace(e,n,r))}</span>catch(o){<span class="cstat-no" title="statement not covered" >if(o instanceof Fd)<span class="cstat-no" title="statement not covered" >return dm.fail(o.message);<span class="cstat-no" title="statement not covered" >t</span></span>hrow o}</span>}</span>;v</span>ar fm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o){<span class="cstat-no" title="statement not covered" >t.call(this),this.from=e,this.to=n,this.slice=r,this.structure=!!o}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.structure&amp;&amp;vm(t,this.from,this.to)?dm.fail("Structure replace would overwrite content"):dm.fromReplace(t,this.from,this.to,this.slice)}</span>,e.prototype.getMap=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new im([this.from,this.to-this.from,this.slice.size])}</span>,e.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new e(this.from,this.from+this.slice.size,t.slice(this.from,this.to))}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.mapResult(this.from,1),</span>r=<span class="cstat-no" title="statement not covered" >t.mapResult(this.to,-1);<span class="cstat-no" title="statement not covered" ></span>return n.deleted&amp;&amp;r.deleted?null:new e(n.pos,Math.max(n.pos,r.pos),this.slice)}</span>,e.prototype.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!(t instanceof e)||t.structure||this.structure)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.from+this.slice.size!=t.from||this.slice.openEnd||t.slice.openStart){<span class="cstat-no" title="statement not covered" >if(t.to!=this.from||this.slice.openStart||t.slice.openEnd)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.slice.size+t.slice.size==0?Hd.empty:new Hd(t.slice.content.append(this.slice.content),t.slice.openStart,this.slice.openEnd);<span class="cstat-no" title="statement not covered" ></span>return new e(t.from,this.to,n,this.structure)}</span>v</span>ar r=<span class="cstat-no" title="statement not covered" >this.slice.size+t.slice.size==0?Hd.empty:new Hd(this.slice.content.append(t.slice.content),this.slice.openStart,t.slice.openEnd);<span class="cstat-no" title="statement not covered" ></span>return new e(this.from,this.to+(t.to-t.from),r,this.structure)}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >{stepType:"replace",from:this.from,to:this.to};<span class="cstat-no" title="statement not covered" ></span>return this.slice.size&amp;&amp;(t.slice=this.slice.toJSON()),this.structure&amp;&amp;(t.structure=!0),t}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.from||"number"!=typeof n.to)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for ReplaceStep.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(n.from,n.to,Hd.fromJSON(t,n.slice),!!n.structure)}</span>,e}</span>(hm);<span class="cstat-no" title="statement not covered" ></span>hm.jsonID("replace",fm);v</span>ar mm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r,o,i,s,a){<span class="cstat-no" title="statement not covered" >t.call(this),this.from=e,this.to=n,this.gapFrom=r,this.gapTo=o,this.slice=i,this.insert=s,this.structure=!!a}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.structure&amp;&amp;(vm(t,this.from,this.gapFrom)||vm(t,this.gapTo,this.to)))<span class="cstat-no" title="statement not covered" >return dm.fail("Structure gap-replace would overwrite content");v</span></span>ar e=<span class="cstat-no" title="statement not covered" >t.slice(this.gapFrom,this.gapTo);<span class="cstat-no" title="statement not covered" ></span>if(e.openStart||e.openEnd)<span class="cstat-no" title="statement not covered" >return dm.fail("Gap is not a flat range");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.slice.insertAt(this.insert,e.content);<span class="cstat-no" title="statement not covered" ></span>return n?dm.fromReplace(t,this.from,this.to,n):dm.fail("Content does not fit in gap")}</span>,e.prototype.getMap=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new im([this.from,this.gapFrom-this.from,this.insert,this.gapTo,this.to-this.gapTo,this.slice.size-this.insert])}</span>,e.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >this.gapTo-this.gapFrom;<span class="cstat-no" title="statement not covered" ></span>return new e(this.from,this.from+this.slice.size+n,this.from+this.insert,this.from+this.insert+n,t.slice(this.from,this.to).removeBetween(this.gapFrom-this.from,this.gapTo-this.from),this.gapFrom-this.from,this.structure)}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.mapResult(this.from,1),</span>r=<span class="cstat-no" title="statement not covered" >t.mapResult(this.to,-1),</span>o=<span class="cstat-no" title="statement not covered" >t.map(this.gapFrom,-1),</span>i=<span class="cstat-no" title="statement not covered" >t.map(this.gapTo,1);<span class="cstat-no" title="statement not covered" ></span>return n.deleted&amp;&amp;r.deleted||o&lt;n.pos||i&gt;r.pos?null:new e(n.pos,r.pos,o,i,this.slice,this.insert,this.structure)}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >{stepType:"replaceAround",from:this.from,to:this.to,gapFrom:this.gapFrom,gapTo:this.gapTo,insert:this.insert};<span class="cstat-no" title="statement not covered" ></span>return this.slice.size&amp;&amp;(t.slice=this.slice.toJSON()),this.structure&amp;&amp;(t.structure=!0),t}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.from||"number"!=typeof n.to||"number"!=typeof n.gapFrom||"number"!=typeof n.gapTo||"number"!=typeof n.insert)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(n.from,n.to,n.gapFrom,n.gapTo,Hd.fromJSON(t,n.slice),n.insert,!!n.structure)}</span>,e}</span>(hm);</span>function <span class="fstat-no" title="function not covered" >vm(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.resolve(e),</span>o=<span class="cstat-no" title="statement not covered" >n-e,</span>i=<span class="cstat-no" title="statement not covered" >r.depth;<span class="cstat-no" title="statement not covered" ></span>while(o&gt;0&amp;&amp;i&gt;0&amp;&amp;r.indexAfter(i)==r.node(i).childCount)<span class="cstat-no" title="statement not covered" >i--,o--;<span class="cstat-no" title="statement not covered" >i</span></span>f(o&gt;0){var s=<span class="cstat-no" title="statement not covered" >r.node(i).maybeChild(r.indexAfter(i));<span class="cstat-no" title="statement not covered" ></span>while(o&gt;0){<span class="cstat-no" title="statement not covered" >if(!s||s.isLeaf)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >s</span></span>=s.firstChild,o--}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >gm(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.resolve(e),</span>o=<span class="cstat-no" title="statement not covered" >r.index();<span class="cstat-no" title="statement not covered" ></span>return r.parent.canReplaceWith(o,o+1,n)}</span>function <span class="fstat-no" title="function not covered" >ym(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.resolve(e);<span class="cstat-no" title="statement not covered" ></span>if(r.parent.canReplaceWith(r.index(),r.index(),n))<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(0==r.parentOffset)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >r.depth-1;</span>o&gt;=0;o--){var i=<span class="cstat-no" title="statement not covered" >r.index(o);<span class="cstat-no" title="statement not covered" ></span>if(r.node(o).canReplaceWith(i,i,n))<span class="cstat-no" title="statement not covered" >return r.before(o+1);<span class="cstat-no" title="statement not covered" >i</span></span>f(i&gt;0)<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span></span>i</span></span>f(r.parentOffset==r.parent.content.size)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >r.depth-1;</span>s&gt;=0;s--){var a=<span class="cstat-no" title="statement not covered" >r.indexAfter(s);<span class="cstat-no" title="statement not covered" ></span>if(r.node(s).canReplaceWith(a,a,n))<span class="cstat-no" title="statement not covered" >return r.after(s+1);<span class="cstat-no" title="statement not covered" >i</span></span>f(a&lt;r.node(s).childCount)<span class="cstat-no" title="statement not covered" >return null}</span></span>}</span></span>function <span class="fstat-no" title="function not covered" >bm(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;t.childCount;o++){var i=<span class="cstat-no" title="statement not covered" >t.child(o);<span class="cstat-no" title="statement not covered" ></span>i.content.size&amp;&amp;(i=i.copy(bm(i.content,e,i))),i.isInline&amp;&amp;(i=e(i,n,o)),r.push(i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Pd.fromArray(r)}<span class="cstat-no" title="statement not covered" ></span>hm.jsonID("replaceAround",mm),cm.prototype.lift=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t.$from,</span>r=<span class="cstat-no" title="statement not covered" >t.$to,</span>o=<span class="cstat-no" title="statement not covered" >t.depth,</span>i=<span class="cstat-no" title="statement not covered" >n.before(o+1),</span>s=<span class="cstat-no" title="statement not covered" >r.after(o+1),</span>a=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >s,</span>l=<span class="cstat-no" title="statement not covered" >Pd.empty,</span>p=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >o,</span>h=<span class="cstat-no" title="statement not covered" >!1;</span>u&gt;e;u--)<span class="cstat-no" title="statement not covered" >h||n.index(u)&gt;0?(h=!0,l=Pd.from(n.node(u).copy(l)),p++):a--;<span class="cstat-no" title="statement not covered" >f</span></span>or(var d=<span class="cstat-no" title="statement not covered" >Pd.empty,</span>f=<span class="cstat-no" title="statement not covered" >0,</span>m=<span class="cstat-no" title="statement not covered" >o,</span>v=<span class="cstat-no" title="statement not covered" >!1;</span>m&gt;e;m--)<span class="cstat-no" title="statement not covered" >v||r.after(m+1)&lt;r.end(m)?(v=!0,d=Pd.from(r.node(m).copy(d)),f++):c++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.step(new mm(a,c,i,s,new Hd(l.append(d),p,f),l.size-p,!0))}</span>,cm.prototype.wrap=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >Pd.empty,</span>r=<span class="cstat-no" title="statement not covered" >e.length-1;</span>r&gt;=0;r--)<span class="cstat-no" title="statement not covered" >n=Pd.from(e[r].type.create(e[r].attrs,n));v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t.start,</span>i=<span class="cstat-no" title="statement not covered" >t.end;<span class="cstat-no" title="statement not covered" ></span>return this.step(new mm(o,i,o,i,new Hd(n,0,0),e.length,!0))}</span>,cm.prototype.setBlockType=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(void 0===e&amp;&amp;(e=t),!n.isTextblock)<span class="cstat-no" title="statement not covered" >throw new RangeError("Type given to setBlockType should be a textblock");v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this.steps.length;<span class="cstat-no" title="statement not covered" ></span>return this.doc.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t.isTextblock&amp;&amp;!t.hasMarkup(n,r)&amp;&amp;gm(o.doc,o.mapping.slice(i).map(e),n)){<span class="cstat-no" title="statement not covered" >o.clearIncompatible(o.mapping.slice(i).map(e,1),n);v</span>ar s=<span class="cstat-no" title="statement not covered" >o.mapping.slice(i),</span>a=<span class="cstat-no" title="statement not covered" >s.map(e,1),</span>c=<span class="cstat-no" title="statement not covered" >s.map(e+t.nodeSize,1);<span class="cstat-no" title="statement not covered" ></span>return o.step(new mm(a,c,a+1,c-1,new Hd(Pd.from(n.create(r,null,t.marks)),0,0),1,!0)),!1}</span>}</span>)),this}</span>,cm.prototype.setNodeMarkup=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >this.doc.nodeAt(t);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >throw new RangeError("No node at given position");<span class="cstat-no" title="statement not covered" >e</span></span>||(e=o.type);v</span>ar i=<span class="cstat-no" title="statement not covered" >e.create(n,null,r||o.marks);<span class="cstat-no" title="statement not covered" ></span>if(o.isLeaf)<span class="cstat-no" title="statement not covered" >return this.replaceWith(t,t+o.nodeSize,i);<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.validContent(o.content))<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid content for node type "+e.name);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.step(new mm(t,t+o.nodeSize,t+1,t+o.nodeSize-1,new Hd(Pd.from(i),0,0),1,!0))}</span>,cm.prototype.split=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=1);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >this.doc.resolve(t),</span>o=<span class="cstat-no" title="statement not covered" >Pd.empty,</span>i=<span class="cstat-no" title="statement not covered" >Pd.empty,</span>s=<span class="cstat-no" title="statement not covered" >r.depth,</span>a=<span class="cstat-no" title="statement not covered" >r.depth-e,</span>c=<span class="cstat-no" title="statement not covered" >e-1;</span>s&gt;a;s--,c--){<span class="cstat-no" title="statement not covered" >o=Pd.from(r.node(s).copy(o));v</span>ar l=<span class="cstat-no" title="statement not covered" >n&amp;&amp;n[c];<span class="cstat-no" title="statement not covered" ></span>i=Pd.from(l?l.type.create(l.attrs,i):r.node(s).copy(i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.step(new fm(t,t,new Hd(o.append(i),e,e),!0))}</span>,cm.prototype.join=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=1);v</span>ar n=<span class="cstat-no" title="statement not covered" >new fm(t-e,t+e,Hd.empty,!0);<span class="cstat-no" title="statement not covered" ></span>return this.step(n)}</span>;v</span>ar wm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r){<span class="cstat-no" title="statement not covered" >t.call(this),this.from=e,this.to=n,this.mark=r}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.slice(this.from,this.to),</span>r=<span class="cstat-no" title="statement not covered" >t.resolve(this.from),</span>o=<span class="cstat-no" title="statement not covered" >r.node(r.sharedDepth(this.to)),</span>i=<span class="cstat-no" title="statement not covered" >new Hd(bm(n.content,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t.isAtom&amp;&amp;n.type.allowsMarkType(e.mark.type)?t.mark(e.mark.addToSet(t.marks)):t}</span>),o),n.openStart,n.openEnd);<span class="cstat-no" title="statement not covered" ></span>return dm.fromReplace(t,this.from,this.to,i)}</span>,e.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Om(this.from,this.to,this.mark)}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.mapResult(this.from,1),</span>r=<span class="cstat-no" title="statement not covered" >t.mapResult(this.to,-1);<span class="cstat-no" title="statement not covered" ></span>return n.deleted&amp;&amp;r.deleted||n.pos&gt;=r.pos?null:new e(n.pos,r.pos,this.mark)}</span>,e.prototype.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t instanceof e&amp;&amp;t.mark.eq(this.mark)&amp;&amp;this.from&lt;=t.to&amp;&amp;this.to&gt;=t.from)<span class="cstat-no" title="statement not covered" >return new e(Math.min(this.from,t.from),Math.max(this.to,t.to),this.mark)}</span></span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{stepType:"addMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.from||"number"!=typeof n.to)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for AddMarkStep.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(n.from,n.to,t.markFromJSON(n.mark))}</span>,e}</span>(hm);<span class="cstat-no" title="statement not covered" ></span>hm.jsonID("addMark",wm);v</span>ar Om=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n,r){<span class="cstat-no" title="statement not covered" >t.call(this),this.from=e,this.to=n,this.mark=r}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.slice(this.from,this.to),</span>r=<span class="cstat-no" title="statement not covered" >new Hd(bm(n.content,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.mark(e.mark.removeFromSet(t.marks))}</span>)),n.openStart,n.openEnd);<span class="cstat-no" title="statement not covered" ></span>return dm.fromReplace(t,this.from,this.to,r)}</span>,e.prototype.invert=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new wm(this.from,this.to,this.mark)}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.mapResult(this.from,1),</span>r=<span class="cstat-no" title="statement not covered" >t.mapResult(this.to,-1);<span class="cstat-no" title="statement not covered" ></span>return n.deleted&amp;&amp;r.deleted||n.pos&gt;=r.pos?null:new e(n.pos,r.pos,this.mark)}</span>,e.prototype.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t instanceof e&amp;&amp;t.mark.eq(this.mark)&amp;&amp;this.from&lt;=t.to&amp;&amp;this.to&gt;=t.from)<span class="cstat-no" title="statement not covered" >return new e(Math.min(this.from,t.from),Math.max(this.to,t.to),this.mark)}</span></span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{stepType:"removeMark",mark:this.mark.toJSON(),from:this.from,to:this.to}}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.from||"number"!=typeof n.to)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(n.from,n.to,t.markFromJSON(n.mark))}</span>,e}</span>(hm);</span>function <span class="fstat-no" title="function not covered" >km(</span>t,e,n,r){<span class="cstat-no" title="statement not covered" >if(void 0===n&amp;&amp;(n=e),void 0===r&amp;&amp;(r=Hd.empty),e==n&amp;&amp;!r.size)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t.resolve(e),</span>i=<span class="cstat-no" title="statement not covered" >t.resolve(n);<span class="cstat-no" title="statement not covered" ></span>return xm(o,i,r)?new fm(e,n,r):new Sm(o,i,r).fit()}</span>function <span class="fstat-no" title="function not covered" >xm(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return!n.openStart&amp;&amp;!n.openEnd&amp;&amp;t.start()==e.start()&amp;&amp;t.parent.canReplace(t.index(),e.index(),n.content)}<span class="cstat-no" title="statement not covered" ></span>hm.jsonID("removeMark",Om),cm.prototype.addMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >null,</span>a=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return this.doc.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(r,c,l){<span class="cstat-no" title="statement not covered" >if(r.isInline){var p=<span class="cstat-no" title="statement not covered" >r.marks;<span class="cstat-no" title="statement not covered" ></span>if(!n.isInSet(p)&amp;&amp;l.type.allowsMarkType(n.type)){<span class="cstat-no" title="statement not covered" >for(var u=<span class="cstat-no" title="statement not covered" >Math.max(c,t),</span>h=<span class="cstat-no" title="statement not covered" >Math.min(c+r.nodeSize,e),</span>d=<span class="cstat-no" title="statement not covered" >n.addToSet(p),</span>f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;p.length;f++)<span class="cstat-no" title="statement not covered" >p[f].isInSet(d)||(s&amp;&amp;s.to==u&amp;&amp;s.mark.eq(p[f])?s.to=h:o.push(s=new Om(u,h,p[f])));<span class="cstat-no" title="statement not covered" >a</span></span>&amp;&amp;a.to==u?a.to=h:i.push(a=new wm(u,h,n))}</span>}</span>}</span>)),o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return r.step(t)}</span>)),i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return r.step(t)}</span>)),this}</span>,cm.prototype.removeMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>void 0===n&amp;&amp;(n=null);v</span>ar o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.doc.nodesBetween(t,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(r,s){<span class="cstat-no" title="statement not covered" >if(r.isInline){<span class="cstat-no" title="statement not covered" >i++;v</span>ar a=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(n instanceof Bf){var c,l=<span class="cstat-no" title="statement not covered" >r.marks;<span class="cstat-no" title="statement not covered" ></span>while(c=n.isInSet(l))<span class="cstat-no" title="statement not covered" >(a||(a=[])).push(c),l=c.removeFromSet(l)}</span></span>else <span class="cstat-no" title="statement not covered" >n?n.isInSet(r.marks)&amp;&amp;(a=[n]):a=r.marks;<span class="cstat-no" title="statement not covered" >i</span></span>f(a&amp;&amp;a.length)<span class="cstat-no" title="statement not covered" >for(var p=<span class="cstat-no" title="statement not covered" >Math.min(s+r.nodeSize,e),</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;a.length;u++){<span class="cstat-no" title="statement not covered" >for(var h=<span class="cstat-no" title="statement not covered" >a[u],</span>d=<span class="cstat-no" title="statement not covered" >void 0,</span>f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;o.length;f++){var m=<span class="cstat-no" title="statement not covered" >o[f];<span class="cstat-no" title="statement not covered" ></span>m.step==i-1&amp;&amp;h.eq(o[f].style)&amp;&amp;(d=m)}<span class="cstat-no" title="statement not covered" ></span>d</span>?(d.to=p,d.step=i):o.push({style:h,from:Math.max(s,t),to:p,step:i})}</span>}</span></span>}</span>)),o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return r.step(new Om(t.from,t.to,t.style))}</span>)),this}</span>,cm.prototype.clearIncompatible=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=e.contentMatch);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >this.doc.nodeAt(t),</span>o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >t+1,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;r.childCount;s++){var a=<span class="cstat-no" title="statement not covered" >r.child(s),</span>c=<span class="cstat-no" title="statement not covered" >i+a.nodeSize,</span>l=<span class="cstat-no" title="statement not covered" >n.matchType(a.type,a.attrs);<span class="cstat-no" title="statement not covered" ></span>if(l){<span class="cstat-no" title="statement not covered" >n=l;<span class="cstat-no" title="statement not covered" >f</span>or(var p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;a.marks.length;p++)<span class="cstat-no" title="statement not covered" >e.allowsMarkType(a.marks[p].type)||this.step(new Om(i,c,a.marks[p]))}</span></span>else <span class="cstat-no" title="statement not covered" >o.push(new fm(i,c,Hd.empty));<span class="cstat-no" title="statement not covered" >i</span></span>=c}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!n.validEnd){var u=<span class="cstat-no" title="statement not covered" >n.fillBefore(Pd.empty,!0);<span class="cstat-no" title="statement not covered" ></span>this.replace(i,i,new Hd(u,0,0))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var h=<span class="cstat-no" title="statement not covered" >o.length-1;</span>h&gt;=0;h--)<span class="cstat-no" title="statement not covered" >this.step(o[h]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}</span>,cm.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=t),void 0===n&amp;&amp;(n=Hd.empty);v</span>ar r=<span class="cstat-no" title="statement not covered" >km(this.doc,t,e,n);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;this.step(r),this}</span>,cm.prototype.replaceWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return this.replace(t,e,new Hd(Pd.from(n),0,0))}</span>,cm.prototype.delete=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.replace(t,e,Hd.empty)}</span>,cm.prototype.insert=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.replaceWith(t,t,e)}</span>;v</span>ar Sm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.$to=e,this.$from=t,this.unplaced=n,this.frontier=[];<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;=t.depth;r++){var o=<span class="cstat-no" title="statement not covered" >t.node(r);<span class="cstat-no" title="statement not covered" ></span>this.frontier.push({type:o.type,match:o.contentMatchAt(t.indexAfter(r))})}<span class="cstat-no" title="statement not covered" ></span>t</span>his.placed=Pd.empty;<span class="cstat-no" title="statement not covered" >f</span>or(var i=<span class="cstat-no" title="statement not covered" >t.depth;</span>i&gt;0;i--)<span class="cstat-no" title="statement not covered" >this.placed=Pd.from(t.node(i).copy(this.placed))}</span></span>,</span>Mm=<span class="cstat-no" title="statement not covered" >{depth:{configurable:!0}};</span>function <span class="fstat-no" title="function not covered" >Cm(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return 0==e?t.cutByIndex(n):t.replaceChild(0,t.firstChild.copy(Cm(t.firstChild.content,e-1,n)))}</span>function <span class="fstat-no" title="function not covered" >Em(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return 0==e?t.append(n):t.replaceChild(t.childCount-1,t.lastChild.copy(Em(t.lastChild.content,e-1,n)))}</span>function <span class="fstat-no" title="function not covered" >Tm(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e;n++)<span class="cstat-no" title="statement not covered" >t=t.firstChild.content;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Nm(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(e&lt;=0)<span class="cstat-no" title="statement not covered" >return t;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t.content;<span class="cstat-no" title="statement not covered" ></span>return e&gt;1&amp;&amp;(r=r.replaceChild(0,Nm(r.firstChild,e-1,1==r.childCount?n-1:0))),e&gt;0&amp;&amp;(r=t.type.contentMatch.fillBefore(r).append(r),n&lt;=0&amp;&amp;(r=r.append(t.type.contentMatch.matchFragment(r).fillBefore(Pd.empty,!0)))),t.copy(r)}</span>function <span class="fstat-no" title="function not covered" >jm(</span>t,e,n,r,o){var i=<span class="cstat-no" title="statement not covered" >t.node(e),</span>s=<span class="cstat-no" title="statement not covered" >o?t.indexAfter(e):t.index(e);<span class="cstat-no" title="statement not covered" ></span>if(s==i.childCount&amp;&amp;!n.compatibleContent(i.type))<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >r.fillBefore(i.content,!0,s);<span class="cstat-no" title="statement not covered" ></span>return a&amp;&amp;!Am(n,i.content,s)?a:null}</span>function <span class="fstat-no" title="function not covered" >Am(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >n;</span>r&lt;e.childCount;r++)<span class="cstat-no" title="statement not covered" >if(!t.allowsMarks(e.child(r).marks))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Im(</span>t,e,n,r,o){<span class="cstat-no" title="statement not covered" >if(e&lt;n){var i=<span class="cstat-no" title="statement not covered" >t.firstChild;<span class="cstat-no" title="statement not covered" ></span>t=t.replaceChild(0,i.copy(Im(i.content,e+1,n,r,i)))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e&gt;r){var s=<span class="cstat-no" title="statement not covered" >o.contentMatchAt(0),</span>a=<span class="cstat-no" title="statement not covered" >s.fillBefore(t).append(t);<span class="cstat-no" title="statement not covered" ></span>t=a.append(s.matchFragment(a).fillBefore(Pd.empty,!0))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Dm(</span>t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >Math.min(t.depth,e.depth),</span>o=<span class="cstat-no" title="statement not covered" >r;</span>o&gt;=0;o--){var i=<span class="cstat-no" title="statement not covered" >t.start(o);<span class="cstat-no" title="statement not covered" ></span>if(i&lt;t.pos-(t.depth-o)||e.end(o)&gt;e.pos+(e.depth-o)||t.node(o).type.spec.isolating||e.node(o).type.spec.isolating)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>==e.start(o)&amp;&amp;n.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="cstat-no" title="statement not covered" ></span>Mm.depth.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.frontier.length-1}</span>,Sm.prototype.fit=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >while(this.unplaced.size){var t=<span class="cstat-no" title="statement not covered" >this.findFittable();<span class="cstat-no" title="statement not covered" ></span>t?this.placeNodes(t):this.openMore()||this.dropNode()}</span>v</span>ar e=<span class="cstat-no" title="statement not covered" >this.mustMoveInline(),</span>n=<span class="cstat-no" title="statement not covered" >this.placed.size-this.depth-this.$from.depth,</span>r=<span class="cstat-no" title="statement not covered" >this.$from,</span>o=<span class="cstat-no" title="statement not covered" >this.close(e&lt;0?this.$to:r.doc.resolve(e));<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar i=<span class="cstat-no" title="statement not covered" >this.placed,</span>s=<span class="cstat-no" title="statement not covered" >r.depth,</span>a=<span class="cstat-no" title="statement not covered" >o.depth;<span class="cstat-no" title="statement not covered" ></span>while(s&amp;&amp;a&amp;&amp;1==i.childCount)<span class="cstat-no" title="statement not covered" >i=i.firstChild.content,s--,a--;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >new Hd(i,s,a);<span class="cstat-no" title="statement not covered" ></span>return e&gt;-1?new mm(r.pos,e,this.$to.pos,this.$to.end(),c,n):c.size||r.pos!=this.$to.pos?new fm(r.pos,o.pos,c):void 0}</span>,Sm.prototype.findFittable=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >1;</span>t&lt;=2;t++)<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >this.unplaced.openStart;</span>e&gt;=0;e--){var n=<span class="cstat-no" title="statement not covered" >void 0,</span>r=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>e?(r=Tm(this.unplaced.content,e-1).firstChild,n=r.content):n=this.unplaced.content;<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >n.firstChild,</span>i=<span class="cstat-no" title="statement not covered" >this.depth;</span>i&gt;=0;i--){var s=<span class="cstat-no" title="statement not covered" >this.frontier[i],</span>a=<span class="cstat-no" title="statement not covered" >s.type,</span>c=<span class="cstat-no" title="statement not covered" >s.match,</span>l=<span class="cstat-no" title="statement not covered" >void 0,</span>p=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>if(1==t&amp;&amp;(o?c.matchType(o.type)||(p=c.fillBefore(Pd.from(o),!1)):a.compatibleContent(r.type)))<span class="cstat-no" title="statement not covered" >return{sliceDepth:e,frontierDepth:i,parent:r,inject:p};<span class="cstat-no" title="statement not covered" >i</span></span>f(2==t&amp;&amp;o&amp;&amp;(l=c.findWrapping(o.type)))<span class="cstat-no" title="statement not covered" >return{sliceDepth:e,frontierDepth:i,parent:r,wrap:l};<span class="cstat-no" title="statement not covered" >i</span></span>f(r&amp;&amp;c.matchType(r.type))<span class="cstat-no" title="statement not covered" >break}</span></span>}</span>}</span></span>,Sm.prototype.openMore=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.unplaced,</span>e=<span class="cstat-no" title="statement not covered" >t.content,</span>n=<span class="cstat-no" title="statement not covered" >t.openStart,</span>r=<span class="cstat-no" title="statement not covered" >t.openEnd,</span>o=<span class="cstat-no" title="statement not covered" >Tm(e,n);<span class="cstat-no" title="statement not covered" ></span>return!(!o.childCount||o.firstChild.isLeaf)&amp;&amp;(this.unplaced=new Hd(e,n+1,Math.max(r,o.size+n&gt;=e.size-r?n+1:0)),!0)}</span>,Sm.prototype.dropNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.unplaced,</span>e=<span class="cstat-no" title="statement not covered" >t.content,</span>n=<span class="cstat-no" title="statement not covered" >t.openStart,</span>r=<span class="cstat-no" title="statement not covered" >t.openEnd,</span>o=<span class="cstat-no" title="statement not covered" >Tm(e,n);<span class="cstat-no" title="statement not covered" ></span>if(o.childCount&lt;=1&amp;&amp;n&gt;0){var i=<span class="cstat-no" title="statement not covered" >e.size-n&lt;=n+o.size;<span class="cstat-no" title="statement not covered" ></span>this.unplaced=new Hd(Cm(e,n-1,1),n-1,i?n-1:r)}</span>else <span class="cstat-no" title="statement not covered" >this.unplaced=new Hd(Cm(e,n,1),n,r)}</span></span>,Sm.prototype.placeNodes=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.sliceDepth,</span>n=<span class="cstat-no" title="statement not covered" >t.frontierDepth,</span>r=<span class="cstat-no" title="statement not covered" >t.parent,</span>o=<span class="cstat-no" title="statement not covered" >t.inject,</span>i=<span class="cstat-no" title="statement not covered" >t.wrap;<span class="cstat-no" title="statement not covered" ></span>while(this.depth&gt;n)<span class="cstat-no" title="statement not covered" >this.closeFrontierNode();<span class="cstat-no" title="statement not covered" >i</span></span>f(i)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >this.openFrontierNode(i[s]);v</span></span></span>ar a=<span class="cstat-no" title="statement not covered" >this.unplaced,</span>c=<span class="cstat-no" title="statement not covered" >r?r.content:a.content,</span>l=<span class="cstat-no" title="statement not covered" >a.openStart-e,</span>p=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >this.frontier[n],</span>d=<span class="cstat-no" title="statement not covered" >h.match,</span>f=<span class="cstat-no" title="statement not covered" >h.type;<span class="cstat-no" title="statement not covered" ></span>if(o){<span class="cstat-no" title="statement not covered" >for(var m=<span class="cstat-no" title="statement not covered" >0;</span>m&lt;o.childCount;m++)<span class="cstat-no" title="statement not covered" >u.push(o.child(m));<span class="cstat-no" title="statement not covered" >d</span></span>=d.matchFragment(o)}</span>v</span>ar v=<span class="cstat-no" title="statement not covered" >c.size+e-(a.content.size-a.openEnd);<span class="cstat-no" title="statement not covered" ></span>while(p&lt;c.childCount){var g=<span class="cstat-no" title="statement not covered" >c.child(p),</span>y=<span class="cstat-no" title="statement not covered" >d.matchType(g.type);<span class="cstat-no" title="statement not covered" ></span>if(!y)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >p</span></span>++,(p&gt;1||0==l||g.content.size)&amp;&amp;(d=y,u.push(Nm(g.mark(f.allowedMarks(g.marks)),1==p?l:0,p==c.childCount?v:-1)))}</span>v</span>ar b=<span class="cstat-no" title="statement not covered" >p==c.childCount;<span class="cstat-no" title="statement not covered" ></span>b||(v=-1),this.placed=Em(this.placed,n,Pd.from(u)),this.frontier[n].match=d,b&amp;&amp;v&lt;0&amp;&amp;r&amp;&amp;r.type==this.frontier[this.depth].type&amp;&amp;this.frontier.length&gt;1&amp;&amp;this.closeFrontierNode();<span class="cstat-no" title="statement not covered" >f</span>or(var w=<span class="cstat-no" title="statement not covered" >0,</span>O=<span class="cstat-no" title="statement not covered" >c;</span>w&lt;v;w++){var k=<span class="cstat-no" title="statement not covered" >O.lastChild;<span class="cstat-no" title="statement not covered" ></span>this.frontier.push({type:k.type,match:k.contentMatchAt(k.childCount)}),O=k.content}<span class="cstat-no" title="statement not covered" ></span>t</span>his.unplaced=b?0==e?Hd.empty:new Hd(Cm(a.content,e-1,1),e-1,v&lt;0?a.openEnd:e-1):new Hd(Cm(a.content,e,p),a.openStart,a.openEnd)}</span>,Sm.prototype.mustMoveInline=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.$to.parent.isTextblock||this.$to.end()==this.$to.pos)<span class="cstat-no" title="statement not covered" >return-1;v</span></span>ar t,e=<span class="cstat-no" title="statement not covered" >this.frontier[this.depth];<span class="cstat-no" title="statement not covered" ></span>if(!e.type.isTextblock||!jm(this.$to,this.$to.depth,e.type,e.match,!1)||this.$to.depth==this.depth&amp;&amp;(t=this.findCloseLevel(this.$to))&amp;&amp;t.depth==this.depth)<span class="cstat-no" title="statement not covered" >return-1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.$to,</span>r=<span class="cstat-no" title="statement not covered" >n.depth,</span>o=<span class="cstat-no" title="statement not covered" >this.$to.after(r);<span class="cstat-no" title="statement not covered" ></span>while(r&gt;1&amp;&amp;o==this.$to.end(--r))<span class="cstat-no" title="statement not covered" >++o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>,Sm.prototype.findCloseLevel=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t:<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >Math.min(this.depth,t.depth);</span>e&gt;=0;e--){var n=<span class="cstat-no" title="statement not covered" >this.frontier[e],</span>r=<span class="cstat-no" title="statement not covered" >n.match,</span>o=<span class="cstat-no" title="statement not covered" >n.type,</span>i=<span class="cstat-no" title="statement not covered" >e&lt;t.depth&amp;&amp;t.end(e+1)==t.pos+(t.depth-(e+1)),</span>s=<span class="cstat-no" title="statement not covered" >jm(t,e,o,r,i);<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >e-1;</span>a&gt;=0;a--){var c=<span class="cstat-no" title="statement not covered" >this.frontier[a],</span>l=<span class="cstat-no" title="statement not covered" >c.match,</span>p=<span class="cstat-no" title="statement not covered" >c.type,</span>u=<span class="cstat-no" title="statement not covered" >jm(t,a,p,l,!0);<span class="cstat-no" title="statement not covered" ></span>if(!u||u.childCount)<span class="cstat-no" title="statement not covered" >continue t}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{depth:e,fit:s,move:i?t.doc.resolve(t.after(e+1)):t}}</span>}</span>}</span></span>,Sm.prototype.close=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this.findCloseLevel(t);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >w</span></span>hile(this.depth&gt;e.depth)<span class="cstat-no" title="statement not covered" >this.closeFrontierNode();<span class="cstat-no" title="statement not covered" >e</span></span>.fit.childCount&amp;&amp;(this.placed=Em(this.placed,e.depth,e.fit)),t=e.move;<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >e.depth+1;</span>n&lt;=t.depth;n++){var r=<span class="cstat-no" title="statement not covered" >t.node(n),</span>o=<span class="cstat-no" title="statement not covered" >r.type.contentMatch.fillBefore(r.content,!0,t.index(n));<span class="cstat-no" title="statement not covered" ></span>this.openFrontierNode(r.type,r.attrs,o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>,Sm.prototype.openFrontierNode=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >this.frontier[this.depth];<span class="cstat-no" title="statement not covered" ></span>r.match=r.match.matchType(t),this.placed=Em(this.placed,this.depth,Pd.from(t.create(e,n))),this.frontier.push({type:t,match:t.contentMatch})}</span>,Sm.prototype.closeFrontierNode=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this.frontier.pop(),</span>e=<span class="cstat-no" title="statement not covered" >t.match.fillBefore(Pd.empty,!0);<span class="cstat-no" title="statement not covered" ></span>e.childCount&amp;&amp;(this.placed=Em(this.placed,this.frontier.length,e))}</span>,Object.defineProperties(Sm.prototype,Mm),cm.prototype.replaceRange=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(!n.size)<span class="cstat-no" title="statement not covered" >return this.deleteRange(t,e);v</span></span>ar r=<span class="cstat-no" title="statement not covered" >this.doc.resolve(t),</span>o=<span class="cstat-no" title="statement not covered" >this.doc.resolve(e);<span class="cstat-no" title="statement not covered" ></span>if(xm(r,o,n))<span class="cstat-no" title="statement not covered" >return this.step(new fm(t,e,n));v</span></span>ar i=<span class="cstat-no" title="statement not covered" >Dm(r,this.doc.resolve(e));<span class="cstat-no" title="statement not covered" ></span>0==i[i.length-1]&amp;&amp;i.pop();v</span>ar s=<span class="cstat-no" title="statement not covered" >-(r.depth+1);<span class="cstat-no" title="statement not covered" ></span>i.unshift(s);<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >r.depth,</span>c=<span class="cstat-no" title="statement not covered" >r.pos-1;</span>a&gt;0;a--,c--){var l=<span class="cstat-no" title="statement not covered" >r.node(a).type.spec;<span class="cstat-no" title="statement not covered" ></span>if(l.defining||l.isolating)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>.indexOf(a)&gt;-1?s=a:r.before(a)==c&amp;&amp;i.splice(1,0,-a)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var p=<span class="cstat-no" title="statement not covered" >i.indexOf(s),</span>u=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >n.openStart,</span>d=<span class="cstat-no" title="statement not covered" >n.content,</span>f=<span class="cstat-no" title="statement not covered" >0;</span>;f++){var m=<span class="cstat-no" title="statement not covered" >d.firstChild;<span class="cstat-no" title="statement not covered" ></span>if(u.push(m),f==n.openStart)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >d</span></span>=m.content}<span class="cstat-no" title="statement not covered" ></span>h</span>&gt;0&amp;&amp;u[h-1].type.spec.defining&amp;&amp;r.node(p).type!=u[h-1].type?h-=1:h&gt;=2&amp;&amp;u[h-1].isTextblock&amp;&amp;u[h-2].type.spec.defining&amp;&amp;r.node(p).type!=u[h-2].type&amp;&amp;(h-=2);<span class="cstat-no" title="statement not covered" >f</span>or(var v=<span class="cstat-no" title="statement not covered" >n.openStart;</span>v&gt;=0;v--){var g=<span class="cstat-no" title="statement not covered" >(v+h+1)%(n.openStart+1),</span>y=<span class="cstat-no" title="statement not covered" >u[g];<span class="cstat-no" title="statement not covered" ></span>if(y)<span class="cstat-no" title="statement not covered" >for(var b=<span class="cstat-no" title="statement not covered" >0;</span>b&lt;i.length;b++){var w=<span class="cstat-no" title="statement not covered" >i[(b+p)%i.length],</span>O=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>w&lt;0&amp;&amp;(O=!1,w=-w);v</span>ar k=<span class="cstat-no" title="statement not covered" >r.node(w-1),</span>x=<span class="cstat-no" title="statement not covered" >r.index(w-1);<span class="cstat-no" title="statement not covered" ></span>if(k.canReplaceWith(x,x,y.type,y.marks))<span class="cstat-no" title="statement not covered" >return this.replace(r.before(w),O?o.after(w):e,new Hd(Im(n.content,0,n.openStart,g),g,n.openEnd))}</span></span>}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var S=<span class="cstat-no" title="statement not covered" >this.steps.length,</span>M=<span class="cstat-no" title="statement not covered" >i.length-1;</span>M&gt;=0;M--){<span class="cstat-no" title="statement not covered" >if(this.replace(t,e,n),this.steps.length&gt;S)<span class="cstat-no" title="statement not covered" >break;v</span></span>ar C=<span class="cstat-no" title="statement not covered" >i[M];<span class="cstat-no" title="statement not covered" ></span>C&lt;0||(t=r.before(C),e=o.after(C))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}</span>,cm.prototype.replaceRangeWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(!n.isInline&amp;&amp;t==e&amp;&amp;this.doc.resolve(t).parent.content.size){var r=<span class="cstat-no" title="statement not covered" >ym(this.doc,t,n.type);<span class="cstat-no" title="statement not covered" ></span>null!=r&amp;&amp;(t=e=r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.replaceRange(t,e,new Hd(Pd.from(n),0,0))}</span>,cm.prototype.deleteRange=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >this.doc.resolve(t),</span>r=<span class="cstat-no" title="statement not covered" >this.doc.resolve(e),</span>o=<span class="cstat-no" title="statement not covered" >Dm(n,r),</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;o.length;i++){var s=<span class="cstat-no" title="statement not covered" >o[i],</span>a=<span class="cstat-no" title="statement not covered" >i==o.length-1;<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;0==s||n.node(s).type.contentMatch.validEnd)<span class="cstat-no" title="statement not covered" >return this.delete(n.start(s),r.end(s));<span class="cstat-no" title="statement not covered" >i</span></span>f(s&gt;0&amp;&amp;(a||n.node(s-1).canReplace(n.index(s-1),r.indexAfter(s-1))))<span class="cstat-no" title="statement not covered" >return this.delete(n.before(s),r.after(s))}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(var c=<span class="cstat-no" title="statement not covered" >1;</span>c&lt;=n.depth&amp;&amp;c&lt;=r.depth;c++)<span class="cstat-no" title="statement not covered" >if(t-n.start(c)==n.depth-c&amp;&amp;e&gt;n.end(c)&amp;&amp;r.end(c)-e!=r.depth-c)<span class="cstat-no" title="statement not covered" >return this.delete(n.before(c),e);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this.delete(t,e)}</span>;v</span>ar Rm=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>_m=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.ranges=n||[new zm(t.min(e),t.max(e))],this.$anchor=t,this.$head=e}</span>,</span>Pm=<span class="cstat-no" title="statement not covered" >{anchor:{configurable:!0},head:{configurable:!0},from:{configurable:!0},to:{configurable:!0},$from:{configurable:!0},$to:{configurable:!0},empty:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>Pm.anchor.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$anchor.pos}</span>,Pm.head.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$head.pos}</span>,Pm.from.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.pos}</span>,Pm.to.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$to.pos}</span>,Pm.$from.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.ranges[0].$from}</span>,Pm.$to.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.ranges[0].$to}</span>,Pm.empty.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >this.ranges,</span>e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >if(t[e].$from.pos!=t[e].$to.pos)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>,_m.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$from.node(0).slice(this.from,this.to,!0)}</span>,_m.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=Hd.empty);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >e.content.lastChild,</span>r=<span class="cstat-no" title="statement not covered" >null,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.openEnd;o++)<span class="cstat-no" title="statement not covered" >r=n,n=n.lastChild;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >t.steps.length,</span>s=<span class="cstat-no" title="statement not covered" >this.ranges,</span>a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;s.length;a++){var c=<span class="cstat-no" title="statement not covered" >s[a],</span>l=<span class="cstat-no" title="statement not covered" >c.$from,</span>p=<span class="cstat-no" title="statement not covered" >c.$to,</span>u=<span class="cstat-no" title="statement not covered" >t.mapping.slice(i);<span class="cstat-no" title="statement not covered" ></span>t.replaceRange(u.map(l.pos),u.map(p.pos),a?Hd.empty:e),0==a&amp;&amp;Jm(t,i,(n?n.isInline:r&amp;&amp;r.isTextblock)?-1:1)}</span>}</span>,_m.prototype.replaceWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >t.steps.length,</span>r=<span class="cstat-no" title="statement not covered" >this.ranges,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;r.length;o++){var i=<span class="cstat-no" title="statement not covered" >r[o],</span>s=<span class="cstat-no" title="statement not covered" >i.$from,</span>a=<span class="cstat-no" title="statement not covered" >i.$to,</span>c=<span class="cstat-no" title="statement not covered" >t.mapping.slice(n),</span>l=<span class="cstat-no" title="statement not covered" >c.map(s.pos),</span>p=<span class="cstat-no" title="statement not covered" >c.map(a.pos);<span class="cstat-no" title="statement not covered" ></span>o?t.deleteRange(l,p):(t.replaceRangeWith(l,p,e),Jm(t,n,e.isInline?-1:1))}</span>}</span>,_m.findFrom=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.parent.inlineContent?new Bm(t):qm(t.node(0),t.parent,t.pos,t.index(),e,n);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >t.depth-1;</span>o&gt;=0;o--){var i=<span class="cstat-no" title="statement not covered" >e&lt;0?qm(t.node(0),t.node(o),t.before(o+1),t.index(o),e,n):qm(t.node(0),t.node(o),t.after(o+1),t.index(o)+1,e,n);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i}</span></span>}</span>,_m.near=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===e&amp;&amp;(e=1),this.findFrom(t,e)||this.findFrom(t,-e)||new Fm(t.node(0))}</span>,_m.atStart=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return qm(t,t,0,0,1)||new Fm(t)}</span>,_m.atEnd=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return qm(t,t,t.content.size,t.childCount,-1)||new Fm(t)}</span>,_m.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e||!e.type)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for Selection.fromJSON");v</span></span>ar n=<span class="cstat-no" title="statement not covered" >Rm[e.type];<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new RangeError("No selection type "+e.type+" defined");<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.fromJSON(t,e)}</span>,_m.jsonID=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(t in Rm)<span class="cstat-no" title="statement not covered" >throw new RangeError("Duplicate use of selection JSON ID "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Rm[t]=e,e.prototype.jsonID=t,e}</span>,_m.prototype.getBookmark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Bm.between(this.$anchor,this.$head).getBookmark()}</span>,Object.defineProperties(_m.prototype,Pm),_m.prototype.visible=!0;v</span>ar zm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.$from=t,this.$to=e}</span>,</span>Bm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=e),t.call(this,e,n)}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{$cursor:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return n.$cursor.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.$anchor.pos==this.$head.pos?this.$head:null}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){var o=<span class="cstat-no" title="statement not covered" >n.resolve(r.map(this.head));<span class="cstat-no" title="statement not covered" ></span>if(!o.parent.inlineContent)<span class="cstat-no" title="statement not covered" >return t.near(o);v</span></span>ar i=<span class="cstat-no" title="statement not covered" >n.resolve(r.map(this.anchor));<span class="cstat-no" title="statement not covered" ></span>return new e(i.parent.inlineContent?i:o,o)}</span>,e.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(void 0===n&amp;&amp;(n=Hd.empty),t.prototype.replace.call(this,e,n),n==Hd.empty){var r=<span class="cstat-no" title="statement not covered" >this.$from.marksAcross(this.$to);<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;e.ensureMarks(r)}</span>}</span>,e.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof e&amp;&amp;t.anchor==this.anchor&amp;&amp;t.head==this.head}</span>,e.prototype.getBookmark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Lm(this.anchor,this.head)}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{type:"text",anchor:this.anchor,head:this.head}}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.anchor||"number"!=typeof n.head)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for TextSelection.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(t.resolve(n.anchor),t.resolve(n.head))}</span>,e.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=e);v</span>ar r=<span class="cstat-no" title="statement not covered" >t.resolve(e);<span class="cstat-no" title="statement not covered" ></span>return new this(r,n==e?r:t.resolve(n))}</span>,e.between=<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o){var i=<span class="cstat-no" title="statement not covered" >n.pos-r.pos;<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;!i||(o=i&gt;=0?1:-1),!r.parent.inlineContent){var s=<span class="cstat-no" title="statement not covered" >t.findFrom(r,o,!0)||t.findFrom(r,-o,!0);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return t.near(r,o);<span class="cstat-no" title="statement not covered" >r</span></span>=s.$head}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n.parent.inlineContent||(0==i?n=r:(n=(t.findFrom(n,-o,!0)||t.findFrom(n,o,!0)).$anchor,n.pos&lt;r.pos!=i&lt;0&amp;&amp;(n=r))),new e(n,r)}</span>,Object.defineProperties(e.prototype,n),e}</span>(_m);<span class="cstat-no" title="statement not covered" ></span>_m.jsonID("text",Bm);v</span>ar Lm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.anchor=t,this.head=e}</span>;<span class="cstat-no" title="statement not covered" ></span>Lm.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Lm(t.map(this.anchor),t.map(this.head))}</span>,Lm.prototype.resolve=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Bm.between(t.resolve(this.anchor),t.resolve(this.head))}</span>;v</span>ar Vm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e){var n=<span class="cstat-no" title="statement not covered" >e.nodeAfter,</span>r=<span class="cstat-no" title="statement not covered" >e.node(0).resolve(e.pos+n.nodeSize);<span class="cstat-no" title="statement not covered" ></span>t.call(this,e,r),this.node=n}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){var o=<span class="cstat-no" title="statement not covered" >r.mapResult(this.anchor),</span>i=<span class="cstat-no" title="statement not covered" >o.deleted,</span>s=<span class="cstat-no" title="statement not covered" >o.pos,</span>a=<span class="cstat-no" title="statement not covered" >n.resolve(s);<span class="cstat-no" title="statement not covered" ></span>return i?t.near(a):new e(a)}</span>,e.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Hd(Pd.from(this.node),0,0)}</span>,e.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof e&amp;&amp;t.anchor==this.anchor}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{type:"node",anchor:this.anchor}}</span>,e.prototype.getBookmark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new $m(this.anchor)}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.anchor)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for NodeSelection.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(t.resolve(n.anchor))}</span>,e.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return new this(t.resolve(e))}</span>,e.isSelectable=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!t.isText&amp;&amp;!1!==t.type.spec.selectable}</span>,e}</span>(_m);<span class="cstat-no" title="statement not covered" ></span>Vm.prototype.visible=!1,_m.jsonID("node",Vm);v</span>ar $m=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.anchor=t}</span>;<span class="cstat-no" title="statement not covered" ></span>$m.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.mapResult(this.anchor),</span>n=<span class="cstat-no" title="statement not covered" >e.deleted,</span>r=<span class="cstat-no" title="statement not covered" >e.pos;<span class="cstat-no" title="statement not covered" ></span>return n?new Lm(r,r):new $m(r)}</span>,$m.prototype.resolve=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.resolve(this.anchor),</span>n=<span class="cstat-no" title="statement not covered" >e.nodeAfter;<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;Vm.isSelectable(n)?new Vm(e):_m.near(e)}</span>;v</span>ar Fm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e){<span class="cstat-no" title="statement not covered" >t.call(this,e.resolve(0),e.resolve(e.content.size))}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.replace=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(void 0===n&amp;&amp;(n=Hd.empty),n==Hd.empty){<span class="cstat-no" title="statement not covered" >e.delete(0,e.doc.content.size);v</span>ar r=<span class="cstat-no" title="statement not covered" >t.atStart(e.doc);<span class="cstat-no" title="statement not covered" ></span>r.eq(e.selection)||e.setSelection(r)}</span>else <span class="cstat-no" title="statement not covered" >t.prototype.replace.call(this,e,n)}</span></span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{type:"all"}}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new e(t)}</span>,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new e(t)}</span>,e.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof e}</span>,e.prototype.getBookmark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Hm}</span>,e}</span>(_m);<span class="cstat-no" title="statement not covered" ></span>_m.jsonID("all",Fm);v</span>ar Hm=<span class="cstat-no" title="statement not covered" >{map:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,resolve:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Fm(t)}</span>};</span>function <span class="fstat-no" title="function not covered" >qm(</span>t,e,n,r,o,i){<span class="cstat-no" title="statement not covered" >if(e.inlineContent)<span class="cstat-no" title="statement not covered" >return Bm.create(t,n);<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >r-(o&gt;0?0:1);</span>o&gt;0?s&lt;e.childCount:s&gt;=0;s+=o){var a=<span class="cstat-no" title="statement not covered" >e.child(s);<span class="cstat-no" title="statement not covered" ></span>if(a.isAtom){<span class="cstat-no" title="statement not covered" >if(!i&amp;&amp;Vm.isSelectable(a))<span class="cstat-no" title="statement not covered" >return Vm.create(t,n-(o&lt;0?a.nodeSize:0))}</span></span>else{var c=<span class="cstat-no" title="statement not covered" >qm(t,a,n+o,o&lt;0?a.childCount:0,o,i);<span class="cstat-no" title="statement not covered" ></span>if(c)<span class="cstat-no" title="statement not covered" >return c}<span class="cstat-no" title="statement not covered" ></span></span>n</span>+=a.nodeSize*o}</span>}</span>function <span class="fstat-no" title="function not covered" >Jm(</span>t,e,n){var r=<span class="cstat-no" title="statement not covered" >t.steps.length-1;<span class="cstat-no" title="statement not covered" ></span>if(!(r&lt;e)){var o=<span class="cstat-no" title="statement not covered" >t.steps[r];<span class="cstat-no" title="statement not covered" ></span>if(o instanceof fm||o instanceof mm){var i,s=<span class="cstat-no" title="statement not covered" >t.mapping.maps[r];<span class="cstat-no" title="statement not covered" ></span>s.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >null==i&amp;&amp;(i=r)}</span>)),t.setSelection(_m.near(t.doc.resolve(i),n))}</span>}</span>}</span>var Wm=<span class="cstat-no" title="statement not covered" >1,</span>Km=<span class="cstat-no" title="statement not covered" >2,</span>Um=<span class="cstat-no" title="statement not covered" >4,</span>Gm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e){<span class="cstat-no" title="statement not covered" >t.call(this,e.doc),this.time=Date.now(),this.curSelection=e.selection,this.curSelectionFor=0,this.storedMarks=e.storedMarks,this.updated=0,this.meta=Object.create(null)}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{selection:{configurable:!0},selectionSet:{configurable:!0},storedMarksSet:{configurable:!0},isGeneric:{configurable:!0},scrolledIntoView:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return n.selection.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.curSelectionFor&lt;this.steps.length&amp;&amp;(this.curSelection=this.curSelection.map(this.doc,this.mapping.slice(this.curSelectionFor)),this.curSelectionFor=this.steps.length),this.curSelection}</span>,e.prototype.setSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(t.$from.doc!=this.doc)<span class="cstat-no" title="statement not covered" >throw new RangeError("Selection passed to setSelection must point at the current document");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.curSelection=t,this.curSelectionFor=this.steps.length,this.updated=(this.updated|Wm)&amp;~Km,this.storedMarks=null,this}</span>,n.selectionSet.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.updated&amp;Wm)&gt;0}</span>,e.prototype.setStoredMarks=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.storedMarks=t,this.updated|=Km,this}</span>,e.prototype.ensureMarks=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return $d.sameSet(this.storedMarks||this.selection.$from.marks(),t)||this.setStoredMarks(t),this}</span>,e.prototype.addStoredMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.ensureMarks(t.addToSet(this.storedMarks||this.selection.$head.marks()))}</span>,e.prototype.removeStoredMark=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.ensureMarks(t.removeFromSet(this.storedMarks||this.selection.$head.marks()))}</span>,n.storedMarksSet.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.updated&amp;Km)&gt;0}</span>,e.prototype.addStep=<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >t.prototype.addStep.call(this,e,n),this.updated=this.updated&amp;~Km,this.storedMarks=null}</span>,e.prototype.setTime=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.time=t,this}</span>,e.prototype.replaceSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.selection.replace(this,t),this}</span>,e.prototype.replaceSelectionWith=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this.selection;<span class="cstat-no" title="statement not covered" ></span>return!1!==e&amp;&amp;(t=t.mark(this.storedMarks||(n.empty?n.$from.marks():n.$from.marksAcross(n.$to)||$d.none))),n.replaceWith(this,t),this}</span>,e.prototype.deleteSelection=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.selection.replace(this),this}</span>,e.prototype.insertText=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=e);v</span>ar r=<span class="cstat-no" title="statement not covered" >this.doc.type.schema;<span class="cstat-no" title="statement not covered" ></span>if(null==e)<span class="cstat-no" title="statement not covered" >return t?this.replaceSelectionWith(r.text(t),!0):this.deleteSelection();<span class="cstat-no" title="statement not covered" >i</span></span>f(!t)<span class="cstat-no" title="statement not covered" >return this.deleteRange(e,n);v</span></span>ar o=<span class="cstat-no" title="statement not covered" >this.storedMarks;<span class="cstat-no" title="statement not covered" ></span>if(!o){var i=<span class="cstat-no" title="statement not covered" >this.doc.resolve(e);<span class="cstat-no" title="statement not covered" ></span>o=n==e?i.marks():i.marksAcross(this.doc.resolve(n))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.replaceRangeWith(e,n,r.text(t,o)),this.selection.empty||this.setSelection(_m.near(this.selection.$to)),this}</span>,e.prototype.setMeta=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return this.meta["string"==typeof t?t:t.key]=e,this}</span>,e.prototype.getMeta=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.meta["string"==typeof t?t:t.key]}</span>,n.isGeneric.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t in this.meta)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!0}</span>,e.prototype.scrollIntoView=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.updated|=Um,this}</span>,n.scrolledIntoView.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(this.updated&amp;Um)&gt;0}</span>,Object.defineProperties(e.prototype,n),e}</span>(cm);</span>function <span class="fstat-no" title="function not covered" >Ym(</span>t,e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;t?t.bind(e):t}</span>var Xm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >this.name=t,this.init=Ym(e.init,n),this.apply=Ym(e.apply,n)}</span>,</span>Qm=<span class="cstat-no" title="statement not covered" >[new Xm("doc",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.doc||t.schema.topNodeType.createAndFill()}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.doc}</span>}),new Xm("selection",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.selection||_m.atStart(e.doc)}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.selection}</span>}),new Xm("storedMarks",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.storedMarks||null}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >return r.selection.$cursor?t.storedMarks:null}</span>}),new Xm("scrollToSelection",{init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 0}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.scrolledIntoView?e+1:e}</span>})],</span>Zm=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.schema=t,this.fields=Qm.concat(),this.plugins=[],this.pluginsByKey=Object.create(null),e&amp;&amp;e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(n.pluginsByKey[t.key])<span class="cstat-no" title="statement not covered" >throw new RangeError("Adding different instances of a keyed plugin ("+t.key+")");<span class="cstat-no" title="statement not covered" >n</span></span>.plugins.push(t),n.pluginsByKey[t.key]=t,t.spec.state&amp;&amp;n.fields.push(new Xm(t.key,t.spec.state,t))}</span>))}</span>,</span>tv=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.config=t}</span>,</span>ev=<span class="cstat-no" title="statement not covered" >{schema:{configurable:!0},plugins:{configurable:!0},tr:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>ev.schema.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.config.schema}</span>,ev.plugins.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.config.plugins}</span>,tv.prototype.apply=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.applyTransaction(t).state}</span>,tv.prototype.filterTransaction=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=-1);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.config.plugins.length;n++)<span class="cstat-no" title="statement not covered" >if(n!=e){var r=<span class="cstat-no" title="statement not covered" >this.config.plugins[n];<span class="cstat-no" title="statement not covered" ></span>if(r.spec.filterTransaction&amp;&amp;!r.spec.filterTransaction.call(r,t,this))<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn!0}</span>,tv.prototype.applyTransaction=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!this.filterTransaction(t))<span class="cstat-no" title="statement not covered" >return{state:this,transactions:[]};<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >[t],</span>n=<span class="cstat-no" title="statement not covered" >this.applyInner(t),</span>r=<span class="cstat-no" title="statement not covered" >null;</span>;){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.config.plugins.length;i++){var s=<span class="cstat-no" title="statement not covered" >this.config.plugins[i];<span class="cstat-no" title="statement not covered" ></span>if(s.spec.appendTransaction){var a=<span class="cstat-no" title="statement not covered" >r?r[i].n:0,</span>c=<span class="cstat-no" title="statement not covered" >r?r[i].state:this,</span>l=<span class="cstat-no" title="statement not covered" >a&lt;e.length&amp;&amp;s.spec.appendTransaction.call(s,a?e.slice(a):e,c,n);<span class="cstat-no" title="statement not covered" ></span>if(l&amp;&amp;n.filterTransaction(l,i)){<span class="cstat-no" title="statement not covered" >if(l.setMeta("appendedTransaction",t),!r){<span class="cstat-no" title="statement not covered" >r=[];<span class="cstat-no" title="statement not covered" >f</span>or(var p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;this.config.plugins.length;p++)<span class="cstat-no" title="statement not covered" >r.push(p&lt;i?{state:n,n:e.length}:{state:this,n:0})}<span class="cstat-no" title="statement not covered" ></span></span>e</span>.push(l),n=n.applyInner(l),o=!0}<span class="cstat-no" title="statement not covered" ></span>r</span>&amp;&amp;(r[i]={state:n,n:e.length})}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!o)<span class="cstat-no" title="statement not covered" >return{state:n,transactions:e}}</span></span>}</span>,tv.prototype.applyInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t.before.eq(this.doc))<span class="cstat-no" title="statement not covered" >throw new RangeError("Applying a mismatched transaction");<span class="cstat-no" title="statement not covered" >f</span></span>or(var e=<span class="cstat-no" title="statement not covered" >new tv(this.config),</span>n=<span class="cstat-no" title="statement not covered" >this.config.fields,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;n.length;r++){var o=<span class="cstat-no" title="statement not covered" >n[r];<span class="cstat-no" title="statement not covered" ></span>e[o.name]=o.apply(t,this[o.name],this,e)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;nv.length;i++)<span class="cstat-no" title="statement not covered" >nv[i](this,t,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,ev.tr.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Gm(this)}</span>,tv.create=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >new Zm(t.doc?t.doc.type.schema:t.schema,t.plugins),</span>n=<span class="cstat-no" title="statement not covered" >new tv(e),</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.fields.length;r++)<span class="cstat-no" title="statement not covered" >n[e.fields[r].name]=e.fields[r].init(t,n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>,tv.prototype.reconfigure=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >new Zm(this.schema,t.plugins),</span>n=<span class="cstat-no" title="statement not covered" >e.fields,</span>r=<span class="cstat-no" title="statement not covered" >new tv(e),</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n.length;o++){var i=<span class="cstat-no" title="statement not covered" >n[o].name;<span class="cstat-no" title="statement not covered" ></span>r[i]=this.hasOwnProperty(i)?this[i]:n[o].init(t,r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>,tv.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >{doc:this.doc.toJSON(),selection:this.selection.toJSON()};<span class="cstat-no" title="statement not covered" ></span>if(this.storedMarks&amp;&amp;(e.storedMarks=this.storedMarks.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.toJSON()}</span>))),t&amp;&amp;"object"==typeof t)<span class="cstat-no" title="statement not covered" >for(var n in t){<span class="cstat-no" title="statement not covered" >if("doc"==n||"selection"==n)<span class="cstat-no" title="statement not covered" >throw new RangeError("The JSON fields `doc` and `selection` are reserved");v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t[n],</span>o=<span class="cstat-no" title="statement not covered" >r.spec.state;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;o.toJSON&amp;&amp;(e[n]=o.toJSON.call(r,this[r.key]))}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>,tv.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for EditorState.fromJSON");<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.schema)<span class="cstat-no" title="statement not covered" >throw new RangeError("Required config field 'schema' missing");v</span></span>ar r=<span class="cstat-no" title="statement not covered" >new Zm(t.schema,t.plugins),</span>o=<span class="cstat-no" title="statement not covered" >new tv(r);<span class="cstat-no" title="statement not covered" ></span>return r.fields.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >if("doc"==r.name)<span class="cstat-no" title="statement not covered" >o.doc=hf.fromJSON(t.schema,e.doc);e</span>lse <span class="cstat-no" title="statement not covered" >if("selection"==r.name)<span class="cstat-no" title="statement not covered" >o.selection=_m.fromJSON(o.doc,e.selection);e</span>lse <span class="cstat-no" title="statement not covered" >if("storedMarks"==r.name)<span class="cstat-no" title="statement not covered" >e.storedMarks&amp;&amp;(o.storedMarks=e.storedMarks.map(t.schema.markFromJSON));e</span>lse{<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >for(var i in n){var s=<span class="cstat-no" title="statement not covered" >n[i],</span>a=<span class="cstat-no" title="statement not covered" >s.spec.state;<span class="cstat-no" title="statement not covered" ></span>if(s.key==r.name&amp;&amp;a&amp;&amp;a.fromJSON&amp;&amp;Object.prototype.hasOwnProperty.call(e,i))<span class="cstat-no" title="statement not covered" >return void(o[r.name]=a.fromJSON.call(s,t,e[i],o))}<span class="cstat-no" title="statement not covered" ></span></span>o</span></span>[r.name]=r.init(t,o)}</span>}</span></span></span>)),o}</span>,tv.addApplyListener=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >nv.push(t)}</span>,tv.removeApplyListener=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >nv.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>e&gt;-1&amp;&amp;nv.splice(e,1)}</span>,Object.defineProperties(tv.prototype,ev);v</span>ar nv=<span class="cstat-no" title="statement not covered" >[];</span>function <span class="fstat-no" title="function not covered" >rv(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(var r in t){var o=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>o instanceof Function?o=o.bind(e):"handleDOMEvents"==r&amp;&amp;(o=rv(o,e,{})),n[r]=o}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>var ov=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.props={},t.props&amp;&amp;rv(t.props,this,this.props),this.spec=t,this.key=t.key?t.key.key:sv("plugin")}</span>;<span class="cstat-no" title="statement not covered" ></span>ov.prototype.getState=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t[this.key]}</span>;v</span>ar iv=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>function <span class="fstat-no" title="function not covered" >sv(</span>t){<span class="cstat-no" title="statement not covered" >return t in iv?t+"$"+ ++iv[t]:(iv[t]=0,t+"$")}</span>var av=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >void 0===t&amp;&amp;(t="key"),this.key=sv(t)}</span>;<span class="cstat-no" title="statement not covered" ></span>av.prototype.get=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.config.pluginsByKey[this.key]}</span>,av.prototype.getState=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t[this.key]}</span>;c</span>onst cv=<span class="cstat-no" title="statement not covered" >new av("characterLimit"),</span>lv=<span class="cstat-no" title="statement not covered" >Qp.create({name:"characterCount",defaultOptions:{limit:0},<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){const{options:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return[new ov({key:cv,appendTransaction:<span class="fstat-no" title="function not covered" >(e</span>,n,r)=&gt;{const o=<span class="cstat-no" title="statement not covered" >r.doc.content.size;<span class="cstat-no" title="statement not covered" ></span>if(t.limit&amp;&amp;o&gt;t.limit)<span class="cstat-no" title="statement not covered" >return r.tr.insertText("",t.limit+1,o)}</span></span>})]}</span>});</span>var pv=<span class="cstat-no" title="statement not covered" >lv;</span>function <span class="fstat-no" title="function not covered" >uv(</span>t){const{char:e,allowSpaces:n,prefixSpace:r,startOfLine:o,$position:i}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" >e.split("").map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"\\"+t)</span>.join(""),</span>a=<span class="cstat-no" title="statement not covered" >new RegExp(`\\s${s}$`),</span>c=<span class="cstat-no" title="statement not covered" >o?"^":"",</span>l=<span class="cstat-no" title="statement not covered" >n?new RegExp(`${c}${s}.*?(?=\\s${s}|$)`,"gm"):new RegExp(`${c}(?:^)?${s}[^\\s${s}]*`,"gm"),</span>p=<span class="cstat-no" title="statement not covered" >i.depth&lt;=0,</span>u=<span class="cstat-no" title="statement not covered" >p?0:i.before(),</span>h=<span class="cstat-no" title="statement not covered" >i.pos,</span>d=<span class="cstat-no" title="statement not covered" >i.doc.textBetween(u,h,"\0","\0"),</span>f=<span class="cstat-no" title="statement not covered" >Array.from(d.matchAll(l)).pop();<span class="cstat-no" title="statement not covered" ></span>if(!f||void 0===f.input||void 0===f.index)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst m=<span class="cstat-no" title="statement not covered" >f.input.slice(Math.max(0,f.index-1),f.index),</span>v=<span class="cstat-no" title="statement not covered" >/^[\s\0]?$/.test(m);<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;!v)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst g=<span class="cstat-no" title="statement not covered" >f.index+i.start();</span>let y=<span class="cstat-no" title="statement not covered" >g+f[0].length;<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;a.test(d.slice(y-1,y+1))&amp;&amp;(f[0]+=" ",y+=1),g&lt;i.pos&amp;&amp;y&gt;=i.pos?{range:{from:g,to:y},query:f[0].slice(e.length),text:f[0]}:null}</span>const hv=<span class="cstat-no" title="statement not covered" >new vi("suggestion");</span>function <span class="fstat-no" title="function not covered" >dv(</span>{pluginKey:t=<span class="branch-0 cbranch-no" title="branch not covered" >hv,</span>editor:e,char:n=<span class="branch-0 cbranch-no" title="branch not covered" >"@",</span>allowSpaces:r=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>prefixSpace:o=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>startOfLine:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>decorationTag:s=<span class="branch-0 cbranch-no" title="branch not covered" >"span",</span>decorationClass:a=<span class="branch-0 cbranch-no" title="branch not covered" >"suggestion",</span>command:c=(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null)</span></span>,items:l=(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[])</span></span>,render:p=(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{})</span>)</span>,allow:u=(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!0)</span></span>}){const h=<span class="cstat-no" title="statement not covered" >null===p||void 0===p?void 0:p();<span class="cstat-no" title="statement not covered" ></span>return new di({key:t,<span class="fstat-no" title="function not covered" >vi</span>ew(){<span class="cstat-no" title="statement not covered" >return{update:<span class="fstat-no" title="function not covered" >as</span>ync(t,n)=&gt;{var r,o,i,s,a;const p=<span class="cstat-no" title="statement not covered" >null===(r=this.key)||void 0===r?void 0:r.getState(n),</span>u=<span class="cstat-no" title="statement not covered" >null===(o=this.key)||void 0===o?void 0:o.getState(t.state),</span>d=<span class="cstat-no" title="statement not covered" >p.active&amp;&amp;u.active&amp;&amp;p.range.from!==u.range.from,</span>f=<span class="cstat-no" title="statement not covered" >!p.active&amp;&amp;u.active,</span>m=<span class="cstat-no" title="statement not covered" >p.active&amp;&amp;!u.active,</span>v=<span class="cstat-no" title="statement not covered" >!f&amp;&amp;!m&amp;&amp;p.query!==u.query,</span>g=<span class="cstat-no" title="statement not covered" >f||d,</span>y=<span class="cstat-no" title="statement not covered" >v&amp;&amp;!d,</span>b=<span class="cstat-no" title="statement not covered" >m||d;<span class="cstat-no" title="statement not covered" ></span>if(!g&amp;&amp;!y&amp;&amp;!b)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst w=<span class="cstat-no" title="statement not covered" >b&amp;&amp;!g?p:u,</span>O=<span class="cstat-no" title="statement not covered" >document.querySelector(`[data-decoration-id="${w.decorationId}"]`),</span>k=<span class="cstat-no" title="statement not covered" >{editor:e,range:w.range,query:w.query,text:w.text,items:y||g?await l(w.query):[],command:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >c({editor:e,range:w.range,props:t})}</span>,decorationNode:O,clientRect:O?<span class="fstat-no" title="function not covered" >()</span>=&gt;{var t;const{decorationId:n}=<span class="cstat-no" title="statement not covered" >null===(t=this.key)||void 0===t?void 0:t.getState(e.state),</span>r=<span class="cstat-no" title="statement not covered" >document.querySelector(`[data-decoration-id="${n}"]`);<span class="cstat-no" title="statement not covered" ></span>return r.getBoundingClientRect()}</span>:null};<span class="cstat-no" title="statement not covered" ></span>b&amp;&amp;(null===(i=null===h||void 0===h?void 0:h.onExit)||void 0===i||i.call(h,k)),y&amp;&amp;(null===(s=null===h||void 0===h?void 0:h.onUpdate)||void 0===s||s.call(h,k)),g&amp;&amp;(null===(a=null===h||void 0===h?void 0:h.onStart)||void 0===a||a.call(h,k))}</span>}}</span>,state:{<span class="fstat-no" title="function not covered" >in</span>it(){<span class="cstat-no" title="statement not covered" >return{active:!1,range:{},query:null,text:null,composing:!1}}</span>,<span class="fstat-no" title="function not covered" >ap</span>ply(t,s){const{composing:a}=<span class="cstat-no" title="statement not covered" >e.view,</span>{selection:c}=<span class="cstat-no" title="statement not covered" >t,</span>{empty:l,from:p}=<span class="cstat-no" title="statement not covered" >c,</span>h=<span class="cstat-no" title="statement not covered" >{...s};<span class="cstat-no" title="statement not covered" ></span>if(h.composing=a,l||e.view.composing){<span class="cstat-no" title="statement not covered" >!(p&lt;s.range.from||p&gt;s.range.to)||a||s.composing||(h.active=!1);c</span>onst t=<span class="cstat-no" title="statement not covered" >uv({char:n,allowSpaces:r,prefixSpace:o,startOfLine:i,$position:c.$from}),</span>l=<span class="cstat-no" title="statement not covered" >"id_"+Math.floor(4294967295*Math.random());<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;u({editor:e,range:t.range})?(h.active=!0,h.decorationId=s.decorationId?s.decorationId:l,h.range=t.range,h.query=t.query,h.text=t.text):h.active=!1}</span>else <span class="cstat-no" title="statement not covered" >h.active=!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn h.active||(h.decorationId=null,h.range={},h.query=null,h.text=null),h}</span>},props:{<span class="fstat-no" title="function not covered" >ha</span>ndleKeyDown(t,e){var n;const{active:r,range:o}=<span class="cstat-no" title="statement not covered" >this.getState(t.state);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(null===(n=null===h||void 0===h?void 0:h.onKeyDown)||void 0===n?void 0:n.call(h,{view:t,event:e,range:o}))||!1}</span>,<span class="fstat-no" title="function not covered" >de</span>corations(t){const{active:e,range:n,decorationId:r}=<span class="cstat-no" title="statement not covered" >this.getState(t);<span class="cstat-no" title="statement not covered" ></span>return e?Lc.create(t.doc,[_c.inline(n.from,n.to,{nodeName:s,class:a,"data-decoration-id":r})]):null}</span>}})}</span>const fv=<span class="cstat-no" title="statement not covered" >new vi("mention"),</span>mv=<span class="cstat-no" title="statement not covered" >hd.create({name:"mention",defaultOptions:{HTMLAttributes:{},<span class="fstat-no" title="function not covered" >re</span>nderLabel({options:t,node:e}){var n;<span class="cstat-no" title="statement not covered" >return`${t.suggestion.char}${null!==(n=e.attrs.label)&amp;&amp;void 0!==n?n:e.attrs.id}`}</span>,suggestion:{char:"@",pluginKey:fv,command:<span class="fstat-no" title="function not covered" >({</span>editor:t,range:e,props:n})=&gt;{var r;const o=<span class="cstat-no" title="statement not covered" >t.view.state.selection.$to.nodeAfter,</span>i=<span class="cstat-no" title="statement not covered" >null===(r=null===o||void 0===o?void 0:o.text)||void 0===r?void 0:r.startsWith(" ");<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(e.to+=1),t.chain().focus().insertContentAt(e,[{type:"mention",attrs:n},{type:"text",text:" "}]).run()}</span>,allow:<span class="fstat-no" title="function not covered" >({</span>editor:t,range:e})=&gt;<span class="cstat-no" title="statement not covered" >t.can().insertContentAt(e,{type:"mention"})}</span>},group:"inline",inline:!0,selectable:!1,atom:!0,<span class="fstat-no" title="function not covered" >ad</span>dAttributes(){<span class="cstat-no" title="statement not covered" >return{id:{default:null,parseHTML:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.getAttribute("data-id"),</span>renderHTML:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.id?{"data-id":t.id}:{}}</span>,label:{default:null,parseHTML:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.getAttribute("data-label"),</span>renderHTML:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.label?{"data-label":t.label}:{}}</span>}}</span>,<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"span[data-mention]"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({node:t,HTMLAttributes:e}){<span class="cstat-no" title="statement not covered" >return["span",Pp({"data-mention":""},this.options.HTMLAttributes,e),this.options.renderLabel({options:this.options,node:t})]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderText({node:t}){<span class="cstat-no" title="statement not covered" >return this.options.renderLabel({options:this.options,node:t})}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{Backspace:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.command(<span class="fstat-no" title="function not covered" >({</span>tr:t,state:e})=&gt;{let n=<span class="cstat-no" title="statement not covered" >!1;</span>const{selection:r}=<span class="cstat-no" title="statement not covered" >e,</span>{empty:o,anchor:i}=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>return!!o&amp;&amp;(e.doc.nodesBetween(i-1,i,<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(e.type.name===this.name)<span class="cstat-no" title="statement not covered" >return n=!0,t.insertText(this.options.suggestion.char||"",r,r+e.nodeSize),!1}</span></span>),n)}</span>)}</span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){<span class="cstat-no" title="statement not covered" >return[dv({editor:this.editor,...this.options.suggestion})]}</span>}),</span>vv=<span class="cstat-no" title="statement not covered" >/^\s*&gt;\s$/gm,</span>gv=<span class="cstat-no" title="statement not covered" >hd.create({name:"blockquote",defaultOptions:{HTMLAttributes:{}},content:"block*",group:"block",defining:!0,<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"blockquote"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["blockquote",Pp(this.options.HTMLAttributes,t),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setBlockquote:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.wrapIn("blockquote"),</span></span>toggleBlockquote:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.toggleWrap("blockquote"),</span></span>unsetBlockquote:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.lift("blockquote")}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-Shift-b":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.toggleBlockquote()}</span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return[jl(vv,this.type)]}</span>});</span>var yv=<span class="cstat-no" title="statement not covered" >gv;</span>const bv=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/gm,</span>wv=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/gm,</span>Ov=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:__)((?:[^__]+))(?:__))$/gm,</span>kv=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:__)((?:[^__]+))(?:__))/gm,</span>xv=<span class="cstat-no" title="statement not covered" >dd.create({name:"bold",defaultOptions:{HTMLAttributes:{}},<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"strong"},{tag:"b",getAttrs:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"normal"!==t.style.fontWeight&amp;&amp;null}</span>,{style:"font-weight",getAttrs:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >/^(bold(er)?|[5-9]\d{2,})$/.test(t)&amp;&amp;null}</span>]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["strong",Pp(this.options.HTMLAttributes,t),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setBold:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.setMark("bold"),</span></span>toggleBold:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.toggleMark("bold"),</span></span>unsetBold:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.unsetMark("bold")}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-b":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.toggleBold()}</span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return[vd(bv,this.type),vd(Ov,this.type)]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dPasteRules(){<span class="cstat-no" title="statement not covered" >return[gd(wv,this.type),gd(kv,this.type)]}</span>});</span>var Sv=<span class="cstat-no" title="statement not covered" >xv;</span>const Mv=<span class="cstat-no" title="statement not covered" >/^\s*([-+*])\s$/,</span>Cv=<span class="cstat-no" title="statement not covered" >hd.create({name:"bulletList",defaultOptions:{HTMLAttributes:{}},group:"block list",content:"listItem+",<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"ul"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["ul",Pp(this.options.HTMLAttributes,t),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{toggleBulletList:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.toggleList("bulletList","listItem")}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-Shift-8":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.toggleBulletList()}</span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return[jl(Mv,this.type)]}</span>});</span>var Ev=<span class="cstat-no" title="statement not covered" >Cv;</span>const Tv=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:`)((?:[^`]+))(?:`))$/gm,</span>Nv=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:`)((?:[^`]+))(?:`))/gm,</span>jv=<span class="cstat-no" title="statement not covered" >dd.create({name:"code",defaultOptions:{HTMLAttributes:{}},excludes:"_",<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"code"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["code",Pp(this.options.HTMLAttributes,t),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setCode:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.setMark("code"),</span></span>toggleCode:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.toggleMark("code"),</span></span>unsetCode:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.unsetMark("code")}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-e":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.toggleCode()}</span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return[vd(Tv,this.type)]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dPasteRules(){<span class="cstat-no" title="statement not covered" >return[gd(Nv,this.type)]}</span>}),</span>Av=<span class="cstat-no" title="statement not covered" >/^```(?&lt;language&gt;[a-z]*)? $/,</span>Iv=<span class="cstat-no" title="statement not covered" >/^~~~(?&lt;language&gt;[a-z]*)? $/,</span>Dv=<span class="cstat-no" title="statement not covered" >hd.create({name:"codeBlock",defaultOptions:{languageClassPrefix:"language-",HTMLAttributes:{}},content:"text*",marks:"",group:"block",code:!0,defining:!0,<span class="fstat-no" title="function not covered" >ad</span>dAttributes(){<span class="cstat-no" title="statement not covered" >return{language:{default:null,parseHTML:<span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;const{languageClassPrefix:n}=<span class="cstat-no" title="statement not covered" >this.options,</span>r=<span class="cstat-no" title="statement not covered" >[...(null===(e=t.firstElementChild)||void 0===e?void 0:e.classList)||[]],</span>o=<span class="cstat-no" title="statement not covered" >r.filter(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.startsWith(n))</span>.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.replace(n,""))</span>,</span>i=<span class="cstat-no" title="statement not covered" >o[0];<span class="cstat-no" title="statement not covered" ></span>return i||null}</span>,renderHTML:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.language?{class:this.options.languageClassPrefix+t.language}:null}</span>}}</span>,<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"pre",preserveWhitespace:"full"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["pre",this.options.HTMLAttributes,["code",t,0]]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setCodeBlock:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:e})=&gt;<span class="cstat-no" title="statement not covered" >e.setNode("codeBlock",t),</span></span>toggleCodeBlock:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:e})=&gt;<span class="cstat-no" title="statement not covered" >e.toggleNode("codeBlock","paragraph",t)}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-Alt-c":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.toggleCodeBlock(),</span>Backspace:<span class="fstat-no" title="function not covered" >()</span>=&gt;{const{empty:t,$anchor:e}=<span class="cstat-no" title="statement not covered" >this.editor.state.selection,</span>n=<span class="cstat-no" title="statement not covered" >1===e.pos;<span class="cstat-no" title="statement not covered" ></span>return!(!t||e.parent.type.name!==this.name)&amp;&amp;(!(!n&amp;&amp;e.parent.textContent.length)&amp;&amp;this.editor.commands.clearNodes())}</span>}}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return[Al(Av,this.type,<span class="fstat-no" title="function not covered" >({</span>groups:t})=&gt;<span class="cstat-no" title="statement not covered" >t)</span>,Al(Iv,this.type,<span class="fstat-no" title="function not covered" >({</span>groups:t})=&gt;<span class="cstat-no" title="statement not covered" >t)</span>]}</span>});</span>function <span class="fstat-no" title="function not covered" >Rv(</span>t){<span class="cstat-no" title="statement not covered" >return void 0===t&amp;&amp;(t={}),new di({view:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return new _v(e,t)}</span>})}</span>var _v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.editorView=t,this.width=e.width||1,this.color=e.color||"black",this.class=e.class,this.cursorPos=null,this.element=null,this.timeout=null,this.handlers=["dragover","dragend","drop","dragleave"].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n[e](t)}</span>;<span class="cstat-no" title="statement not covered" ></span>return t.dom.addEventListener(e,r),{name:e,handler:r}}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>_v.prototype.destroy=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.handlers.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >e.name,</span>r=<span class="cstat-no" title="statement not covered" >e.handler;<span class="cstat-no" title="statement not covered" ></span>return t.editorView.dom.removeEventListener(n,r)}</span>))}</span>,_v.prototype.update=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >null!=this.cursorPos&amp;&amp;e.doc!=t.state.doc&amp;&amp;(this.cursorPos&gt;t.state.doc.content.size?this.setCursor(null):this.updateOverlay())}</span>,_v.prototype.setCursor=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t!=this.cursorPos&amp;&amp;(this.cursorPos=t,null==t?(this.element.parentNode.removeChild(this.element),this.element=null):this.updateOverlay())}</span>,_v.prototype.updateOverlay=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e=<span class="cstat-no" title="statement not covered" >this.editorView.state.doc.resolve(this.cursorPos);<span class="cstat-no" title="statement not covered" ></span>if(!e.parent.inlineContent){var n=<span class="cstat-no" title="statement not covered" >e.nodeBefore,</span>r=<span class="cstat-no" title="statement not covered" >e.nodeAfter;<span class="cstat-no" title="statement not covered" ></span>if(n||r){var o=<span class="cstat-no" title="statement not covered" >this.editorView.nodeDOM(this.cursorPos-(n?n.nodeSize:0)).getBoundingClientRect(),</span>i=<span class="cstat-no" title="statement not covered" >n?o.bottom:o.top;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;r&amp;&amp;(i=(i+this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top)/2),t={left:o.left,right:o.right,top:i-this.width/2,bottom:i+this.width/2}}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!t){var s=<span class="cstat-no" title="statement not covered" >this.editorView.coordsAtPos(this.cursorPos);<span class="cstat-no" title="statement not covered" ></span>t={left:s.left-this.width/2,right:s.left+this.width/2,top:s.top,bottom:s.bottom}}</span>v</span>ar a,c,l=<span class="cstat-no" title="statement not covered" >this.editorView.dom.offsetParent;<span class="cstat-no" title="statement not covered" ></span>if(this.element||(this.element=l.appendChild(document.createElement("div")),this.class&amp;&amp;(this.element.className=this.class),this.element.style.cssText="position: absolute; z-index: 50; pointer-events: none; background-color: "+this.color),!l||l==document.body&amp;&amp;"static"==getComputedStyle(l).position)<span class="cstat-no" title="statement not covered" >a=-pageXOffset,c=-pageYOffset;e</span>lse{var p=<span class="cstat-no" title="statement not covered" >l.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>a=p.left-l.scrollLeft,c=p.top-l.scrollTop}<span class="cstat-no" title="statement not covered" ></span>t</span>his.element.style.left=t.left-a+"px",this.element.style.top=t.top-c+"px",this.element.style.width=t.right-t.left+"px",this.element.style.height=t.bottom-t.top+"px"}</span>,_v.prototype.scheduleRemoval=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>clearTimeout(this.timeout),this.timeout=setTimeout((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e.setCursor(null)}</span>),t)}</span>,_v.prototype.dragover=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.editorView.editable){var e=<span class="cstat-no" title="statement not covered" >this.editorView.posAtCoords({left:t.clientX,top:t.clientY});<span class="cstat-no" title="statement not covered" ></span>if(e){var n=<span class="cstat-no" title="statement not covered" >e.pos;<span class="cstat-no" title="statement not covered" ></span>if(this.editorView.dragging&amp;&amp;this.editorView.dragging.slice&amp;&amp;(n=Eo(this.editorView.state.doc,n,this.editorView.dragging.slice),null==n))<span class="cstat-no" title="statement not covered" >return this.setCursor(null);<span class="cstat-no" title="statement not covered" >t</span></span>his.setCursor(n),this.scheduleRemoval(5e3)}</span>}</span>}</span>,_v.prototype.dragend=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.scheduleRemoval(20)}</span>,_v.prototype.drop=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >this.scheduleRemoval(20)}</span>,_v.prototype.dragleave=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.target!=this.editorView.dom&amp;&amp;this.editorView.dom.contains(t.relatedTarget)||this.setCursor(null)}</span>;c</span>onst Pv=<span class="cstat-no" title="statement not covered" >Qp.create({name:"dropCursor",defaultOptions:{color:"currentColor",width:1,class:null},<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){<span class="cstat-no" title="statement not covered" >return[Rv(this.options)]}</span>});</span>var zv=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e){<span class="cstat-no" title="statement not covered" >t.call(this,e,e)}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){var o=<span class="cstat-no" title="statement not covered" >n.resolve(r.map(this.head));<span class="cstat-no" title="statement not covered" ></span>return e.valid(o)?new e(o):t.near(o)}</span>,e.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Dn.empty}</span>,e.prototype.eq=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof e&amp;&amp;t.head==this.head}</span>,e.prototype.toJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{type:"gapcursor",pos:this.head}}</span>,e.fromJSON=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if("number"!=typeof n.pos)<span class="cstat-no" title="statement not covered" >throw new RangeError("Invalid input for GapCursor.fromJSON");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new e(t.resolve(n.pos))}</span>,e.prototype.getBookmark=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new Bv(this.anchor)}</span>,e.valid=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.parent;<span class="cstat-no" title="statement not covered" ></span>if(e.isTextblock||!Lv(t)||!Vv(t))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e.type.spec.allowGapCursor;<span class="cstat-no" title="statement not covered" ></span>if(null!=n)<span class="cstat-no" title="statement not covered" >return n;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >e.contentMatchAt(t.index()).defaultType;<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;r.isTextblock}</span>,e.findFrom=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,r){<span class="cstat-no" title="statement not covered" >t:<span class="cstat-no" title="statement not covered" >for(;;){<span class="cstat-no" title="statement not covered" >if(!r&amp;&amp;e.valid(t))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >t.pos,</span>i=<span class="cstat-no" title="statement not covered" >null,</span>s=<span class="cstat-no" title="statement not covered" >t.depth;</span>;s--){var a=<span class="cstat-no" title="statement not covered" >t.node(s);<span class="cstat-no" title="statement not covered" ></span>if(n&gt;0?t.indexAfter(s)&lt;a.childCount:t.index(s)&gt;0){<span class="cstat-no" title="statement not covered" >i=a.child(n&gt;0?t.indexAfter(s):t.index(s)-1);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0==s)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >o</span></span>+=n;v</span>ar c=<span class="cstat-no" title="statement not covered" >t.doc.resolve(o);<span class="cstat-no" title="statement not covered" ></span>if(e.valid(c))<span class="cstat-no" title="statement not covered" >return c}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(;;){var l=<span class="cstat-no" title="statement not covered" >n&gt;0?i.firstChild:i.lastChild;<span class="cstat-no" title="statement not covered" ></span>if(!l){<span class="cstat-no" title="statement not covered" >if(i.isAtom&amp;&amp;!i.isText&amp;&amp;!Go.isSelectable(i)){<span class="cstat-no" title="statement not covered" >t=t.doc.resolve(o+i.nodeSize*n),r=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue t}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>=l,o+=n;v</span>ar p=<span class="cstat-no" title="statement not covered" >t.doc.resolve(o);<span class="cstat-no" title="statement not covered" ></span>if(e.valid(p))<span class="cstat-no" title="statement not covered" >return p}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>}</span></span>,e}</span>(qo);<span class="cstat-no" title="statement not covered" ></span>zv.prototype.visible=!1,qo.jsonID("gapcursor",zv);v</span>ar Bv=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this.pos=t}</span>;</span>function <span class="fstat-no" title="function not covered" >Lv(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.depth;</span>e&gt;=0;e--){var n=<span class="cstat-no" title="statement not covered" >t.index(e);<span class="cstat-no" title="statement not covered" ></span>if(0!=n)<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >t.node(e).child(n-1);</span>;r=r.lastChild){<span class="cstat-no" title="statement not covered" >if(0==r.childCount&amp;&amp;!r.inlineContent||r.isAtom||r.type.spec.isolating)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(r.inlineContent)<span class="cstat-no" title="statement not covered" >return!1}</span></span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >Vv(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.depth;</span>e&gt;=0;e--){var n=<span class="cstat-no" title="statement not covered" >t.indexAfter(e),</span>r=<span class="cstat-no" title="statement not covered" >t.node(e);<span class="cstat-no" title="statement not covered" ></span>if(n!=r.childCount)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >r.child(n);</span>;o=o.firstChild){<span class="cstat-no" title="statement not covered" >if(0==o.childCount&amp;&amp;!o.inlineContent||o.isAtom||o.type.spec.isolating)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.inlineContent)<span class="cstat-no" title="statement not covered" >return!1}</span></span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}<span class="cstat-no" title="statement not covered" ></span>Bv.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Bv(t.map(this.pos))}</span>,Bv.prototype.resolve=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.resolve(this.pos);<span class="cstat-no" title="statement not covered" ></span>return zv.valid(e)?new zv(e):qo.near(e)}</span>;v</span>ar $v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new di({props:{decorations:Jv,createSelectionBetween:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >if(e.pos==n.pos&amp;&amp;zv.valid(n))<span class="cstat-no" title="statement not covered" >return new zv(n)}</span></span>,handleClick:qv,handleKeyDown:Fv}})}</span>,</span>Fv=<span class="cstat-no" title="statement not covered" >xl({ArrowLeft:Hv("horiz",-1),ArrowRight:Hv("horiz",1),ArrowUp:Hv("vert",-1),ArrowDown:Hv("vert",1)});</span>function <span class="fstat-no" title="function not covered" >Hv(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >"vert"==t?e&gt;0?"down":"up":e&gt;0?"right":"left";<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,r,o){var i=<span class="cstat-no" title="statement not covered" >t.selection,</span>s=<span class="cstat-no" title="statement not covered" >e&gt;0?i.$to:i.$from,</span>a=<span class="cstat-no" title="statement not covered" >i.empty;<span class="cstat-no" title="statement not covered" ></span>if(i instanceof Ko){<span class="cstat-no" title="statement not covered" >if(!o.endOfTextblock(n)||0==s.depth)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >a</span></span>=!1,s=t.doc.resolve(e&gt;0?s.after():s.before())}</span>v</span>ar c=<span class="cstat-no" title="statement not covered" >zv.findFrom(s,e,a);<span class="cstat-no" title="statement not covered" ></span>return!!c&amp;&amp;(r&amp;&amp;r(t.tr.setSelection(new zv(c))),!0)}</span>}</span>function <span class="fstat-no" title="function not covered" >qv(</span>t,e,n){<span class="cstat-no" title="statement not covered" >if(!t.editable)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar r=<span class="cstat-no" title="statement not covered" >t.state.doc.resolve(e);<span class="cstat-no" title="statement not covered" ></span>if(!zv.valid(r))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t.posAtCoords({left:n.clientX,top:n.clientY}),</span>i=<span class="cstat-no" title="statement not covered" >o.inside;<span class="cstat-no" title="statement not covered" ></span>return!(i&gt;-1&amp;&amp;Go.isSelectable(t.state.doc.nodeAt(i)))&amp;&amp;(t.dispatch(t.state.tr.setSelection(new zv(r))),!0)}</span>function <span class="fstat-no" title="function not covered" >Jv(</span>t){<span class="cstat-no" title="statement not covered" >if(!(t.selection instanceof zv))<span class="cstat-no" title="statement not covered" >return null;v</span></span>ar e=<span class="cstat-no" title="statement not covered" >document.createElement("div");<span class="cstat-no" title="statement not covered" ></span>return e.className="ProseMirror-gapcursor",Lc.create(t.doc,[_c.widget(t.selection.head,e,{key:"gapcursor"})])}</span>const Wv=<span class="cstat-no" title="statement not covered" >Qp.create({name:"gapCursor",<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){<span class="cstat-no" title="statement not covered" >return[$v()]}</span>,<span class="fstat-no" title="function not covered" >ex</span>tendNodeSchema(t){var e;const n=<span class="cstat-no" title="statement not covered" >{name:t.name,options:t.options};<span class="cstat-no" title="statement not covered" ></span>return{allowGapCursor:null!==(e=Hp(Dp(t,"allowGapCursor",n)))&amp;&amp;void 0!==e?e:null}}</span>});</span>var Kv=<span class="cstat-no" title="statement not covered" >Wv;</span>const Uv=<span class="cstat-no" title="statement not covered" >hd.create({name:"hardBreak",defaultOptions:{HTMLAttributes:{}},inline:!0,group:"inline",selectable:!1,<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"br"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["br",Pp(this.options.HTMLAttributes,t)]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderText(){<span class="cstat-no" title="statement not covered" >return"\n"}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setHardBreak:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.first([<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.exitCode(),<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.insertContent({type:this.name})]</span>)}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-Enter":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.setHardBreak(),</span>"Shift-Enter":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.setHardBreak()}</span>}</span>}),</span>Gv=<span class="cstat-no" title="statement not covered" >hd.create({name:"heading",defaultOptions:{levels:[1,2,3,4,5,6],HTMLAttributes:{}},content:"inline*",group:"block",defining:!0,<span class="fstat-no" title="function not covered" >ad</span>dAttributes(){<span class="cstat-no" title="statement not covered" >return{level:{default:1,rendered:!1}}}</span>,<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return this.options.levels.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{tag:"h"+t,attrs:{level:t}})</span>)}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({node:t,HTMLAttributes:e}){const n=<span class="cstat-no" title="statement not covered" >this.options.levels.includes(t.attrs.level),</span>r=<span class="cstat-no" title="statement not covered" >n?t.attrs.level:this.options.levels[0];<span class="cstat-no" title="statement not covered" ></span>return["h"+r,Pp(this.options.HTMLAttributes,e),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setHeading:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:e})=&gt;<span class="cstat-no" title="statement not covered" >!!this.options.levels.includes(t.level)&amp;&amp;e.setNode("heading",t),</span></span>toggleHeading:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:e})=&gt;<span class="cstat-no" title="statement not covered" >!!this.options.levels.includes(t.level)&amp;&amp;e.toggleNode("heading","paragraph",t)}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return this.options.levels.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;(<span class="cstat-no" title="statement not covered" >{...t,["Mod-Alt-"+e]:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.toggleHeading({level:e})}</span>)</span>,{})}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return this.options.levels.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Al(new RegExp(`^(#{1,${t}})\\s$`),this.type,{level:t}))</span>}</span>});</span>var Yv=<span class="cstat-no" title="statement not covered" >Gv,</span>Xv=<span class="cstat-no" title="statement not covered" >200,</span>Qv=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){};<span class="cstat-no" title="statement not covered" ></span>Qv.prototype.append=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.length?(t=Qv.from(t),!this.length&amp;&amp;t||t.length&lt;Xv&amp;&amp;this.leafAppend(t)||this.length&lt;Xv&amp;&amp;t.leafPrepend(this)||this.appendInner(t)):this}</span>,Qv.prototype.prepend=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.length?Qv.from(t).append(this):this}</span>,Qv.prototype.appendInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new tg(this,t)}</span>,Qv.prototype.slice=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return void 0===t&amp;&amp;(t=0),void 0===e&amp;&amp;(e=this.length),t&gt;=e?Qv.empty:this.sliceInner(Math.max(0,t),Math.min(this.length,e))}</span>,Qv.prototype.get=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!(t&lt;0||t&gt;=this.length))<span class="cstat-no" title="statement not covered" >return this.getInner(t)}</span></span>,Qv.prototype.forEach=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=0),void 0===n&amp;&amp;(n=this.length),e&lt;=n?this.forEachInner(t,e,n,0):this.forEachInvertedInner(t,e,n,0)}</span>,Qv.prototype.map=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=0),void 0===n&amp;&amp;(n=this.length);v</span>ar r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return r.push(t(e,n))}</span>),e,n),r}</span>,Qv.from=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t instanceof Qv?t:t&amp;&amp;t.length?new Zv(t):Qv.empty}</span>;v</span>ar Zv=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e){<span class="cstat-no" title="statement not covered" >t.call(this),this.values=e}<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e;v</span>ar n=<span class="cstat-no" title="statement not covered" >{length:{configurable:!0},depth:{configurable:!0}};<span class="cstat-no" title="statement not covered" ></span>return e.prototype.flatten=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.values}</span>,e.prototype.sliceInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return 0==t&amp;&amp;n==this.length?this:new e(this.values.slice(t,n))}</span>,e.prototype.getInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.values[t]}</span>,e.prototype.forEachInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >e;</span>o&lt;n;o++)<span class="cstat-no" title="statement not covered" >if(!1===t(this.values[o],r+o))<span class="cstat-no" title="statement not covered" >return!1}</span></span></span>,e.prototype.forEachInvertedInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >e-1;</span>o&gt;=n;o--)<span class="cstat-no" title="statement not covered" >if(!1===t(this.values[o],r+o))<span class="cstat-no" title="statement not covered" >return!1}</span></span></span>,e.prototype.leafAppend=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.length+t.length&lt;=Xv)<span class="cstat-no" title="statement not covered" >return new e(this.values.concat(t.flatten()))}</span></span>,e.prototype.leafPrepend=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.length+t.length&lt;=Xv)<span class="cstat-no" title="statement not covered" >return new e(t.flatten().concat(this.values))}</span></span>,n.length.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.values.length}</span>,n.depth.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 0}</span>,Object.defineProperties(e.prototype,n),e}</span>(Qv);<span class="cstat-no" title="statement not covered" ></span>Qv.empty=new Zv([]);v</span>ar tg=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){function <span class="fstat-no" title="function not covered" >e(</span>e,n){<span class="cstat-no" title="statement not covered" >t.call(this),this.left=e,this.right=n,this.length=e.length+n.length,this.depth=Math.max(e.depth,n.depth)+1}<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(e.__proto__=t),e.prototype=Object.create(t&amp;&amp;t.prototype),e.prototype.constructor=e,e.prototype.flatten=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.left.flatten().concat(this.right.flatten())}</span>,e.prototype.getInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t&lt;this.left.length?this.left.get(t):this.right.get(t-this.left.length)}</span>,e.prototype.forEachInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >this.left.length;<span class="cstat-no" title="statement not covered" ></span>return!(e&lt;o&amp;&amp;!1===this.left.forEachInner(t,e,Math.min(n,o),r))&amp;&amp;(!(n&gt;o&amp;&amp;!1===this.right.forEachInner(t,Math.max(e-o,0),Math.min(this.length,n)-o,r+o))&amp;&amp;void 0)}</span>,e.prototype.forEachInvertedInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >this.left.length;<span class="cstat-no" title="statement not covered" ></span>return!(e&gt;o&amp;&amp;!1===this.right.forEachInvertedInner(t,e-o,Math.max(n,o)-o,r+o))&amp;&amp;(!(n&lt;o&amp;&amp;!1===this.left.forEachInvertedInner(t,Math.min(e,o),n,r))&amp;&amp;void 0)}</span>,e.prototype.sliceInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(0==t&amp;&amp;e==this.length)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >this.left.length;<span class="cstat-no" title="statement not covered" ></span>return e&lt;=n?this.left.slice(t,e):t&gt;=n?this.right.slice(t-n,e-n):this.left.slice(t,n).append(this.right.slice(0,e-n))}</span>,e.prototype.leafAppend=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >this.right.leafAppend(t);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return new e(this.left,n)}</span></span>,e.prototype.leafPrepend=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >this.left.leafPrepend(t);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return new e(n,this.right)}</span></span>,e.prototype.appendInner=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return this.left.depth&gt;=Math.max(this.right.depth,t.depth)+1?new e(this.left,new e(this.right,t)):new e(this,t)}</span>,e}</span>(Qv),</span>eg=<span class="cstat-no" title="statement not covered" >Qv,</span>ng=<span class="cstat-no" title="statement not covered" >eg,</span>rg=<span class="cstat-no" title="statement not covered" >500,</span>og=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >this.items=t,this.eventCount=e}</span>;</span>function <span class="fstat-no" title="function not covered" >ig(</span>t,e){var n;<span class="cstat-no" title="statement not covered" >return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >if(t.selection&amp;&amp;0==e--)<span class="cstat-no" title="statement not covered" >return n=r,!1}</span></span>)),t.slice(n)}<span class="cstat-no" title="statement not covered" ></span>og.prototype.popEvent=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(0==this.eventCount)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >f</span></span>or(var r,o,i=<span class="cstat-no" title="statement not covered" >this.items.length;</span>;i--){var s=<span class="cstat-no" title="statement not covered" >this.items.get(i-1);<span class="cstat-no" title="statement not covered" ></span>if(s.selection){<span class="cstat-no" title="statement not covered" >--i;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>e</span>&amp;&amp;(r=this.remapping(i,this.items.length),o=r.maps.length);v</span>ar a,c,l=<span class="cstat-no" title="statement not covered" >t.tr,</span>p=<span class="cstat-no" title="statement not covered" >[],</span>u=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.items.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!t.step)<span class="cstat-no" title="statement not covered" >return r||(r=n.remapping(i,e+1),o=r.maps.length),o--,void u.push(t);<span class="cstat-no" title="statement not covered" >i</span></span>f(r){<span class="cstat-no" title="statement not covered" >u.push(new sg(t.map));v</span>ar s,h=<span class="cstat-no" title="statement not covered" >t.step.map(r.slice(o));<span class="cstat-no" title="statement not covered" ></span>h&amp;&amp;l.maybeStep(h).doc&amp;&amp;(s=l.mapping.maps[l.mapping.maps.length-1],p.push(new sg(s,null,null,p.length+u.length))),o--,s&amp;&amp;r.appendMap(s,o)}</span>else <span class="cstat-no" title="statement not covered" >l.maybeStep(t.step);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.selection?(a=r?t.selection.map(r.slice(o)):t.selection,c=new og(n.items.slice(0,i).append(u.reverse().concat(p)),n.eventCount-1),!1):void 0}</span>),this.items.length,0),{remaining:c,transform:l,selection:a}}</span>,og.prototype.addTransform=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >this.eventCount,</span>s=<span class="cstat-no" title="statement not covered" >this.items,</span>a=<span class="cstat-no" title="statement not covered" >!r&amp;&amp;s.length?s.get(s.length-1):null,</span>c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;t.steps.length;c++){var l=<span class="cstat-no" title="statement not covered" >t.steps[c].invert(t.docs[c]),</span>p=<span class="cstat-no" title="statement not covered" >new sg(t.mapping.maps[c],l,e),</span>u=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>(u=a&amp;&amp;a.merge(p))&amp;&amp;(p=u,c?o.pop():s=s.slice(0,s.length-1)),o.push(p),e&amp;&amp;(i++,e=null),r||(a=p)}</span>v</span>ar h=<span class="cstat-no" title="statement not covered" >i-n.depth;<span class="cstat-no" title="statement not covered" ></span>return h&gt;cg&amp;&amp;(s=ig(s,h),i-=h),new og(s.append(o),i)}</span>,og.prototype.remapping=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >new oo;<span class="cstat-no" title="statement not covered" ></span>return this.items.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){var o=<span class="cstat-no" title="statement not covered" >null!=e.mirrorOffset&amp;&amp;r-e.mirrorOffset&gt;=t?n.maps.length-e.mirrorOffset:null;<span class="cstat-no" title="statement not covered" ></span>n.appendMap(e.map,o)}</span>),t,e),n}</span>,og.prototype.addMaps=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return 0==this.eventCount?this:new og(this.items.append(t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new sg(t)}</span>))),this.eventCount)}</span>,og.prototype.rebased=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!this.eventCount)<span class="cstat-no" title="statement not covered" >return this;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >Math.max(0,this.items.length-e),</span>o=<span class="cstat-no" title="statement not covered" >t.mapping,</span>i=<span class="cstat-no" title="statement not covered" >t.steps.length,</span>s=<span class="cstat-no" title="statement not covered" >this.eventCount;<span class="cstat-no" title="statement not covered" ></span>this.items.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.selection&amp;&amp;s--}</span>),r);v</span>ar a=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>this.items.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var r=<span class="cstat-no" title="statement not covered" >o.getMirror(--a);<span class="cstat-no" title="statement not covered" ></span>if(null!=r){<span class="cstat-no" title="statement not covered" >i=Math.min(i,r);v</span>ar c=<span class="cstat-no" title="statement not covered" >o.maps[r];<span class="cstat-no" title="statement not covered" ></span>if(e.step){var l=<span class="cstat-no" title="statement not covered" >t.steps[r].invert(t.docs[r]),</span>p=<span class="cstat-no" title="statement not covered" >e.selection&amp;&amp;e.selection.map(o.slice(a+1,r));<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;s++,n.push(new sg(c,l,p))}</span>else <span class="cstat-no" title="statement not covered" >n.push(new sg(c))}</span></span>}</span>),r);<span class="cstat-no" title="statement not covered" >f</span>or(var c=<span class="cstat-no" title="statement not covered" >[],</span>l=<span class="cstat-no" title="statement not covered" >e;</span>l&lt;i;l++)<span class="cstat-no" title="statement not covered" >c.push(new sg(o.maps[l]));v</span></span>ar p=<span class="cstat-no" title="statement not covered" >this.items.slice(0,r).append(c).append(n),</span>u=<span class="cstat-no" title="statement not covered" >new og(p,s);<span class="cstat-no" title="statement not covered" ></span>return u.emptyItemCount()&gt;rg&amp;&amp;(u=u.compress(this.items.length-n.length)),u}</span>,og.prototype.emptyItemCount=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.items.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.step||t++}</span>)),t}</span>,og.prototype.compress=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >void 0===t&amp;&amp;(t=this.items.length);v</span>ar e=<span class="cstat-no" title="statement not covered" >this.remapping(0,t),</span>n=<span class="cstat-no" title="statement not covered" >e.maps.length,</span>r=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.items.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i,s){<span class="cstat-no" title="statement not covered" >if(s&gt;=t)<span class="cstat-no" title="statement not covered" >r.push(i),i.selection&amp;&amp;o++;e</span>lse <span class="cstat-no" title="statement not covered" >if(i.step){var a=<span class="cstat-no" title="statement not covered" >i.step.map(e.slice(n)),</span>c=<span class="cstat-no" title="statement not covered" >a&amp;&amp;a.getMap();<span class="cstat-no" title="statement not covered" ></span>if(n--,c&amp;&amp;e.appendMap(c,n),a){var l=<span class="cstat-no" title="statement not covered" >i.selection&amp;&amp;i.selection.map(e.slice(n));<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;o++;v</span>ar p,u=<span class="cstat-no" title="statement not covered" >new sg(c.invert(),a,l),</span>h=<span class="cstat-no" title="statement not covered" >r.length-1;<span class="cstat-no" title="statement not covered" ></span>(p=r.length&amp;&amp;r[h].merge(u))?r[h]=p:r.push(u)}</span>}</span>else <span class="cstat-no" title="statement not covered" >i.map&amp;&amp;n--}</span></span></span>),this.items.length,0),new og(ng.from(r.reverse()),o)}</span>,og.empty=new og(ng.empty,0);v</span>ar sg=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.map=t,this.step=e,this.selection=n,this.mirrorOffset=r}</span>;<span class="cstat-no" title="statement not covered" ></span>sg.prototype.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(this.step&amp;&amp;t.step&amp;&amp;!t.selection){var e=<span class="cstat-no" title="statement not covered" >t.step.merge(this.step);<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return new sg(e.getMap().invert(),e,this.selection)}</span></span>}</span>;v</span>ar ag=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >this.done=t,this.undone=e,this.prevRanges=n,this.prevTime=r}</span>,</span>cg=<span class="cstat-no" title="statement not covered" >20;</span>function <span class="fstat-no" title="function not covered" >lg(</span>t,e,n,r){var o,i=<span class="cstat-no" title="statement not covered" >n.getMeta(gg);<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >return i.historyState;<span class="cstat-no" title="statement not covered" >n</span></span>.getMeta(yg)&amp;&amp;(t=new ag(t.done,t.undone,null,0));v</span>ar s=<span class="cstat-no" title="statement not covered" >n.getMeta("appendedTransaction");<span class="cstat-no" title="statement not covered" ></span>if(0==n.steps.length)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(s&amp;&amp;s.getMeta(gg))<span class="cstat-no" title="statement not covered" >return s.getMeta(gg).redo?new ag(t.done.addTransform(n,null,r,vg(e)),t.undone,ug(n.mapping.maps[n.steps.length-1]),t.prevTime):new ag(t.done,t.undone.addTransform(n,null,r,vg(e)),null,t.prevTime);<span class="cstat-no" title="statement not covered" >i</span></span>f(!1===n.getMeta("addToHistory")||s&amp;&amp;!1===s.getMeta("addToHistory"))<span class="cstat-no" title="statement not covered" >return(o=n.getMeta("rebased"))?new ag(t.done.rebased(n,o),t.undone.rebased(n,o),hg(t.prevRanges,n.mapping),t.prevTime):new ag(t.done.addMaps(n.mapping.maps),t.undone.addMaps(n.mapping.maps),hg(t.prevRanges,n.mapping),t.prevTime);v</span></span>ar a=<span class="cstat-no" title="statement not covered" >0==t.prevTime||!s&amp;&amp;(t.prevTime&lt;(n.time||0)-r.newGroupDelay||!pg(n,t.prevRanges)),</span>c=<span class="cstat-no" title="statement not covered" >s?hg(t.prevRanges,n.mapping):ug(n.mapping.maps[n.steps.length-1]);<span class="cstat-no" title="statement not covered" ></span>return new ag(t.done.addTransform(n,a?e.selection.getBookmark():null,r,vg(e)),og.empty,c,n.time)}</span>function <span class="fstat-no" title="function not covered" >pg(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!t.docChanged)<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return t.mapping.maps[0].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.length;o+=2)<span class="cstat-no" title="statement not covered" >t&lt;=e[o+1]&amp;&amp;r&gt;=e[o]&amp;&amp;(n=!0)}</span></span>)),n}</span>function <span class="fstat-no" title="function not covered" >ug(</span>t){var e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,r,o){<span class="cstat-no" title="statement not covered" >return e.push(r,o)}</span>)),e}</span>function <span class="fstat-no" title="function not covered" >hg(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >f</span></span>or(var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t.length;r+=2){var o=<span class="cstat-no" title="statement not covered" >e.map(t[r],1),</span>i=<span class="cstat-no" title="statement not covered" >e.map(t[r+1],-1);<span class="cstat-no" title="statement not covered" ></span>o&lt;=i&amp;&amp;n.push(o,i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>function <span class="fstat-no" title="function not covered" >dg(</span>t,e,n,r){var o=<span class="cstat-no" title="statement not covered" >vg(e),</span>i=<span class="cstat-no" title="statement not covered" >gg.get(e).spec.config,</span>s=<span class="cstat-no" title="statement not covered" >(r?t.undone:t.done).popEvent(e,o);<span class="cstat-no" title="statement not covered" ></span>if(s){var a=<span class="cstat-no" title="statement not covered" >s.selection.resolve(s.transform.doc),</span>c=<span class="cstat-no" title="statement not covered" >(r?t.done:t.undone).addTransform(s.transform,e.selection.getBookmark(),i,o),</span>l=<span class="cstat-no" title="statement not covered" >new ag(r?c:s.remaining,r?s.remaining:c,null,0);<span class="cstat-no" title="statement not covered" ></span>n(s.transform.setSelection(a).setMeta(gg,{redo:r,historyState:l}).scrollIntoView())}</span>}</span>var fg=<span class="cstat-no" title="statement not covered" >!1,</span>mg=<span class="cstat-no" title="statement not covered" >null;</span>function <span class="fstat-no" title="function not covered" >vg(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.plugins;<span class="cstat-no" title="statement not covered" ></span>if(mg!=e){<span class="cstat-no" title="statement not covered" >fg=!1,mg=e;<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >if(e[n].spec.historyPreserveItems){<span class="cstat-no" title="statement not covered" >fg=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn fg}</span>var gg=<span class="cstat-no" title="statement not covered" >new vi("history"),</span>yg=<span class="cstat-no" title="statement not covered" >new vi("closeHistory");</span>function <span class="fstat-no" title="function not covered" >bg(</span>t){<span class="cstat-no" title="statement not covered" >return t={depth:t&amp;&amp;t.depth||100,newGroupDelay:t&amp;&amp;t.newGroupDelay||500},new di({key:gg,state:{init:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return new ag(og.empty,og.empty,null,0)}</span>,apply:<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,r){<span class="cstat-no" title="statement not covered" >return lg(n,r,e,t)}</span>},config:t,props:{handleDOMEvents:{beforeinput:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >"historyUndo"==e.inputType?wg(t.state,t.dispatch):"historyRedo"==e.inputType&amp;&amp;Og(t.state,t.dispatch);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;e.preventDefault(),n}</span>}}})}</span>function <span class="fstat-no" title="function not covered" >wg(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >gg.getState(t);<span class="cstat-no" title="statement not covered" ></span>return!(!n||0==n.done.eventCount)&amp;&amp;(e&amp;&amp;dg(n,t,e,!1),!0)}</span>function <span class="fstat-no" title="function not covered" >Og(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >gg.getState(t);<span class="cstat-no" title="statement not covered" ></span>return!(!n||0==n.undone.eventCount)&amp;&amp;(e&amp;&amp;dg(n,t,e,!0),!0)}</span>const kg=<span class="cstat-no" title="statement not covered" >Qp.create({name:"history",defaultOptions:{depth:100,newGroupDelay:500},<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{undo:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >wg(t,e),</span></span>redo:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>state:t,dispatch:e})=&gt;<span class="cstat-no" title="statement not covered" >Og(t,e)}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dProseMirrorPlugins(){<span class="cstat-no" title="statement not covered" >return[bg(this.options)]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-z":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.undo(),</span>"Mod-y":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.redo(),</span>"Shift-Mod-z":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.redo(),</span>"Mod-я":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.undo(),</span>"Shift-Mod-я":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.redo()}</span>}</span>}),</span>xg=<span class="cstat-no" title="statement not covered" >hd.create({name:"horizontalRule",defaultOptions:{HTMLAttributes:{}},group:"block",<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"hr"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["hr",Pp(this.options.HTMLAttributes,t)]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setHorizontalRule:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>chain:t})=&gt;<span class="cstat-no" title="statement not covered" >t().command(<span class="fstat-no" title="function not covered" >({</span>tr:t,dispatch:e})=&gt;{const{selection:n}=<span class="cstat-no" title="statement not covered" >t,</span>{empty:r,$anchor:o}=<span class="cstat-no" title="statement not covered" >n,</span>i=<span class="cstat-no" title="statement not covered" >o.parent.isTextblock&amp;&amp;!o.parent.type.spec.code&amp;&amp;!o.parent.textContent;<span class="cstat-no" title="statement not covered" ></span>if(!r||!i||!e)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >o.before();<span class="cstat-no" title="statement not covered" ></span>return t.deleteRange(s,s+1),!0}</span>).insertContent({type:this.name}).command(<span class="fstat-no" title="function not covered" >({</span>tr:t,dispatch:e})=&gt;{var n;<span class="cstat-no" title="statement not covered" >if(e){const{parent:e,pos:r}=<span class="cstat-no" title="statement not covered" >t.selection.$from,</span>o=<span class="cstat-no" title="statement not covered" >r+1,</span>i=<span class="cstat-no" title="statement not covered" >t.doc.nodeAt(o);<span class="cstat-no" title="statement not covered" ></span>if(!i){const r=<span class="cstat-no" title="statement not covered" >null===(n=e.type.contentMatch.defaultType)||void 0===n?void 0:n.create();<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(t.insert(o,r),t.setSelection(Ko.create(t.doc,o)))}<span class="cstat-no" title="statement not covered" ></span>t</span>.scrollIntoView()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>).run()}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return[fd(/^(?:---|—-|___\s|\*\*\*\s)$/,this.type)]}</span>}),</span>Sg=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/gm,</span>Mg=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/gm,</span>Cg=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:_)((?:[^_]+))(?:_))$/gm,</span>Eg=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:_)((?:[^_]+))(?:_))/gm,</span>Tg=<span class="cstat-no" title="statement not covered" >dd.create({name:"italic",defaultOptions:{HTMLAttributes:{}},<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"em"},{tag:"i",getAttrs:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"normal"!==t.style.fontStyle&amp;&amp;null}</span>,{style:"font-style=italic"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["em",Pp(this.options.HTMLAttributes,t),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setItalic:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.setMark("italic"),</span></span>toggleItalic:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.toggleMark("italic"),</span></span>unsetItalic:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.unsetMark("italic")}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-i":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.toggleItalic()}</span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return[vd(Sg,this.type),vd(Cg,this.type)]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dPasteRules(){<span class="cstat-no" title="statement not covered" >return[gd(Mg,this.type),gd(Eg,this.type)]}</span>});</span>var Ng=<span class="cstat-no" title="statement not covered" >Tg;</span>const jg=<span class="cstat-no" title="statement not covered" >hd.create({name:"listItem",defaultOptions:{HTMLAttributes:{}},content:"paragraph block*",defining:!0,<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"li"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["li",Pp(this.options.HTMLAttributes,t),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{Enter:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.splitListItem("listItem"),</span>Tab:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.sinkListItem("listItem"),</span>"Shift-Tab":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.liftListItem("listItem")}</span>}</span>});</span>var Ag=<span class="cstat-no" title="statement not covered" >jg;</span>const Ig=<span class="cstat-no" title="statement not covered" >/^(\d+)\.\s$/,</span>Dg=<span class="cstat-no" title="statement not covered" >hd.create({name:"orderedList",defaultOptions:{HTMLAttributes:{}},group:"block list",content:"listItem+",<span class="fstat-no" title="function not covered" >ad</span>dAttributes(){<span class="cstat-no" title="statement not covered" >return{start:{default:1,parseHTML:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.hasAttribute("start")?parseInt(t.getAttribute("start")||"",10):1}</span>}}</span>,<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"ol"}]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){const{start:e,...n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return 1===e?["ol",Pp(this.options.HTMLAttributes,n),0]:["ol",Pp(this.options.HTMLAttributes,t),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{toggleOrderedList:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.toggleList("orderedList","listItem")}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-Shift-7":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.toggleOrderedList()}</span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return[jl(Ig,this.type,<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{start:+t[1]})</span>,<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.childCount+e.attrs.start===+t[1])</span>]}</span>}),</span>Rg=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/gm,</span>_g=<span class="cstat-no" title="statement not covered" >/(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/gm,</span>Pg=<span class="cstat-no" title="statement not covered" >dd.create({name:"strike",defaultOptions:{HTMLAttributes:{}},<span class="fstat-no" title="function not covered" >pa</span>rseHTML(){<span class="cstat-no" title="statement not covered" >return[{tag:"s"},{tag:"del"},{tag:"strike"},{style:"text-decoration",consuming:!1,getAttrs:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!!t.includes("line-through")&amp;&amp;{}}</span>]}</span>,<span class="fstat-no" title="function not covered" >re</span>nderHTML({HTMLAttributes:t}){<span class="cstat-no" title="statement not covered" >return["s",Pp(this.options.HTMLAttributes,t),0]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dCommands(){<span class="cstat-no" title="statement not covered" >return{setStrike:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.setMark("strike"),</span></span>toggleStrike:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.toggleMark("strike"),</span></span>unsetStrike:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>commands:t})=&gt;<span class="cstat-no" title="statement not covered" >t.unsetMark("strike")}</span></span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dKeyboardShortcuts(){<span class="cstat-no" title="statement not covered" >return{"Mod-Shift-x":<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.editor.commands.toggleStrike()}</span>}</span>,<span class="fstat-no" title="function not covered" >ad</span>dInputRules(){<span class="cstat-no" title="statement not covered" >return[vd(Rg,this.type)]}</span>,<span class="fstat-no" title="function not covered" >ad</span>dPasteRules(){<span class="cstat-no" title="statement not covered" >return[gd(_g,this.type)]}</span>});</span>var zg=<span class="cstat-no" title="statement not covered" >Pg;</span>const Bg=<span class="cstat-no" title="statement not covered" >Qp.create({name:"starterKit",<span class="fstat-no" title="function not covered" >ad</span>dExtensions(){var t,e,n,r,o,i,s,a,c,l,p,u,h,d,f,m,v,g;const y=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return!1!==this.options.blockquote&amp;&amp;y.push(yv.configure(null===(t=this.options)||void 0===t?void 0:t.blockquote)),!1!==this.options.bold&amp;&amp;y.push(Sv.configure(null===(e=this.options)||void 0===e?void 0:e.bold)),!1!==this.options.bulletList&amp;&amp;y.push(Ev.configure(null===(n=this.options)||void 0===n?void 0:n.bulletList)),!1!==this.options.code&amp;&amp;y.push(jv.configure(null===(r=this.options)||void 0===r?void 0:r.code)),!1!==this.options.codeBlock&amp;&amp;y.push(Dv.configure(null===(o=this.options)||void 0===o?void 0:o.codeBlock)),!1!==this.options.document&amp;&amp;y.push(jd.configure(null===(i=this.options)||void 0===i?void 0:i.document)),!1!==this.options.dropcursor&amp;&amp;y.push(Pv.configure(null===(s=this.options)||void 0===s?void 0:s.dropcursor)),!1!==this.options.gapcursor&amp;&amp;y.push(Kv.configure(null===(a=this.options)||void 0===a?void 0:a.gapcursor)),!1!==this.options.hardBreak&amp;&amp;y.push(Uv.configure(null===(c=this.options)||void 0===c?void 0:c.hardBreak)),!1!==this.options.heading&amp;&amp;y.push(Yv.configure(null===(l=this.options)||void 0===l?void 0:l.heading)),!1!==this.options.history&amp;&amp;y.push(kg.configure(null===(p=this.options)||void 0===p?void 0:p.history)),!1!==this.options.horizontalRule&amp;&amp;y.push(xg.configure(null===(u=this.options)||void 0===u?void 0:u.horizontalRule)),!1!==this.options.italic&amp;&amp;y.push(Ng.configure(null===(h=this.options)||void 0===h?void 0:h.italic)),!1!==this.options.listItem&amp;&amp;y.push(Ag.configure(null===(d=this.options)||void 0===d?void 0:d.listItem)),!1!==this.options.orderedList&amp;&amp;y.push(Dg.configure(null===(f=this.options)||void 0===f?void 0:f.orderedList)),!1!==this.options.paragraph&amp;&amp;y.push(Ad.configure(null===(m=this.options)||void 0===m?void 0:m.paragraph)),!1!==this.options.strike&amp;&amp;y.push(zg.configure(null===(v=this.options)||void 0===v?void 0:v.strike)),!1!==this.options.text&amp;&amp;y.push(Dd.configure(null===(g=this.options)||void 0===g?void 0:g.text)),y}</span>});</span>var Lg=<span class="cstat-no" title="statement not covered" >n("6c02");</span>function <span class="fstat-no" title="function not covered" >Vg(</span>t){<span class="cstat-no" title="statement not covered" >if(Array.isArray(t))<span class="cstat-no" title="statement not covered" >return t}<span class="cstat-no" title="statement not covered" ></span></span>n("a4d3"),n("e01a"),n("d3b7"),n("d28b"),n("3ca3"),n("ddb0");f</span>unction <span class="fstat-no" title="function not covered" >$g(</span>t,e){var n=<span class="cstat-no" title="statement not covered" >null==t?null:"undefined"!==typeof Symbol&amp;&amp;t[Symbol.iterator]||t["@@iterator"];<span class="cstat-no" title="statement not covered" ></span>if(null!=n){var r,o,i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >!0,</span>a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >for(n=n.call(t);!(s=(r=n.next()).done);s=!0)<span class="cstat-no" title="statement not covered" >if(i.push(r.value),e&amp;&amp;i.length===e)<span class="cstat-no" title="statement not covered" >break}</span></span></span>catch(c){<span class="cstat-no" title="statement not covered" >a=!0,o=c}</span>finally{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >s||null==n["return"]||n["return"]()}</span>finally{<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >throw o}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>}<span class="cstat-no" title="statement not covered" ></span>n("fb6a"),n("a630e");f</span>unction <span class="fstat-no" title="function not covered" >Fg(</span>t,e){<span class="cstat-no" title="statement not covered" >(null==e||e&gt;t.length)&amp;&amp;(e=t.length);<span class="cstat-no" title="statement not covered" >f</span>or(var n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >new Array(e);</span>n&lt;e;n++)<span class="cstat-no" title="statement not covered" >r[n]=t[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Hg(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t){<span class="cstat-no" title="statement not covered" >if("string"===typeof t)<span class="cstat-no" title="statement not covered" >return Fg(t,e);v</span></span>ar n=<span class="cstat-no" title="statement not covered" >Object.prototype.toString.call(t).slice(8,-1);<span class="cstat-no" title="statement not covered" ></span>return"Object"===n&amp;&amp;t.constructor&amp;&amp;(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?Fg(t,e):void 0}</span>}</span>function <span class="fstat-no" title="function not covered" >qg(</span>){<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}</span>function <span class="fstat-no" title="function not covered" >Jg(</span>t,e){<span class="cstat-no" title="statement not covered" >return Vg(t)||$g(t,e)||Hg(t,e)||qg()}<span class="cstat-no" title="statement not covered" ></span>n("159b"),n("4de4");v</span>ar Wg=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new di({props:{handlePaste:<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r;<span class="cstat-no" title="statement not covered" >console.log("----onhandlePaste image---");v</span>ar o=<span class="cstat-no" title="statement not covered" >Array.from((null===(r=n.clipboardData)||void 0===r?void 0:r.items)||[]),</span>i=<span class="cstat-no" title="statement not covered" >e.state.schema;<span class="cstat-no" title="statement not covered" ></span>return console.log({items:o}),o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){var o=<span class="cstat-no" title="statement not covered" >r.getAsFile();<span class="cstat-no" title="statement not covered" ></span>if(console.log({image:o,item:r}),0===r.type.indexOf("image"))<span class="cstat-no" title="statement not covered" >console.log("item is an image"),n.preventDefault(),t&amp;&amp;o&amp;&amp;t(o).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >i.nodes.image.create({src:t}),</span>r=<span class="cstat-no" title="statement not covered" >e.state.tr.replaceSelectionWith(n);<span class="cstat-no" title="statement not covered" ></span>e.dispatch(r)}</span>));e</span>lse{var s=<span class="cstat-no" title="statement not covered" >new FileReader;<span class="cstat-no" title="statement not covered" ></span>if(s.onload=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n,r=<span class="cstat-no" title="statement not covered" >i.nodes.image.create({src:null===(n=t.target)||void 0===n?void 0:n.result}),</span>o=<span class="cstat-no" title="statement not covered" >e.state.tr.replaceSelectionWith(r);<span class="cstat-no" title="statement not covered" ></span>e.dispatch(o)}</span>,!o)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span></span>.readAsDataURL(o)}</span>}</span>)),!1}</span>,handleDOMEvents:{drop:<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){var r,o;<span class="cstat-no" title="statement not covered" >console.log("----handleDom.onDrop----"),console.log(e),console.log(n);v</span>ar i=<span class="cstat-no" title="statement not covered" >null===(r=n.dataTransfer)||void 0===r||null===(o=r.files)||void 0===o?void 0:o.length;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar s=<span class="cstat-no" title="statement not covered" >Array.from(n.dataTransfer.files).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return/image/i.test(t.type)}</span>));<span class="cstat-no" title="statement not covered" ></span>if(0===s.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >n</span></span>.preventDefault();v</span>ar a=<span class="cstat-no" title="statement not covered" >e.state.schema,</span>c=<span class="cstat-no" title="statement not covered" >e.posAtCoords({left:n.clientX,top:n.clientY});<span class="cstat-no" title="statement not covered" ></span>return s.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(){var n=<span class="cstat-no" title="statement not covered" >Object(h["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >n(</span>r){var o,i,s;<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(n.prev=n.next){case 0:<span class="cstat-no" title="statement not covered" >if(o=new FileReader,!t){<span class="cstat-no" title="statement not covered" >n.next=12;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n.t0=a.nodes.image,n.next=5,t(r);c</span>ase 5:<span class="cstat-no" title="statement not covered" >n.t1=n.sent,n.t2={src:n.t1},i=n.t0.create.call(n.t0,n.t2),s=e.state.tr.insert(c.pos,i),e.dispatch(s),n.next=14;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 12:<span class="cstat-no" title="statement not covered" >o.onload=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n,r=<span class="cstat-no" title="statement not covered" >a.nodes.image.create({src:null===(n=t.target)||void 0===n?void 0:n.result}),</span>o=<span class="cstat-no" title="statement not covered" >e.state.tr.insert(c.pos,r);<span class="cstat-no" title="statement not covered" ></span>e.dispatch(o)}</span>,o.readAsDataURL(r);c</span>ase 14:case"end":<span class="cstat-no" title="statement not covered" >return n.stop()}</span>}</span></span>),n)}</span>)));<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n.apply(this,arguments)}</span>}</span>()),!1}</span>}}})}</span>,</span>Kg=<span class="cstat-no" title="statement not covered" >/!\[(.+|:?)\]\((\S+)(?:(?:\s+)["'](\S+)["'])?\)/,</span>Ug=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return hd.create({name:"image",defaultOptions:{inline:!1,HTMLAttributes:{}},inline:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.options.inline}</span>,group:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.options.inline?"inline":"block"}</span>,draggable:!0,addAttributes:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{src:{default:null},alt:{default:null},title:{default:null},class:{default:null},height:{default:null},width:{default:null}}}</span>,parseHTML:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[{tag:"img[src]",getAttrs:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if("string"===typeof t)<span class="cstat-no" title="statement not covered" >return{};v</span></span>ar e=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >{src:e.getAttribute("src"),title:e.getAttribute("title"),alt:e.getAttribute("alt"),class:e.getAttribute("class")};<span class="cstat-no" title="statement not covered" ></span>return n}</span>}]}</span>,renderHTML:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.HTMLAttributes;<span class="cstat-no" title="statement not covered" ></span>return["img",e]}</span>,addCommands:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return{setImage:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(n){var r=<span class="cstat-no" title="statement not covered" >n.state,</span>o=<span class="cstat-no" title="statement not covered" >n.dispatch,</span>i=<span class="cstat-no" title="statement not covered" >r.selection,</span>s=<span class="cstat-no" title="statement not covered" >i.$head?i.$head.pos:i.$to.pos;<span class="cstat-no" title="statement not covered" ></span>console.log("before",i,t);v</span>ar a=<span class="cstat-no" title="statement not covered" >t.type.create(e),</span>c=<span class="cstat-no" title="statement not covered" >r.tr.insert(s,a);<span class="cstat-no" title="statement not covered" ></span>return console.log("after",i,c.selection),null===o||void 0===o?void 0:o(c)}</span>}</span>}}</span>,addInputRules:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[fd(Kg,this.type,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Jg(t,4),</span>n=<span class="cstat-no" title="statement not covered" >e[1],</span>r=<span class="cstat-no" title="statement not covered" >e[2],</span>o=<span class="cstat-no" title="statement not covered" >e[3];<span class="cstat-no" title="statement not covered" ></span>return{src:r,alt:n,title:o}}</span>))]}</span>,addProseMirrorPlugins:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Wg(t)]}</span>})}</span>,</span>Gg=<span class="cstat-no" title="statement not covered" >n("0613");<span class="cstat-no" title="statement not covered" ></span>Object(r["pushScopeId"])("data-v-282544a1");v</span>ar Yg=<span class="cstat-no" title="statement not covered" >{height:"20",width:"20",viewBox:"0 0 20 20",class:"character-count__graph"},</span>Xg=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("circle",{r:"10",cx:"10",cy:"10",fill:"#e9ecef"},null,-1),</span>Qg=<span class="cstat-no" title="statement not covered" >["stroke-dasharray"],</span>Zg=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("circle",{r:"6",cx:"10",cy:"10",fill:"white"},null,-1),</span>ty=<span class="cstat-no" title="statement not covered" >{class:"character-count__text"};</span>function <span class="fstat-no" title="function not covered" >ey(</span>t,e,n,o,i,s){<span class="cstat-no" title="statement not covered" >return Object(r["openBlock"])(),Object(r["createElementBlock"])("div",{class:Object(r["normalizeClass"])({"character-count":!0,"character-count--warning":t.current===t.limit})},[(Object(r["openBlock"])(),Object(r["createElementBlock"])("svg",Yg,[Xg,Object(r["createElementVNode"])("circle",{r:"5",cx:"10",cy:"10",fill:"transparent",stroke:"currentColor","stroke-width":"10","stroke-dasharray":"calc(".concat(t.percentage," * 31.4 / 100) 31.4"),transform:"rotate(-90) translate(-20)"},null,8,Qg),Zg])),Object(r["createElementVNode"])("div",ty,Object(r["toDisplayString"])(t.current)+"/"+Object(r["toDisplayString"])(t.limit)+" characters ",1)],2)}<span class="cstat-no" title="statement not covered" ></span>Object(r["popScopeId"])();<span class="cstat-no" title="statement not covered" >n</span>("a9e3");v</span>ar ny=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({name:"article.limit",props:{limit:{type:Number,required:!0},current:{type:Number,required:!0}},setup:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Object(r["toRefs"])(t),</span>n=<span class="cstat-no" title="statement not covered" >e.limit,</span>o=<span class="cstat-no" title="statement not covered" >e.current,</span>i=<span class="cstat-no" title="statement not covered" >Object(r["computed"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Math.round(100/n.value*o.value)}</span>));<span class="cstat-no" title="statement not covered" ></span>return{percentage:i}}</span>});<span class="cstat-no" title="statement not covered" ></span>n("8f57");<span class="cstat-no" title="statement not covered" >n</span>y.render=ey,ny.__scopeId="data-v-282544a1";v</span>ar ry=<span class="cstat-no" title="statement not covered" >ny;<span class="cstat-no" title="statement not covered" ></span>Object(r["pushScopeId"])("data-v-2818b952");v</span>ar oy=<span class="cstat-no" title="statement not covered" >{class:"items"},</span>iy=<span class="cstat-no" title="statement not covered" >["onClick"];</span>function <span class="fstat-no" title="function not covered" >sy(</span>t,e,n,o,i,s){<span class="cstat-no" title="statement not covered" >return Object(r["openBlock"])(),Object(r["createElementBlock"])("div",oy,[(Object(r["openBlock"])(!0),Object(r["createElementBlock"])(r["Fragment"],null,Object(r["renderList"])(t.items,(<span class="fstat-no" title="function not covered" >fu</span>nction(n,o){<span class="cstat-no" title="statement not covered" >return Object(r["openBlock"])(),Object(r["createElementBlock"])("button",{class:Object(r["normalizeClass"])(["item",{"is-selected":o===t.selectedIndex}]),key:o,onKeydown:e[0]||(e[0]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.onKeyDown(e)}</span>),onClick:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.selectItem(o)}</span>},Object(r["toDisplayString"])(n.entity.name),43,iy)}</span>)),128))])}<span class="cstat-no" title="statement not covered" ></span>Object(r["popScopeId"])();v</span>ar ay=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({props:{items:{type:Array,required:!0},command:{type:Function,required:!0}},setup:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >Object(r["toRefs"])(t),</span>n=<span class="cstat-no" title="statement not covered" >e.items,</span>o=<span class="cstat-no" title="statement not covered" >e.command,</span>i=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(0);</span>function <span class="fstat-no" title="function not covered" >s(</span>){<span class="cstat-no" title="statement not covered" >i.value=(i.value+n.value.length-1)%n.value.length}</span>function <span class="fstat-no" title="function not covered" >a(</span>){<span class="cstat-no" title="statement not covered" >i.value=(i.value+1)%n.value.length}</span>function <span class="fstat-no" title="function not covered" >c(</span>t){var e=<span class="cstat-no" title="statement not covered" >n.value[t];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;o.value({id:e.entity.id,name:e.entity.name})}</span>function <span class="fstat-no" title="function not covered" >l(</span>){<span class="cstat-no" title="statement not covered" >c(i.value)}</span>function <span class="fstat-no" title="function not covered" >p(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.event;<span class="cstat-no" title="statement not covered" ></span>return"ArrowUp"===e.key?(s(),!0):"ArrowDown"===e.key?(a(),!0):"Enter"===e.key&amp;&amp;(l(),!0)}<span class="cstat-no" title="statement not covered" ></span>return Object(r["watch"])(n,(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i.value=0}</span>)),{onKeyDown:p,downHandler:a,selectItem:c,selectedIndex:i}}</span>});<span class="cstat-no" title="statement not covered" ></span>n("5ebe");<span class="cstat-no" title="statement not covered" >a</span>y.render=sy,ay.__scopeId="data-v-2818b952";v</span>ar cy=<span class="cstat-no" title="statement not covered" >ay;<span class="cstat-no" title="statement not covered" ></span>Object(r["pushScopeId"])("data-v-c462152a");v</span>ar ly=<span class="cstat-no" title="statement not covered" >{key:0,class:"operator"},</span>py=<span class="cstat-no" title="statement not covered" >{class:"operator-container"},</span>uy=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>hy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 保存 ",-1),</span>dy=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>fy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 撤销 ",-1),</span>my=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>vy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 重做 ",-1),</span>gy=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>yy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 加粗 ",-1),</span>by=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>wy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 倾斜 ",-1),</span>Oy=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>ky=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 划线 ",-1),</span>xy=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>Sy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 列表 ",-1),</span>My=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>Cy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 列表 ",-1),</span>Ey=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>Ty=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 块引用 ",-1),</span>Ny=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>jy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 标题1 ",-1),</span>Ay=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>Iy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 标题2 ",-1),</span>Dy=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>Ry=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 标题3 ",-1),</span>_y=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>Py=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 代码段 ",-1),</span>zy=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>By=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 查找 ",-1),</span>Ly=<span class="cstat-no" title="statement not covered" >{class:"icon"},</span>Vy=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("div",{class:"name"}," 上传 ",-1),</span>$y=<span class="cstat-no" title="statement not covered" >{key:0,style:{"max-height":"500px",overflow:"scroll",width:"100%",padding:"20px","line-height":"24px"}},</span>Fy=<span class="cstat-no" title="statement not covered" >{key:1,style:{"max-height":"300px",overflow:"scroll",width:"100%"}};</span>function <span class="fstat-no" title="function not covered" >Hy(</span>t,e,n,o,i,s){var a,c,l,p=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("SaveIcon"),</span>u=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("UndoOutlined"),</span>h=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("RedoOutlined"),</span>d=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("BoldOutlined"),</span>f=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ItalicOutlined"),</span>m=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("StrikethroughOutlined"),</span>v=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("UnorderedListOutlined"),</span>g=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("OrderedListOutlined"),</span>y=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("quote"),</span>b=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("H1Icon"),</span>w=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("H2Icon"),</span>O=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("H3Icon"),</span>k=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("CodeIcon"),</span>x=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("FindIcon"),</span>S=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("UploadIcon"),</span>M=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-list-item"),</span>C=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-list"),</span>E=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("ant-modal");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createElementBlock"])(r["Fragment"],null,[t.editor?(Object(r["openBlock"])(),Object(r["createElementBlock"])("div",ly,[Object(r["createElementVNode"])("div",py,[Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[0]||(e[0]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.saveSectionArticle&amp;&amp;t.saveSectionArticle.apply(t,arguments)}</span>)},[Object(r["createElementVNode"])("div",uy,[Object(r["createVNode"])(p,{class:"icon-svg"})]),hy]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[1]||(e[1]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().undo().run()}</span>)},[Object(r["createElementVNode"])("div",dy,[Object(r["createVNode"])(u,{viewBox:"0 0 1024 1024",class:"icon-svg"})]),fy]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[2]||(e[2]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().redo().run()}</span>)},[Object(r["createElementVNode"])("div",my,[Object(r["createVNode"])(h,{viewBox:"0 0 1024 1024",class:"icon-svg"})]),vy]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[3]||(e[3]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleBold().run()}</span>)},[Object(r["createElementVNode"])("div",gy,[Object(r["createVNode"])(d,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("bold")}])},null,8,["class"])]),yy]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[4]||(e[4]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleItalic().run()}</span>)},[Object(r["createElementVNode"])("div",by,[Object(r["createVNode"])(f,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("italic")}])},null,8,["class"])]),wy]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[5]||(e[5]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleStrike().run()}</span>)},[Object(r["createElementVNode"])("div",Oy,[Object(r["createVNode"])(m,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("strike")}])},null,8,["class"])]),ky]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[6]||(e[6]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleBulletList().run()}</span>)},[Object(r["createElementVNode"])("div",xy,[Object(r["createVNode"])(v,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("bulletList")}])},null,8,["class"])]),Sy]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[7]||(e[7]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleOrderedList().run()}</span>)},[Object(r["createElementVNode"])("div",My,[Object(r["createVNode"])(g,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("orderedList")}])},null,8,["class"])]),Cy]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[8]||(e[8]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleBlockquote().run()}</span>)},[Object(r["createElementVNode"])("div",Ey,[Object(r["createVNode"])(y,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("blockquote")}])},null,8,["class"])]),Ty]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[9]||(e[9]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleHeading({level:1}).run()}</span>)},[Object(r["createElementVNode"])("div",Ny,[Object(r["createVNode"])(b,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("heading",{level:1})}])},null,8,["class"])]),jy]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[10]||(e[10]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleHeading({level:2}).run()}</span>)},[Object(r["createElementVNode"])("div",Ay,[Object(r["createVNode"])(w,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("heading",{level:2})}])},null,8,["class"])]),Iy]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[11]||(e[11]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleHeading({level:3}).run()}</span>)},[Object(r["createElementVNode"])("div",Dy,[Object(r["createVNode"])(O,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("heading",{level:3})}])},null,8,["class"])]),Ry]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[12]||(e[12]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.editor.chain().focus().toggleCode().run()}</span>)},[Object(r["createElementVNode"])("div",_y,[Object(r["createVNode"])(k,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":t.editor.isActive("code")}])},null,8,["class"])]),Py]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[13]||(e[13]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.handleCreateMention&amp;&amp;t.handleCreateMention.apply(t,arguments)}</span>)},[Object(r["createElementVNode"])("div",zy,[Object(r["createVNode"])(x,{class:Object(r["normalizeClass"])(["icon-svg",{"is-active":!(null!==(a=t.editor)&amp;&amp;void 0!==a&amp;&amp;null!==(c=a.state)&amp;&amp;void 0!==c&amp;&amp;null!==(l=c.selection)&amp;&amp;void 0!==l&amp;&amp;l.empty)}])},null,8,["class"])]),By]),Object(r["createElementVNode"])("div",{class:"operation-icon",onClick:e[14]||(e[14]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.handleUpload&amp;&amp;t.handleUpload.apply(t,arguments)}</span>)},[Object(r["createElementVNode"])("div",Ly,[Object(r["createVNode"])(S,{class:"icon-svg"})]),Vy])])])):Object(r["createCommentVNode"])("",!0),Object(r["createVNode"])(E,{title:"上传",width:1e3,visible:t.isUploadModalShown,onOk:t.handleCreateArticle,onCancel:e[16]||(e[16]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.isUploadModalShown=!1}</span>)},{default:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Object(r["createElementVNode"])("input",{type:"file",onChange:e[15]||(e[15]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.uploadWord(e)}</span>)},null,32),t.text?(Object(r["openBlock"])(),Object(r["createElementBlock"])("div",$y,[Object(r["createElementVNode"])("p",null,Object(r["toDisplayString"])(t.text),1)])):Object(r["createCommentVNode"])("",!0),t.words?(Object(r["openBlock"])(),Object(r["createElementBlock"])("div",Fy,[Object(r["createVNode"])(C,{size:"small",bordered:"","data-source":t.words},{renderItem:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.item;<span class="cstat-no" title="statement not covered" ></span>return[Object(r["createVNode"])(M,null,{default:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Object(r["createTextVNode"])(Object(r["toDisplayString"])(e.word)+" ---- "+Object(r["toDisplayString"])(e.weight),1)]}</span>)),_:2},1024)]}</span>)),_:1},8,["data-source"])])):Object(r["createCommentVNode"])("",!0)]}</span>)),_:1},8,["visible","onOk"])],64)}<span class="cstat-no" title="statement not covered" ></span>Object(r["popScopeId"])();v</span>ar qy=<span class="cstat-no" title="statement not covered" >{icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M697.8 481.4c33.6-35 54.2-82.3 54.2-134.3v-10.2C752 229.3 663.9 142 555.3 142H259.4c-15.1 0-27.4 12.3-27.4 27.4v679.1c0 16.3 13.2 29.5 29.5 29.5h318.7c117 0 211.8-94.2 211.8-210.5v-11c0-73-37.4-137.3-94.2-175.1zM328 238h224.7c57.1 0 103.3 44.4 103.3 99.3v9.5c0 54.8-46.3 99.3-103.3 99.3H328V238zm366.6 429.4c0 62.9-51.7 113.9-115.5 113.9H328V542.7h251.1c63.8 0 115.5 51 115.5 113.9v10.8z"}}]},name:"bold",theme:"outlined"},</span>Jy=<span class="cstat-no" title="statement not covered" >qy,</span>Wy=<span class="cstat-no" title="statement not covered" >n("b3f0");</span>function <span class="fstat-no" title="function not covered" >Ky(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;arguments.length;e++){var n=<span class="cstat-no" title="statement not covered" >null!=arguments[e]?Object(arguments[e]):{},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(n);<span class="cstat-no" title="statement not covered" ></span>"function"===typeof Object.getOwnPropertySymbols&amp;&amp;(r=r.concat(Object.getOwnPropertySymbols(n).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(n,t).enumerable}</span>)))),r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >Uy(t,e,n[e])}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Uy(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}</span>var Gy=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Ky({},t,e.attrs);<span class="cstat-no" title="statement not covered" ></span>return r["createVNode"](Wy["a"],r["mergeProps"](n,{icon:Jy}),null)}</span>;<span class="cstat-no" title="statement not covered" ></span>Gy.displayName="BoldOutlined",Gy.inheritAttrs=!1;v</span>ar Yy=<span class="cstat-no" title="statement not covered" >Gy,</span>Xy=<span class="cstat-no" title="statement not covered" >{icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M798 160H366c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h181.2l-156 544H229c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h432c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8H474.4l156-544H798c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"}}]},name:"italic",theme:"outlined"},</span>Qy=<span class="cstat-no" title="statement not covered" >Xy;</span>function <span class="fstat-no" title="function not covered" >Zy(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;arguments.length;e++){var n=<span class="cstat-no" title="statement not covered" >null!=arguments[e]?Object(arguments[e]):{},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(n);<span class="cstat-no" title="statement not covered" ></span>"function"===typeof Object.getOwnPropertySymbols&amp;&amp;(r=r.concat(Object.getOwnPropertySymbols(n).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(n,t).enumerable}</span>)))),r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >tb(t,e,n[e])}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >tb(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}</span>var eb=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Zy({},t,e.attrs);<span class="cstat-no" title="statement not covered" ></span>return r["createVNode"](Wy["a"],r["mergeProps"](n,{icon:Qy}),null)}</span>;<span class="cstat-no" title="statement not covered" ></span>eb.displayName="ItalicOutlined",eb.inheritAttrs=!1;v</span>ar nb=<span class="cstat-no" title="statement not covered" >eb,</span>rb=<span class="cstat-no" title="statement not covered" >{icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M952 474H569.9c-10-2-20.5-4-31.6-6-15.9-2.9-22.2-4.1-30.8-5.8-51.3-10-82.2-20-106.8-34.2-35.1-20.5-52.2-48.3-52.2-85.1 0-37 15.2-67.7 44-89 28.4-21 68.8-32.1 116.8-32.1 54.8 0 97.1 14.4 125.8 42.8 14.6 14.4 25.3 32.1 31.8 52.6 1.3 4.1 2.8 10 4.3 17.8.9 4.8 5.2 8.2 9.9 8.2h72.8c5.6 0 10.1-4.6 10.1-10.1v-1c-.7-6.8-1.3-12.1-2-16-7.3-43.5-28-81.7-59.7-110.3-44.4-40.5-109.7-61.8-188.7-61.8-72.3 0-137.4 18.1-183.3 50.9-25.6 18.4-45.4 41.2-58.6 67.7-13.5 27.1-20.3 58.4-20.3 92.9 0 29.5 5.7 54.5 17.3 76.5 8.3 15.7 19.6 29.5 34.1 42H72c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h433.2c2.1.4 3.9.8 5.9 1.2 30.9 6.2 49.5 10.4 66.6 15.2 23 6.5 40.6 13.3 55.2 21.5 35.8 20.2 53.3 49.2 53.3 89 0 35.3-15.5 66.8-43.6 88.8-30.5 23.9-75.6 36.4-130.5 36.4-43.7 0-80.7-8.5-110.2-25-29.1-16.3-49.1-39.8-59.7-69.5-.8-2.2-1.7-5.2-2.7-9-1.2-4.4-5.3-7.5-9.7-7.5h-79.7c-5.6 0-10.1 4.6-10.1 10.1v1c.2 2.3.4 4.2.6 5.7 6.5 48.8 30.3 88.8 70.7 118.8 47.1 34.8 113.4 53.2 191.8 53.2 84.2 0 154.8-19.8 204.2-57.3 25-18.9 44.2-42.2 57.1-69 13-27.1 19.7-57.9 19.7-91.5 0-31.8-5.8-58.4-17.8-81.4-5.8-11.2-13.1-21.5-21.8-30.8H952c4.4 0 8-3.6 8-8v-60a8 8 0 00-8-7.9z"}}]},name:"strikethrough",theme:"outlined"},</span>ob=<span class="cstat-no" title="statement not covered" >rb;</span>function <span class="fstat-no" title="function not covered" >ib(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;arguments.length;e++){var n=<span class="cstat-no" title="statement not covered" >null!=arguments[e]?Object(arguments[e]):{},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(n);<span class="cstat-no" title="statement not covered" ></span>"function"===typeof Object.getOwnPropertySymbols&amp;&amp;(r=r.concat(Object.getOwnPropertySymbols(n).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(n,t).enumerable}</span>)))),r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >sb(t,e,n[e])}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >sb(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}</span>var ab=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >ib({},t,e.attrs);<span class="cstat-no" title="statement not covered" ></span>return r["createVNode"](Wy["a"],r["mergeProps"](n,{icon:ob}),null)}</span>;<span class="cstat-no" title="statement not covered" ></span>ab.displayName="StrikethroughOutlined",ab.inheritAttrs=!1;v</span>ar cb=<span class="cstat-no" title="statement not covered" >ab,</span>lb=<span class="cstat-no" title="statement not covered" >{icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M511.4 124C290.5 124.3 112 303 112 523.9c0 128 60.2 242 153.8 315.2l-37.5 48c-4.1 5.3-.3 13 6.3 12.9l167-.8c5.2 0 9-4.9 7.7-9.9L369.8 727a8 8 0 00-14.1-3L315 776.1c-10.2-8-20-16.7-29.3-26a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-7.5 7.5-15.3 14.5-23.4 21.2a7.93 7.93 0 00-1.2 11.1l39.4 50.5c2.8 3.5 7.9 4.1 11.4 1.3C854.5 760.8 912 649.1 912 523.9c0-221.1-179.4-400.2-400.6-399.9z"}}]},name:"undo",theme:"outlined"},</span>pb=<span class="cstat-no" title="statement not covered" >lb;</span>function <span class="fstat-no" title="function not covered" >ub(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;arguments.length;e++){var n=<span class="cstat-no" title="statement not covered" >null!=arguments[e]?Object(arguments[e]):{},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(n);<span class="cstat-no" title="statement not covered" ></span>"function"===typeof Object.getOwnPropertySymbols&amp;&amp;(r=r.concat(Object.getOwnPropertySymbols(n).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(n,t).enumerable}</span>)))),r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >hb(t,e,n[e])}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >hb(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}</span>var db=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >ub({},t,e.attrs);<span class="cstat-no" title="statement not covered" ></span>return r["createVNode"](Wy["a"],r["mergeProps"](n,{icon:pb}),null)}</span>;<span class="cstat-no" title="statement not covered" ></span>db.displayName="UndoOutlined",db.inheritAttrs=!1;v</span>ar fb=<span class="cstat-no" title="statement not covered" >db,</span>mb=<span class="cstat-no" title="statement not covered" >{icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M920 760H336c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0-568H336c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H336c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM216 712H100c-2.2 0-4 1.8-4 4v34c0 2.2 1.8 4 4 4h72.4v20.5h-35.7c-2.2 0-4 1.8-4 4v34c0 2.2 1.8 4 4 4h35.7V838H100c-2.2 0-4 1.8-4 4v34c0 2.2 1.8 4 4 4h116c2.2 0 4-1.8 4-4V716c0-2.2-1.8-4-4-4zM100 188h38v120c0 2.2 1.8 4 4 4h40c2.2 0 4-1.8 4-4V152c0-4.4-3.6-8-8-8h-78c-2.2 0-4 1.8-4 4v36c0 2.2 1.8 4 4 4zm116 240H100c-2.2 0-4 1.8-4 4v36c0 2.2 1.8 4 4 4h68.4l-70.3 77.7a8.3 8.3 0 00-2.1 5.4V592c0 2.2 1.8 4 4 4h116c2.2 0 4-1.8 4-4v-36c0-2.2-1.8-4-4-4h-68.4l70.3-77.7a8.3 8.3 0 002.1-5.4V432c0-2.2-1.8-4-4-4z"}}]},name:"ordered-list",theme:"outlined"},</span>vb=<span class="cstat-no" title="statement not covered" >mb;</span>function <span class="fstat-no" title="function not covered" >gb(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;arguments.length;e++){var n=<span class="cstat-no" title="statement not covered" >null!=arguments[e]?Object(arguments[e]):{},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(n);<span class="cstat-no" title="statement not covered" ></span>"function"===typeof Object.getOwnPropertySymbols&amp;&amp;(r=r.concat(Object.getOwnPropertySymbols(n).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(n,t).enumerable}</span>)))),r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >yb(t,e,n[e])}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >yb(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}</span>var bb=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >gb({},t,e.attrs);<span class="cstat-no" title="statement not covered" ></span>return r["createVNode"](Wy["a"],r["mergeProps"](n,{icon:vb}),null)}</span>;<span class="cstat-no" title="statement not covered" ></span>bb.displayName="OrderedListOutlined",bb.inheritAttrs=!1;v</span>ar wb=<span class="cstat-no" title="statement not covered" >bb,</span>Ob=<span class="cstat-no" title="statement not covered" >{icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z"}}]},name:"unordered-list",theme:"outlined"},</span>kb=<span class="cstat-no" title="statement not covered" >Ob;</span>function <span class="fstat-no" title="function not covered" >xb(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;arguments.length;e++){var n=<span class="cstat-no" title="statement not covered" >null!=arguments[e]?Object(arguments[e]):{},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(n);<span class="cstat-no" title="statement not covered" ></span>"function"===typeof Object.getOwnPropertySymbols&amp;&amp;(r=r.concat(Object.getOwnPropertySymbols(n).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(n,t).enumerable}</span>)))),r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >Sb(t,e,n[e])}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Sb(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}</span>var Mb=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >xb({},t,e.attrs);<span class="cstat-no" title="statement not covered" ></span>return r["createVNode"](Wy["a"],r["mergeProps"](n,{icon:kb}),null)}</span>;<span class="cstat-no" title="statement not covered" ></span>Mb.displayName="UnorderedListOutlined",Mb.inheritAttrs=!1;v</span>ar Cb=<span class="cstat-no" title="statement not covered" >Mb,</span>Eb=<span class="cstat-no" title="statement not covered" >{icon:{tag:"svg",attrs:{viewBox:"64 64 896 896",focusable:"false"},children:[{tag:"path",attrs:{d:"M758.2 839.1C851.8 765.9 912 651.9 912 523.9 912 303 733.5 124.3 512.6 124 291.4 123.7 112 302.8 112 523.9c0 125.2 57.5 236.9 147.6 310.2 3.5 2.8 8.6 2.2 11.4-1.3l39.4-50.5c2.7-3.4 2.1-8.3-1.2-11.1-8.1-6.6-15.9-13.7-23.4-21.2a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-9.3 9.3-19.1 18-29.3 26L668.2 724a8 8 0 00-14.1 3l-39.6 162.2c-1.2 5 2.6 9.9 7.7 9.9l167 .8c6.7 0 10.5-7.7 6.3-12.9l-37.3-47.9z"}}]},name:"redo",theme:"outlined"},</span>Tb=<span class="cstat-no" title="statement not covered" >Eb;</span>function <span class="fstat-no" title="function not covered" >Nb(</span>t){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;arguments.length;e++){var n=<span class="cstat-no" title="statement not covered" >null!=arguments[e]?Object(arguments[e]):{},</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(n);<span class="cstat-no" title="statement not covered" ></span>"function"===typeof Object.getOwnPropertySymbols&amp;&amp;(r=r.concat(Object.getOwnPropertySymbols(n).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(n,t).enumerable}</span>)))),r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >jb(t,e,n[e])}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >jb(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}</span>var Ab=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Nb({},t,e.attrs);<span class="cstat-no" title="statement not covered" ></span>return r["createVNode"](Wy["a"],r["mergeProps"](n,{icon:Tb}),null)}</span>;<span class="cstat-no" title="statement not covered" ></span>Ab.displayName="RedoOutlined",Ab.inheritAttrs=!1;v</span>ar Ib=<span class="cstat-no" title="statement not covered" >Ab,</span>Db=<span class="cstat-no" title="statement not covered" >n("efb1"),</span>Rb=<span class="cstat-no" title="statement not covered" >n("f744"),</span>_b=<span class="cstat-no" title="statement not covered" >n("6162"),</span>Pb=<span class="cstat-no" title="statement not covered" >n("d4ec"),</span>zb=<span class="cstat-no" title="statement not covered" >n("bee2"),</span>Bb=<span class="cstat-no" title="statement not covered" >n("fb57"),</span>Lb=<span class="cstat-no" title="statement not covered" >n("d257"),</span>Vb=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){function <span class="fstat-no" title="function not covered" >t(</span>){<span class="cstat-no" title="statement not covered" >Object(Pb["a"])(this,t)}<span class="cstat-no" title="statement not covered" ></span>return Object(zb["a"])(t,null,[{key:"parseWord",value:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >Object(h["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >t(</span>e){<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(t.prev=t.next){case 0:<span class="cstat-no" title="statement not covered" >return t.abrupt("return",Lb["a"].post({apiPath:Bb["a"].ParseWord,requestBody:e}));c</span>ase 1:case"end":<span class="cstat-no" title="statement not covered" >return t.stop()}</span>}</span></span>),t)}</span>)));</span>function <span class="fstat-no" title="function not covered" >e(</span>e){<span class="cstat-no" title="statement not covered" >return t.apply(this,arguments)}<span class="cstat-no" title="statement not covered" ></span>return e}</span>()}]),t}</span>(),</span>$b=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("svg",{viewBox:"0 0 1024 1024",fill:"currentColor",width:"1em",height:"1em"},[Object(r["createElementVNode"])("path",{d:"M298.900577 778.338974c-7.070023 7.070023-17.974373 7.070023-25.043373 0L20.039405 524.521175c-7.070023-7.070023-7.070023-17.974373 0-25.043373l253.8178-253.8178c7.070023-7.070023 17.974373-7.070023 25.043373 0l27.242458 27.242458c7.070023 7.070023 7.070023 17.974373 0 25.043373L112.089891 512l214.053144 214.053144c7.070023 7.070023 7.070023 17.974373 0 25.043373L298.900577 778.338974zM444.87316 873.098151c-2.726088 9.269108-12.522198 14.702863-21.24486 11.995195l-33.767058-9.269108c-9.250688-2.726088-14.702863-12.522198-11.976776-21.790282l203.148793-703.132108c2.726088-9.269108 12.522198-14.702863 21.24486-11.995195l33.767058 9.269108c9.250688 2.726088 14.702863 12.522198 11.976776 21.790282L444.87316 873.098151zM752.049215 778.338974c-7.070023 7.070023-17.974373 7.070023-25.043373 0l-27.242458-27.242458c-7.070023-7.070023-7.070023-17.974373 0-25.043373l214.053144-214.053144L699.763384 297.946856c-7.070023-7.070023-7.070023-17.974373 0-25.043373l27.242458-27.242458c7.070023-7.070023 17.974373-7.070023 25.043373 0l253.8178 253.8178c7.070023 7.070023 7.070023 17.974373 0 25.043373L752.049215 778.338974z"})],-1);</span>function <span class="fstat-no" title="function not covered" >Fb(</span>t,e,n,o,i,s){var a=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("Icon");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createBlock"])(a,null,{component:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[$b]}</span>)),_:1})}</span>var Hb=<span class="cstat-no" title="statement not covered" >n("e6b1"),</span>qb=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({components:{Icon:Hb["a"]}});<span class="cstat-no" title="statement not covered" ></span>qb.render=Fb;v</span>ar Jb=<span class="cstat-no" title="statement not covered" >qb,</span>Wb=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("svg",{viewBox:"0 0 1024 1024",width:"1em",height:"1em",fill:"currentColor"},[Object(r["createElementVNode"])("path",{d:"M947.942255 886.008182 720.970894 659.243529c48.977481-62.368466 78.178547-140.907217 78.178547-226.249931 0-202.907293-165.033707-367.395578-368.613312-367.395578-203.580628 0-368.616382 164.489308-368.616382 367.395578 0 202.90627 165.035754 367.395578 368.616382 367.395578 85.758176 0 164.673503-29.192879 227.295749-78.146824l226.938616 226.728838c12.769838 12.727882 33.475416 12.727882 46.246277 0l16.925485-16.870226C960.713117 919.374104 960.713117 898.736065 947.942255 886.008182zM430.536129 711.482287c-154.315598 0-279.414781-124.682697-279.414781-278.487665 0-153.805992 125.099183-278.488689 279.414781-278.488689 154.315598 0 279.410688 124.68372 279.410688 278.488689C709.946816 586.79959 584.851727 711.482287 430.536129 711.482287z"})],-1);</span>function <span class="fstat-no" title="function not covered" >Kb(</span>t,e,n,o,i,s){var a=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("Icon");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createBlock"])(a,null,{component:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Wb]}</span>)),_:1})}</span>var Ub=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({components:{Icon:Hb["a"]}});<span class="cstat-no" title="statement not covered" ></span>Ub.render=Kb;v</span>ar Gb=<span class="cstat-no" title="statement not covered" >Ub,</span>Yb=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("svg",{viewBox:"0 0 1024 1024",width:"1em",height:"1em",fill:"currentColor"},[Object(r["createElementVNode"])("path",{d:"M472.296727 930.909091v-372.363636H116.363636v372.363636h-93.090909V93.090909h93.090909v372.363636h355.886546V93.090909h93.090909v837.818182z"}),Object(r["createElementVNode"])("path",{d:"M874.170182 930.955636v-0.418909h-120.413091v-69.818182h120.413091v-364.171636a283.927273 283.927273 0 0 1-120.413091 67.072V483.141818a301.335273 301.335273 0 0 0 74.146909-31.278545 304.500364 304.500364 0 0 0 66.187636-52.922182h60.183273v461.730909h93.090909v69.818182h-93.090909V930.909091z"})],-1);</span>function <span class="fstat-no" title="function not covered" >Xb(</span>t,e,n,o,i,s){var a=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("Icon");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createBlock"])(a,null,{component:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[Yb]}</span>)),_:1})}</span>var Qb=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({components:{Icon:Hb["a"]}});<span class="cstat-no" title="statement not covered" ></span>Qb.render=Xb;v</span>ar Zb=<span class="cstat-no" title="statement not covered" >Qb,</span>tw=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("svg",{viewBox:"0 0 1024 1024",fill:"currentColor",width:"1em",height:"1em"},[Object(r["createElementVNode"])("path",{d:"M662.667636 930.909091a203.776 203.776 0 0 1 52.130909-139.310546 667.787636 667.787636 0 0 1 118.225455-96.954181 547.467636 547.467636 0 0 0 74.891636-61.021091 130.653091 130.653091 0 0 0 35.979637-87.179637 86.946909 86.946909 0 0 0-24.250182-67.025454 102.4 102.4 0 0 0-71.214546-22.341818 86.853818 86.853818 0 0 0-74.938181 34.257454 163.607273 163.607273 0 0 0-27.927273 97.745455h-80.058182a206.196364 206.196364 0 0 1 50.688-143.034182 170.402909 170.402909 0 0 1 134.981818-57.344 176.267636 176.267636 0 0 1 124.136728 43.938909 150.807273 150.807273 0 0 1 47.662545 114.734545 185.530182 185.530182 0 0 1-51.2 125.952 740.864 740.864 0 0 1-108.683636 85.690182 258.513455 258.513455 0 0 0-101.329455 100.538182H1024V930.909091z m-216.482909 0v-372.363636H93.090909v372.363636H0V93.090909h93.090909v372.363636h353.047273V93.090909h93.090909v837.818182z"})],-1);</span>function <span class="fstat-no" title="function not covered" >ew(</span>t,e,n,o,i,s){var a=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("Icon");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createBlock"])(a,null,{component:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[tw]}</span>)),_:1})}</span>var nw=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({components:{Icon:Hb["a"]}});<span class="cstat-no" title="statement not covered" ></span>nw.render=ew;v</span>ar rw=<span class="cstat-no" title="statement not covered" >nw,</span>ow=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("svg",{viewBox:"0 0 1024 1024",fill:"currentColor",width:"1em",height:"1em"},[Object(r["createElementVNode"])("path",{d:"M707.490909 894.417455a188.509091 188.509091 0 0 1-61.719273-136.331637h80.802909a110.033455 110.033455 0 0 0 34.490182 82.711273 105.006545 105.006545 0 0 0 74.845091 26.810182 114.641455 114.641455 0 0 0 81.547637-29.789091 90.670545 90.670545 0 0 0 27.22909-66.327273 82.199273 82.199273 0 0 0-28.672-69.259636 119.202909 119.202909 0 0 0-78.568727-22.434909h-38.167273v-61.067637h37.515637a107.799273 107.799273 0 0 0 72.657454-21.643636 78.382545 78.382545 0 0 0 24.994909-61.812364 80.709818 80.709818 0 0 0-22.807272-61.067636 102.4 102.4 0 0 0-71.261091-21.643636 104.866909 104.866909 0 0 0-74.146909 24.66909 110.312727 110.312727 0 0 0-31.604364 73.681455h-78.568727a174.638545 174.638545 0 0 1 58.042182-123.671273 177.524364 177.524364 0 0 1 125.672727-43.938909 194.699636 194.699636 0 0 1 127.022545 38.772364 133.352727 133.352727 0 0 1 47.010909 107.054545 115.246545 115.246545 0 0 1-86.667636 117.015273 146.338909 146.338909 0 0 1 70.516364 43.892364 113.943273 113.943273 0 0 1 26.391272 77.544727 158.999273 158.999273 0 0 1-49.943272 120.645818 200.471273 200.471273 0 0 1-137.309091 47.662546 193.117091 193.117091 0 0 1-129.303273-41.472z m-261.306182 41.890909v-382.976H93.090909v372.363636H0v-837.818182h93.090909v372.363637h353.093818V98.304h93.090909v837.818182z","p-id":"2936"})],-1);</span>function <span class="fstat-no" title="function not covered" >iw(</span>t,e,n,o,i,s){var a=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("Icon");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createBlock"])(a,null,{component:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[ow]}</span>)),_:1})}</span>var sw=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({components:{Icon:Hb["a"]}});<span class="cstat-no" title="statement not covered" ></span>sw.render=iw;v</span>ar aw=<span class="cstat-no" title="statement not covered" >sw,</span>cw=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("svg",{viewBox:"0 0 1024 1024",width:"1em",height:"1em",fill:"currentColor"},[Object(r["createElementVNode"])("path",{d:"M379.01 256L231.35 511.75l0.05 0.03c-10.97 18.88-17.26 40.81-17.26 64.22 0 70.69 57.31 128 128 128s128-57.31 128-128c0-58.85-39.72-108.42-93.81-123.37L489.86 256H379.01zM696.34 452.63L809.86 256H699.01L551.35 511.75l0.05 0.03c-10.97 18.88-17.26 40.81-17.26 64.22 0 70.69 57.31 128 128 128s128-57.31 128-128c0-58.85-39.71-108.42-93.8-123.37z"})],-1);</span>function <span class="fstat-no" title="function not covered" >lw(</span>t,e,n,o,i,s){var a=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("Icon");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createBlock"])(a,null,{component:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[cw]}</span>)),_:1})}</span>var pw=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({components:{Icon:Hb["a"]}});<span class="cstat-no" title="statement not covered" ></span>pw.render=lw;v</span>ar uw=<span class="cstat-no" title="statement not covered" >pw,</span>hw=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("svg",{viewBox:"0 0 1024 1024",fill:"currentColor",width:"1em",height:"1em"},[Object(r["createElementVNode"])("path",{d:"M845.312 0.512H32.512v1022.976h958.976v-876.8L845.312 0.512z m-172.864 62.976v256H351.488v-256h320.96zM287.488 960.512V605.76l29.184-29.248h390.656l29.184 29.248v354.752H287.488z m640 0h-126.976V585.152L727.424 512H296.576L223.488 585.152v375.36H96.512V63.488h190.976v320.448h449.024V63.488h79.68l111.296 112.32v784.704z m-384-832h65.984v128H543.488v-128z"})],-1);</span>function <span class="fstat-no" title="function not covered" >dw(</span>t,e,n,o,i,s){var a=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("Icon");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createBlock"])(a,null,{component:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[hw]}</span>)),_:1})}</span>var fw=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({components:{Icon:Hb["a"]}});<span class="cstat-no" title="statement not covered" ></span>fw.render=dw;v</span>ar mw=<span class="cstat-no" title="statement not covered" >fw,</span>vw=<span class="cstat-no" title="statement not covered" >Object(r["createElementVNode"])("svg",{viewBox:"0 0 1024 1024",fill:"currentColor",width:"1em",height:"1em"},[Object(r["createElementVNode"])("path",{d:"M832.802797 285.953527c-10.94962-65.066009-43.166769-124.446638-92.440058-169.508534-54.748098-50.115567-125.920625-77.700185-200.041127-77.700185-57.274933 0-113.075879 16.424429-160.87518 47.378161-39.797656 25.689492-72.857084 60.433477-96.23031 101.283981-10.107341-1.895126-20.635822-2.947975-31.164302-2.947974-89.492083 0-162.349167 72.857084-162.349167 162.349167 0 11.581328 1.263418 22.741518 3.369113 33.691137C35.165124 422.613202 0 490.416615 0 562.641991c0 58.327781 21.68867 114.971006 61.275756 159.822331 40.639934 45.904174 94.335184 73.067654 151.610117 76.226198h182.774419c15.792721 0 28.426897-12.634176 28.426897-28.426897s-12.634176-28.426897-28.426897-28.426897h-180.247584C129.289739 736.572486 56.853794 654.660909 56.853794 562.431421c0-59.591199 32.00658-115.181575 83.596134-145.293029 12.002468-6.948797 17.056138-21.4781 12.423607-34.533416-4.211392-11.370759-6.317088-23.373226-6.317088-36.217972 0-58.117212 47.378162-105.495373 105.495373-105.495373 12.423607 0 24.636644 2.105696 36.007403 6.317088 13.897594 5.053671 29.269175-1.263418 35.586263-14.529303 39.376517-83.596134 124.446638-137.501954 216.886696-137.501954 124.236068 0 226.783467 93.071766 238.575365 216.465557 1.263418 12.844746 10.94962 23.162657 23.583796 25.268353 93.703475 16.00329 164.454863 102.547399 164.454863 201.304544 0 104.653095-82.332716 195.619165-183.827267 203.410241h-155.189801c-15.792721 0-28.426897 12.634176-28.426897 28.426897s12.634176 28.426897 28.426897 28.426897h158.348345c64.22373-4.632531 124.236068-34.112276 168.876825-83.385565 44.430187-48.852149 68.645692-111.601892 68.645692-176.87847-0.21057-118.12955-80.858729-223.203784-191.197203-252.262389z"}),Object(r["createElementVNode"])("path",{d:"M682.666667 589.5949c11.160189-11.160189 11.160189-29.058606 0-40.218795l-150.55727-150.557269c-5.26424-5.26424-12.634176-8.422784-20.004112-8.422784s-14.739873 2.947975-20.004113 8.422784l-150.557269 150.557269c-11.160189 11.160189-11.160189 29.058606 0 40.218795 5.47481 5.47481 12.844746 8.422784 20.004113 8.422785s14.529303-2.737405 20.004112-8.422785l102.12626-102.126259v469.359654c0 15.792721 12.634176 28.426897 28.426897 28.426897s28.426897-12.634176 28.426897-28.426897V487.468641l102.126259 102.126259c10.94962 11.160189 28.848036 11.160189 40.008226 0z"})],-1);</span>function <span class="fstat-no" title="function not covered" >gw(</span>t,e,n,o,i,s){var a=<span class="cstat-no" title="statement not covered" >Object(r["resolveComponent"])("Icon");<span class="cstat-no" title="statement not covered" ></span>return Object(r["openBlock"])(),Object(r["createBlock"])(a,null,{component:Object(r["withCtx"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[vw]}</span>)),_:1})}</span>var yw=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({components:{Icon:Hb["a"]}});<span class="cstat-no" title="statement not covered" ></span>yw.render=gw;v</span>ar bw=<span class="cstat-no" title="statement not covered" >yw,</span>ww=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({name:"section.article.control",props:{editor:{type:Object,required:!0}},components:{BoldOutlined:Yy,ItalicOutlined:nb,StrikethroughOutlined:cb,UndoOutlined:fb,OrderedListOutlined:wb,UnorderedListOutlined:Cb,RedoOutlined:Ib,UploadIcon:bw,Quote:uw,H1Icon:Zb,H2Icon:rw,H3Icon:aw,CodeIcon:Jb,SaveIcon:mw,FindIcon:Gb},emits:["save"],setup:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >e.emit,</span>o=<span class="cstat-no" title="statement not covered" >Object(r["toRef"])(t,"editor"),</span>i=<span class="cstat-no" title="statement not covered" >Object(Lg["c"])(),</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n("save")}</span>,</span>a=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(!1),</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e,n,r,i,s,a=<span class="cstat-no" title="statement not covered" >null===(t=o.value)||void 0===t?void 0:t.state.selection,</span>c=<span class="cstat-no" title="statement not covered" >a.from,</span>l=<span class="cstat-no" title="statement not covered" >a.to;<span class="cstat-no" title="statement not covered" ></span>if(c&amp;&amp;l){var p=<span class="cstat-no" title="statement not covered" >null===(e=o.value)||void 0===e?void 0:e.state.doc.textBetween(c,l," ");<span class="cstat-no" title="statement not covered" ></span>void 0!==(null===(n=o.value)||void 0===n||null===(r=n.state)||void 0===r||null===(i=r.selection)||void 0===i?void 0:i.ranges)&amp;&amp;(null===(s=o.value)||void 0===s||s.chain().focus().insertContentAt({from:c,to:l},[{type:"mention",attrs:{id:"test",name:p}},{type:"text",text:" "}]).run())}</span>}</span>,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.value=!0}</span>,</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){},</span>u=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(void 0),</span>d=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(""),</span>f=<span class="cstat-no" title="statement not covered" >Object(r["ref"])([]),</span>m=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >Object(h["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >t(</span>e){var n,r,o;<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(t.prev=t.next){case 0:<span class="cstat-no" title="statement not covered" >return t.next=2,_b["f"].getCredential({name:e.name,type:e.type});c</span>ase 2:<span class="cstat-no" title="statement not covered" >if(n=t.sent,r=n.data,console.log(r),void 0!==r){<span class="cstat-no" title="statement not covered" >t.next=7;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.abrupt("return");c</span>ase 7:<span class="cstat-no" title="statement not covered" >return o={complete:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >console.log(t),u.value=t.url,Vb.parseWord({url:u.value,repositoryEntityId:i.query.repositoryEntityId}).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.data&amp;&amp;(d.value=t.data.text,f.value=t.data.list)}</span>))}</span>},t.next=10,Rb["a"](e.file,r.key,r.uploadToken).subscribe(o);c</span>ase 10:case"end":<span class="cstat-no" title="statement not covered" >return t.stop()}</span>}</span></span>),t)}</span>)));<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.apply(this,arguments)}</span>}</span>(),</span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >Object(h["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >t(</span>e){var n,r;<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(t.prev=t.next){case 0:<span class="cstat-no" title="statement not covered" >if(console.log(e),n=e.target,null!==n.files){<span class="cstat-no" title="statement not covered" >t.next=4;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.abrupt("return");c</span>ase 4:<span class="cstat-no" title="statement not covered" >return r=n.files[0],t.next=7,m({file:r,name:r.name,type:Db["FileEnum"].Text});c</span>ase 7:case"end":<span class="cstat-no" title="statement not covered" >return t.stop()}</span>}</span></span>),t)}</span>)));<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.apply(this,arguments)}</span>}</span>();<span class="cstat-no" title="statement not covered" ></span>return{saveSectionArticle:s,handleCreateMention:c,handleUpload:l,isUploadModalShown:a,handleCreateArticle:p,uploadWord:v,text:d,words:f}}</span>});<span class="cstat-no" title="statement not covered" ></span>n("9bc2");<span class="cstat-no" title="statement not covered" >w</span>w.render=Hy,ww.__scopeId="data-v-c462152a";v</span>ar Ow=<span class="cstat-no" title="statement not covered" >ww,</span>kw=<span class="cstat-no" title="statement not covered" >Object(r["defineComponent"])({name:"section.article",components:{EditorContent:Cd,ArticleLimit:ry,SectionArticleControl:Ow},props:{articleContent:{required:!0,type:Object},editable:{required:!0,type:Boolean},entityId:{required:!0,type:String}},setup:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n=<span class="cstat-no" title="statement not covered" >Object(Lg["c"])(),</span>o=<span class="cstat-no" title="statement not covered" >Object(Gg["e"])(),</span>i=<span class="cstat-no" title="statement not covered" >Object(r["toRefs"])(t),</span>s=<span class="cstat-no" title="statement not covered" >i.articleContent,</span>a=<span class="cstat-no" title="statement not covered" >i.editable,</span>c=<span class="cstat-no" title="statement not covered" >Object(r["computed"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o.state.repositoryEditor.repositoryEntityList}</span>)),</span>l=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(280),</span>p=<span class="cstat-no" title="statement not covered" >Object(r["ref"])(0),</span>u=<span class="cstat-no" title="statement not covered" >mv.extend({renderHTML:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e=<span class="cstat-no" title="statement not covered" >t.node,</span>n=<span class="cstat-no" title="statement not covered" >t.HTMLAttributes;<span class="cstat-no" title="statement not covered" ></span>return["span",Pp(this.options.HTMLAttributes,n),"@".concat(e.attrs.name)]}</span>,addAttributes:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return{name:{default:null,parseHTML:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{name:t.getAttribute("data-mention-name")}}</span>,renderHTML:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.name?{"data-mention-name":t.name}:{}}</span>},id:{default:null,parseHTML:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{id:t.getAttribute("data-mention-id")}}</span>,renderHTML:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.id?{"data-mention-id":t.id}:{}}</span>}}}</span>}),</span>d=<span class="cstat-no" title="statement not covered" >Ed({editable:a.value,content:s.value,extensions:[jd,Ad,Bg,Dd,pv.configure({limit:l.value}),u.configure({HTMLAttributes:{class:"mention"},suggestion:{items:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return c.value}</span>,render:<span class="fstat-no" title="function not covered" >fu</span>nction(){var t,e;<span class="cstat-no" title="statement not covered" >return{onStart:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >d.value&amp;&amp;(t=new Td(cy,{editor:d.value,props:n})),e=wn("body",{getReferenceClientRect:n.clientRect,appendTo:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return document.body}</span>,content:t.element,showOnCreate:!0,interactive:!0,trigger:"manual",placement:"bottom-start"})}</span>,onUpdate:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >t.updateProps(n),e[0].setProps({getReferenceClientRect:n.clientRect})}</span>,onKeyDown:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n;<span class="cstat-no" title="statement not covered" >return null===(n=t.ref)||void 0===n?void 0:n.onKeyDown(e)}</span>,onExit:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >e[0].destroy(),t.destroy()}</span>}}</span>,command:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >t.editor,</span>r=<span class="cstat-no" title="statement not covered" >t.range,</span>o=<span class="cstat-no" title="statement not covered" >t.props;<span class="cstat-no" title="statement not covered" ></span>e.emit("mention",{name:o.name,id:o.id,content:n.getJSON(),contentHtml:n.getHTML(),success:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.chain().focus().insertContentAt(r,[{type:"mention",attrs:{name:o.name,id:o.id}},{type:"text",text:" "}]).run()}</span>,fail:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.chain().focus().insertContentAt(r,[{type:"text",text:o.name}]).run()}</span>})}</span>}}),Ug(<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >Object(h["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >t(</span>e){<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(t.prev=t.next){case 0:<span class="cstat-no" title="statement not covered" >return console.log(e),t.abrupt("return","");c</span>ase 2:case"end":<span class="cstat-no" title="statement not covered" >return t.stop()}</span>}</span></span>),t)}</span>)));<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.apply(this,arguments)}</span>}</span>())],editorProps:{handleClick:<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,r){<span class="cstat-no" title="statement not covered" >return console.log(t,n,r),e.emit("clickMention"),!0}</span>}});<span class="cstat-no" title="statement not covered" ></span>Object(r["onMounted"])(Object(h["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >t(</span>){<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(t.prev=t.next){case 0:<span class="cstat-no" title="statement not covered" >return t.next=2,o.dispatch(Gg["a"].GET_REPOSITORY_BIND_ENTITY_LIST,{repositoryEntityId:n.query.repositoryEntityId});c</span>ase 2:case"end":<span class="cstat-no" title="statement not covered" >return t.stop()}</span>}</span></span>),t)}</span>)))),Object(r["onUnmounted"])((<span class="fstat-no" title="function not covered" >fu</span>nction(){var t;<span class="cstat-no" title="statement not covered" >p.value&amp;&amp;window.clearInterval(p.value),null===(t=d.value)||void 0===t||t.destroy()}</span>)),Object(r["watch"])(s,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e;<span class="cstat-no" title="statement not covered" >null===(e=d.value)||void 0===e||e.commands.setContent(t)}</span>)),Object(r["watch"])(a,(<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e;<span class="cstat-no" title="statement not covered" >null===(e=d.value)||void 0===e||e.setEditable(t)}</span>));v</span>ar f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){var t,n;<span class="cstat-no" title="statement not covered" >e.emit("saveSectionArticle",{content:null===(t=d.value)||void 0===t?void 0:t.getJSON(),contentHtml:null===(n=d.value)||void 0===n?void 0:n.getHTML()})}</span>,</span>m=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >Object(h["a"])(regeneratorRuntime.mark((function <span class="fstat-no" title="function not covered" >t(</span>){var e,n;<span class="cstat-no" title="statement not covered" >return regeneratorRuntime.wrap((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >while(1)<span class="cstat-no" title="statement not covered" >switch(t.prev=t.next){case 0:<span class="cstat-no" title="statement not covered" >n=null===(e=d.value)||void 0===e?void 0:e.commands.setImage({src:"http://file.songxiwen.com.cn/icon1.jpeg",class:"custom-tip-tap-image",height:"300",width:"400"}),console.log(n," ------result");c</span>ase 2:case"end":<span class="cstat-no" title="statement not covered" >return t.stop()}</span>}</span></span>),t)}</span>)));<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.apply(this,arguments)}</span>}</span>();<span class="cstat-no" title="statement not covered" ></span>return{editor:d,limit:l,saveSectionArticle:f,upload:m}}</span>});<span class="cstat-no" title="statement not covered" ></span>n("35bc");<span class="cstat-no" title="statement not covered" >k</span>w.render=u,kw.__scopeId="data-v-5ddadcf2";<span class="cstat-no" title="statement not covered" >e</span>["a"]=kw}</span>,b739:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,ba9a:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,bbbc:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >n("b240")}</span>,be77:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,c408:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,cc00:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,d28b:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var r=<span class="cstat-no" title="statement not covered" >n("746f");<span class="cstat-no" title="statement not covered" ></span>r("iterator")}</span>,e3b7:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,e7fa:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>,efb1:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__createBinding||(Object.create?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=n),Object.defineProperty(t,r,{enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e[n]}</span>})}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,r){<span class="cstat-no" title="statement not covered" >void 0===r&amp;&amp;(r=n),t[r]=e[n]}</span>),</span>o=<span class="cstat-no" title="statement not covered" >this&amp;&amp;this.__exportStar||<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >for(var n in t)<span class="cstat-no" title="statement not covered" >"default"===n||Object.prototype.hasOwnProperty.call(e,n)||r(e,t,n)}</span></span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(e,"__esModule",{value:!0}),o(n("ba9a"),e),o(n("cc00"),e),o(n("3a80"),e),o(n("094f"),e),o(n("a4d6"),e),o(n("b739"),e),o(n("2487"),e),o(n("be77"),e),o(n("79b1"),e),o(n("e3b7"),e),o(n("c408"),e),o(n("7ffa"),e),o(n("fef2"),e),o(n("6e03"),e),o(n("0b53"),e),o(n("238c"),e),o(n("093e"),e),o(n("27f3"),e),o(n("9fb3"),e),o(n("748a"),e),o(n("f0ff"),e),o(n("e7fa"),e)}</span>,f0ff:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0}),e.LogModuleEnum=e.OperationEnum=void 0,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["Create"]="Create",t["Update"]="Update",t["Get"]="Get",t["Delete"]="Delete"}</span>(e.OperationEnum||(e.OperationEnum={})),<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t["KnowledgeBaseType"]="KnowledgeBaseType",t["PullRequest"]="PullRequest"}</span>(e.LogModuleEnum||(e.LogModuleEnum={}))}</span>,fb6a:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";var r=<span class="cstat-no" title="statement not covered" >n("23e7"),</span>o=<span class="cstat-no" title="statement not covered" >n("861d"),</span>i=<span class="cstat-no" title="statement not covered" >n("e8b5"),</span>s=<span class="cstat-no" title="statement not covered" >n("23cb"),</span>a=<span class="cstat-no" title="statement not covered" >n("50c4"),</span>c=<span class="cstat-no" title="statement not covered" >n("fc6a"),</span>l=<span class="cstat-no" title="statement not covered" >n("8418"),</span>p=<span class="cstat-no" title="statement not covered" >n("b622"),</span>u=<span class="cstat-no" title="statement not covered" >n("1dde"),</span>h=<span class="cstat-no" title="statement not covered" >u("slice"),</span>d=<span class="cstat-no" title="statement not covered" >p("species"),</span>f=<span class="cstat-no" title="statement not covered" >[].slice,</span>m=<span class="cstat-no" title="statement not covered" >Math.max;<span class="cstat-no" title="statement not covered" ></span>r({target:"Array",proto:!0,forced:!h},{slice:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var n,r,p,u=<span class="cstat-no" title="statement not covered" >c(this),</span>h=<span class="cstat-no" title="statement not covered" >a(u.length),</span>v=<span class="cstat-no" title="statement not covered" >s(t,h),</span>g=<span class="cstat-no" title="statement not covered" >s(void 0===e?h:e,h);<span class="cstat-no" title="statement not covered" ></span>if(i(u)&amp;&amp;(n=u.constructor,"function"!=typeof n||n!==Array&amp;&amp;!i(n.prototype)?o(n)&amp;&amp;(n=n[d],null===n&amp;&amp;(n=void 0)):n=void 0,n===Array||void 0===n))<span class="cstat-no" title="statement not covered" >return f.call(u,v,g);<span class="cstat-no" title="statement not covered" >f</span></span>or(r=new(void 0===n?Array:n)(m(g-v,0)),p=0;v&lt;g;v++,p++)<span class="cstat-no" title="statement not covered" >v in u&amp;&amp;l(r,p,u[v]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.length=p,r}</span>})}</span>,fef2:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){"use strict";<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"__esModule",{value:!0})}</span>}]);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Tue Oct 19 2021 11:19:47 GMT+0800 (China Standard Time)
            </div>
        </div>
        <script src="../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../sorter.js"></script>
        <script src="../../../block-navigation.js"></script>
    </body>
</html>
    